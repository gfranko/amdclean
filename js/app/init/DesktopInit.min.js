(function() {var jquery, underscore, backbone, esprima, estraverse, escodegen, amdclean, codemirror, codemirror_javascript, codemirror_closebrackets, codemirror_matchbrackets, views_View, routers_router, desktop;
(function () {
    /*!
     * jQuery JavaScript Library v2.0.3
     * http://jquery.com/
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     *
     * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2013-07-03T13:30Z
     */
    (function (window, undefined) {
        // Can't do this because several apps including ASP.NET trace
        // the stack via arguments.caller.callee and Firefox dies if
        // you try to trace through "use strict" call chains. (#13335)
        // Support: Firefox 18+
        //"use strict";
        var
            // A central reference to the root jQuery(document)
            rootjQuery,
            // The deferred used on DOM ready
            readyList,
            // Support: IE9
            // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
            core_strundefined = typeof undefined,
            // Use the correct document accordingly with window argument (sandbox)
            location = window.location, document = window.document, docElem = document.documentElement,
            // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,
            // Map over the $ in case of overwrite
            _$ = window.$,
            // [[Class]] -> type pairs
            class2type = {},
            // List of deleted data cache ids, so we can reuse them
            core_deletedIds = [], core_version = '2.0.3',
            // Save a reference to some core methods
            core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim,
            // Define a local copy of jQuery
            jQuery = function (selector, context) {
                // The jQuery object is actually just the init constructor 'enhanced'
                return new jQuery.fn.init(selector, context, rootjQuery);
            },
            // Used for matching numbers
            core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            // Used for splitting on whitespace
            core_rnotwhite = /\S+/g,
            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
            // Match a standalone tag
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
            // Matches dashed string for camelizing
            rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi,
            // Used by jQuery.camelCase as callback to replace()
            fcamelCase = function (all, letter) {
                return letter.toUpperCase();
            },
            // The ready event handler and self cleanup method
            completed = function () {
                document.removeEventListener('DOMContentLoaded', completed, false);
                window.removeEventListener('load', completed, false);
                jQuery.ready();
            };
        jQuery.fn = jQuery.prototype = {
            jquery: core_version,
            constructor: jQuery,
            init: function (selector, context, rootjQuery) {
                var match, elem;
                // HANDLE: $(""), $(null), $(undefined), $(false)
                if (!selector) {
                    return this;
                }
                // Handle HTML strings
                if (typeof selector === 'string') {
                    if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [
                            null,
                            selector,
                            null
                        ];
                    } else {
                        match = rquickExpr.exec(selector);
                    }
                    // Match html or make sure no context is specified for #id
                    if (match && (match[1] || !context)) {
                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            // scripts is true for back-compat
                            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                            // HANDLE: $(html, props)
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    // Properties of context are called as methods if possible
                                    if (jQuery.isFunction(this[match])) {
                                        this[match](context[match]);    // ...and otherwise set as attributes
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
                            return this;    // HANDLE: $(#id)
                        } else {
                            elem = document.getElementById(match[2]);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }
                            this.context = document;
                            this.selector = selector;
                            return this;
                        }    // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);    // HANDLE: $(expr, context)
                                                                          // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }    // HANDLE: $(DOMElement)
                } else if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;    // HANDLE: $(function)
                                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }
                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }
                return jQuery.makeArray(selector, this);
            },
            selector: '',
            length: 0,
            toArray: function () {
                return core_slice.call(this);
            },
            get: function (num) {
                return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
            },
            pushStack: function (elems) {
                // Build a new jQuery matched element set
                var ret = jQuery.merge(this.constructor(), elems);
                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;
                ret.context = this.context;
                // Return the newly-formed element set
                return ret;
            },
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },
            ready: function (fn) {
                // Add the callback
                jQuery.ready.promise().done(fn);
                return this;
            },
            slice: function () {
                return this.pushStack(core_slice.apply(this, arguments));
            },
            first: function () {
                return this.eq(0);
            },
            last: function () {
                return this.eq(-1);
            },
            eq: function (i) {
                var len = this.length, j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            end: function () {
                return this.prevObject || this.constructor(null);
            },
            push: core_push,
            sort: [].sort,
            splice: [].splice
        };
        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;
        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            // Handle a deep copy situation
            if (typeof target === 'boolean') {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }
            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== 'object' && !jQuery.isFunction(target)) {
                target = {};
            }
            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }
            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }
                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }
                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);    // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            // Return the modified object
            return target;
        };
        jQuery.extend({
            expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
            noConflict: function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }
                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }
                return jQuery;
            },
            isReady: false,
            readyWait: 1,
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },
            ready: function (wait) {
                // Abort if there are pending holds or we're already ready
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }
                // Remember that the DOM is ready
                jQuery.isReady = true;
                // If a normal DOM Ready event fired, decrement, and wait if need be
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }
                // If there are functions bound, to execute
                readyList.resolveWith(document, [jQuery]);
                // Trigger any bound ready events
                if (jQuery.fn.trigger) {
                    jQuery(document).trigger('ready').off('ready');
                }
            },
            isFunction: function (obj) {
                return jQuery.type(obj) === 'function';
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return obj != null && obj === obj.window;
            },
            isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
            },
            type: function (obj) {
                if (obj == null) {
                    return String(obj);
                }
                // Support: Safari <= 5.1 (functionish RegExp)
                return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
            },
            isPlainObject: function (obj) {
                // Not plain objects:
                // - Any object or value whose internal [[Class]] property is not "[object Object]"
                // - DOM nodes
                // - window
                if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }
                // Support: Firefox <20
                // The try/catch suppresses exceptions thrown when attempting to access
                // the "constructor" property of certain host objects, ie. |window.location|
                // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
                try {
                    if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
                // If the function hasn't returned already, we're confident that
                // |obj| is a plain object, created by {} or constructed with new Object
                return true;
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            error: function (msg) {
                throw new Error(msg);
            },
            parseHTML: function (data, context, keepScripts) {
                if (!data || typeof data !== 'string') {
                    return null;
                }
                if (typeof context === 'boolean') {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;
                var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
                // Single tag
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }
                parsed = jQuery.buildFragment([data], context, scripts);
                if (scripts) {
                    jQuery(scripts).remove();
                }
                return jQuery.merge([], parsed.childNodes);
            },
            parseJSON: JSON.parse,
            parseXML: function (data) {
                var xml, tmp;
                if (!data || typeof data !== 'string') {
                    return null;
                }
                // Support: IE9
                try {
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, 'text/xml');
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || xml.getElementsByTagName('parsererror').length) {
                    jQuery.error('Invalid XML: ' + data);
                }
                return xml;
            },
            noop: function () {
            },
            globalEval: function (code) {
                var script, indirect = eval;
                code = jQuery.trim(code);
                if (code) {
                    // If the code includes a valid, prologue position
                    // strict mode pragma, execute code by injecting a
                    // script tag into the document.
                    if (code.indexOf('use strict') === 1) {
                        script = document.createElement('script');
                        script.text = code;
                        document.head.appendChild(script).parentNode.removeChild(script);
                    } else {
                        // Otherwise, avoid the DOM node creation, insertion
                        // and removal by using an indirect global eval
                        indirect(code);
                    }
                }
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            },
            each: function (obj, callback, args) {
                var value, i = 0, length = obj.length, isArray = isArraylike(obj);
                if (args) {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.apply(obj[i], args);
                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.apply(obj[i], args);
                            if (value === false) {
                                break;
                            }
                        }
                    }    // A special, fast, case for the most common use of each
                } else {
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback.call(obj[i], i, obj[i]);
                            if (value === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            value = callback.call(obj[i], i, obj[i]);
                            if (value === false) {
                                break;
                            }
                        }
                    }
                }
                return obj;
            },
            trim: function (text) {
                return text == null ? '' : core_trim.call(text);
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                if (arr != null) {
                    if (isArraylike(Object(arr))) {
                        jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                    } else {
                        core_push.call(ret, arr);
                    }
                }
                return ret;
            },
            inArray: function (elem, arr, i) {
                return arr == null ? -1 : core_indexOf.call(arr, elem, i);
            },
            merge: function (first, second) {
                var l = second.length, i = first.length, j = 0;
                if (typeof l === 'number') {
                    for (; j < l; j++) {
                        first[i++] = second[j];
                    }
                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }
                first.length = i;
                return first;
            },
            grep: function (elems, callback, inv) {
                var retVal, ret = [], i = 0, length = elems.length;
                inv = !!inv;
                // Go through the array, only saving the items
                // that pass the validator function
                for (; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }
                return ret;
            },
            map: function (elems, callback, arg) {
                var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
                // Go through the array, translating each of the items to their
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }    // Go through every key on the object,
                } else {
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret[ret.length] = value;
                        }
                    }
                }
                // Flatten any nested arrays
                return core_concat.apply([], ret);
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                if (typeof context === 'string') {
                    tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }
                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }
                // Simulated bind
                args = core_slice.call(arguments, 2);
                proxy = function () {
                    return fn.apply(context || this, args.concat(core_slice.call(arguments)));
                };
                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                return proxy;
            },
            access: function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0, length = elems.length, bulk = key == null;
                // Sets many values
                if (jQuery.type(key) === 'object') {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;
                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }
                    if (bulk) {
                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;    // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function (elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }
                    if (fn) {
                        for (; i < length; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }
                return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
            },
            now: Date.now,
            swap: function (elem, options, callback, args) {
                var ret, name, old = {};
                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                // Revert the old values
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            }
        });
        jQuery.ready.promise = function (obj) {
            if (!readyList) {
                readyList = jQuery.Deferred();
                // Catch cases where $(document).ready() is called after the browser event has already occurred.
                // we once tried to use readyState "interactive" here, but it caused issues like the one
                // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
                if (document.readyState === 'complete') {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    setTimeout(jQuery.ready);
                } else {
                    // Use the handy event callback
                    document.addEventListener('DOMContentLoaded', completed, false);
                    // A fallback to window.onload, that will always work
                    window.addEventListener('load', completed, false);
                }
            }
            return readyList.promise(obj);
        };
        // Populate the class2type map
        jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
            class2type['[object ' + name + ']'] = name.toLowerCase();
        });
        function isArraylike(obj) {
            var length = obj.length, type = jQuery.type(obj);
            if (jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.nodeType === 1 && length) {
                return true;
            }
            return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
        }
        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);
        /*!
         * Sizzle CSS Selector Engine v1.9.4-pre
         * http://sizzlejs.com/
         *
         * Copyright 2013 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2013-06-03
         */
        (function (window, undefined) {
            var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput,
                // Local document vars
                setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
                // Instance-specific data
                expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    return 0;
                },
                // General-purpose constants
                strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31,
                // Instance methods
                hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice,
                // Use a stripped-down indexOf if we can't use a native one
                indexOf = arr.indexOf || function (elem) {
                    var i = 0, len = this.length;
                    for (; i < len; i++) {
                        if (this[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
                // Regular expressions
                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = '[\\x20\\t\\r\\n\\f]',
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',
                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace('w', 'w#'),
                // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]',
                // Prefer arguments quoted,
                //   then not containing pseudos/brackets,
                //   then attribute selectors/non-parenthetical expressions,
                //   then anything else
                // These preferences are here to reduce the number of selectors
                //   needing tokenize in the PSEUDO preFilter
                pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)',
                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                    'ID': new RegExp('^#(' + characterEncoding + ')'),
                    'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                    'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                    'ATTR': new RegExp('^' + attributes),
                    'PSEUDO': new RegExp('^' + pseudos),
                    'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                    'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                    'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
                }, rnative = /^[^{]+\{\s*\[native \w/,
                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g,
                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                    var high = '0x' + escaped - 65536;
                    // NaN means non-codepoint
                    // Support: Firefox
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
                };
            // Optimize for push.apply( _, NodeList )
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ? function (target, els) {
                        push_native.apply(target, slice.call(els));
                    } : function (target, els) {
                        var j = target.length, i = 0;
                        // Can't trust NodeList.length
                        while (target[j++] = els[i++]) {
                        }
                        target.length = j - 1;
                    }
                };
            }
            function Sizzle(selector, context, results, seed) {
                var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                results = results || [];
                if (!selector || typeof selector !== 'string') {
                    return results;
                }
                if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                    return [];
                }
                if (documentIsHTML && !seed) {
                    // Shortcuts
                    if (match = rquickExpr.exec(selector)) {
                        // Speed-up: Sizzle("#ID")
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                elem = context.getElementById(m);
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document #6963
                                if (elem && elem.parentNode) {
                                    // Handle the case where IE, Opera, and Webkit return items
                                    // by name instead of ID
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                // Context is not a document
                                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }    // Speed-up: Sizzle("TAG")
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;    // Speed-up: Sizzle(".CLASS")
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    // QSA path
                    if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType === 9 && selector;
                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                            groups = tokenize(selector);
                            if (old = context.getAttribute('id')) {
                                nid = old.replace(rescape, '\\$&');
                            } else {
                                context.setAttribute('id', nid);
                            }
                            nid = '[id=\'' + nid + '\'] ';
                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + toSelector(groups[i]);
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(',');
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (!old) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
                // All others
                return select(selector.replace(rtrim, '$1'), context, results, seed);
            }
            /**
             * Create key-value caches of limited size
             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];
                function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key += ' ') > Expr.cacheLength) {
                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return cache[key] = value;
                }
                return cache;
            }
            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }
            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert(fn) {
                var div = document.createElement('div');
                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    // release memory in IE
                    div = null;
                }
            }
            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split('|'), i = attrs.length;
                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }
            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }
                // Check if b follows a
                if (cur) {
                    while (cur = cur.nextSibling) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }
                return a ? 1 : -1;
            }
            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === type;
                };
            }
            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === 'input' || name === 'button') && elem.type === type;
                };
            }
            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[j = matchIndexes[i]]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }
            /**
             * Detect xml
             * @param {Element|Object} elem An element or a document
             */
            isXML = Sizzle.isXML = function (elem) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== 'HTML' : false;
            };
            // Expose support vars for convenience
            support = Sizzle.support = {};
            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
                // If no document and documentElement is available, return
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }
                // Set our document
                document = doc;
                docElem = doc.documentElement;
                // Support tests
                documentIsHTML = !isXML(doc);
                // Support: IE>8
                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                // IE6-8 do not support the defaultView property so parent will be undefined
                if (parent && parent.attachEvent && parent !== parent.top) {
                    parent.attachEvent('onbeforeunload', function () {
                        setDocument();
                    });
                }
                /* Attributes
                	---------------------------------------------------------------------- */
                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
                support.attributes = assert(function (div) {
                    div.className = 'i';
                    return !div.getAttribute('className');
                });
                /* getElement(s)By*
                	---------------------------------------------------------------------- */
                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (div) {
                    div.appendChild(doc.createComment(''));
                    return !div.getElementsByTagName('*').length;
                });
                // Check if getElementsByClassName can be trusted
                support.getElementsByClassName = assert(function (div) {
                    div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                    // Support: Safari<4
                    // Catch class over-caching
                    div.firstChild.className = 'i';
                    // Support: Opera<10
                    // Catch gEBCN failure to find non-leading classes
                    return div.getElementsByClassName('i').length === 2;
                });
                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                });
                // ID find and filter
                if (support.getById) {
                    Expr.find['ID'] = function (id, context) {
                        if (typeof context.getElementById !== strundefined && documentIsHTML) {
                            var m = context.getElementById(id);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [m] : [];
                        }
                    };
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute('id') === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find['ID'];
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                            return node && node.value === attrId;
                        };
                    };
                }
                // Tag
                Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                    if (typeof context.getElementsByTagName !== strundefined) {
                        return context.getElementsByTagName(tag);
                    }
                } : function (tag, context) {
                    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                    // Filter out possible comments
                    if (tag === '*') {
                        while (elem = results[i++]) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem);
                            }
                        }
                        return tmp;
                    }
                    return results;
                };
                // Class
                Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };
                /* QSA/matchesSelector
                	---------------------------------------------------------------------- */
                // QSA and matchesSelector support
                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];
                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];
                if (support.qsa = rnative.test(doc.querySelectorAll)) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (div) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        div.innerHTML = '<select><option selected=\'\'></option></select>';
                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!div.querySelectorAll('[selected]').length) {
                            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                        }
                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(':checked').length) {
                            rbuggyQSA.push(':checked');
                        }
                    });
                    assert(function (div) {
                        // Support: Opera 10-12/IE8
                        // ^= $= *= and empty values
                        // Should not select anything
                        // Support: Windows 8 Native Apps
                        // The type attribute is restricted during .innerHTML assignment
                        var input = doc.createElement('input');
                        input.setAttribute('type', 'hidden');
                        div.appendChild(input).setAttribute('t', '');
                        if (div.querySelectorAll('[t^=\'\']').length) {
                            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                        }
                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (!div.querySelectorAll(':enabled').length) {
                            rbuggyQSA.push(':enabled', ':disabled');
                        }
                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll('*,:x');
                        rbuggyQSA.push(',.*:');
                    });
                }
                if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                    assert(function (div) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(div, 'div');
                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(div, '[s!=\'\']:x');
                        rbuggyMatches.push('!=', pseudos);
                    });
                }
                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
                /* Contains
                	---------------------------------------------------------------------- */
                // Element contains another
                // Purposefully does not implement inclusive descendent
                // As in, an element does not contain itself
                contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
                    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                } : function (a, b) {
                    if (b) {
                        while (b = b.parentNode) {
                            if (b === a) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                /* Sorting
                	---------------------------------------------------------------------- */
                // Document order sorting
                sortOrder = docElem.compareDocumentPosition ? function (a, b) {
                    // Flag for duplicate removal
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
                    if (compare) {
                        // Disconnected nodes
                        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                            // Choose the first element that is related to our preferred document
                            if (a === doc || contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === doc || contains(preferredDoc, b)) {
                                return 1;
                            }
                            // Maintain original order
                            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                        }
                        return compare & 4 ? -1 : 1;
                    }
                    // Not directly comparable, sort on existence of method
                    return a.compareDocumentPosition ? -1 : 1;
                } : function (a, b) {
                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                    // Exit early if the nodes are identical
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;    // Parentless nodes are either documents or disconnected
                    } else if (!aup || !bup) {
                        return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;    // If the nodes are siblings, we can do a quick check
                    } else if (aup === bup) {
                        return siblingCheck(a, b);
                    }
                    // Otherwise we need full lists of their ancestors for comparison
                    cur = a;
                    while (cur = cur.parentNode) {
                        ap.unshift(cur);
                    }
                    cur = b;
                    while (cur = cur.parentNode) {
                        bp.unshift(cur);
                    }
                    // Walk down the tree looking for a discrepancy
                    while (ap[i] === bp[i]) {
                        i++;
                    }
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                };
                return doc;
            };
            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };
            Sizzle.matchesSelector = function (elem, expr) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                // Make sure that attribute selectors are quoted
                expr = expr.replace(rattributeQuotes, '=\'$1\']');
                if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);
                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                    }
                }
                return Sizzle(expr, document, null, [elem]).length > 0;
            };
            Sizzle.contains = function (context, elem) {
                // Set document vars if needed
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };
            Sizzle.attr = function (elem, name) {
                // Set document vars if needed
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
            };
            Sizzle.error = function (msg) {
                throw new Error('Syntax error, unrecognized expression: ' + msg);
            };
            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem, duplicates = [], j = 0, i = 0;
                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);
                if (hasDuplicate) {
                    while (elem = results[i++]) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }
                return results;
            };
            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node, ret = '', i = 0, nodeType = elem.nodeType;
                if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    for (; node = elem[i]; i++) {
                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (see #11153)
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes
                return ret;
            };
            Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    '>': {
                        dir: 'parentNode',
                        first: true
                    },
                    ' ': { dir: 'parentNode' },
                    '+': {
                        dir: 'previousSibling',
                        first: true
                    },
                    '~': { dir: 'previousSibling' }
                },
                preFilter: {
                    'ATTR': function (match) {
                        match[1] = match[1].replace(runescape, funescape);
                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                        if (match[2] === '~=') {
                            match[3] = ' ' + match[3] + ' ';
                        }
                        return match.slice(0, 4);
                    },
                    'CHILD': function (match) {
                        /* matches from matchExpr["CHILD"]
                        		1 type (only|nth|...)
                        		2 what (child|of-type)
                        		3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                        		4 xn-component of xn+y argument ([+-]?\d*n|)
                        		5 sign of xn-component
                        		6 x of xn-component
                        		7 sign of y-component
                        		8 y of y-component
                        	*/
                        match[1] = match[1].toLowerCase();
                        if (match[1].slice(0, 3) === 'nth') {
                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }
                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                            match[5] = +(match[7] + match[8] || match[3] === 'odd');    // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }
                        return match;
                    },
                    'PSEUDO': function (match) {
                        var excess, unquoted = !match[5] && match[2];
                        if (matchExpr['CHILD'].test(match[0])) {
                            return null;
                        }
                        // Accept quoted arguments as-is
                        if (match[3] && match[4] !== undefined) {
                            match[2] = match[4];    // Strip excess characters from unquoted arguments
                        } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }
                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    }
                },
                filter: {
                    'TAG': function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === '*' ? function () {
                            return true;
                        } : function (elem) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                        };
                    },
                    'CLASS': function (className) {
                        var pattern = classCache[className + ' '];
                        return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                        });
                    },
                    'ATTR': function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);
                            if (result == null) {
                                return operator === '!=';
                            }
                            if (!operator) {
                                return true;
                            }
                            result += '';
                            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                        };
                    },
                    'CHILD': function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                        return first === 1 && last === 0 ? function (elem) {
                            return !!elem.parentNode;
                        } : function (elem, context, xml) {
                            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                            if (parent) {
                                // :(first|last|only)-(child|of-type)
                                if (simple) {
                                    while (dir) {
                                        node = elem;
                                        while (node = node[dir]) {
                                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                return false;
                                            }
                                        }
                                        // Reverse direction for :only-* (if we haven't yet done so)
                                        start = dir = type === 'only' && !start && 'nextSibling';
                                    }
                                    return true;
                                }
                                start = [forward ? parent.firstChild : parent.lastChild];
                                // non-xml :nth-child(...) stores cache data on `parent`
                                if (forward && useCache) {
                                    // Seek `elem` from a previously-cached index
                                    outerCache = parent[expando] || (parent[expando] = {});
                                    cache = outerCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = cache[0] === dirruns && cache[2];
                                    node = nodeIndex && parent.childNodes[nodeIndex];
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        // When found, cache indexes on `parent` and break
                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                            outerCache[type] = [
                                                dirruns,
                                                nodeIndex,
                                                diff
                                            ];
                                            break;
                                        }
                                    }    // Use previously-cached element index if available
                                } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                    diff = cache[1];    // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                } else {
                                    // Use the same loop as above to seek `elem` from the start
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            // Cache the index of each encountered element
                                            if (useCache) {
                                                (node[expando] || (node[expando] = {}))[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                                // Incorporate the offset, then check against cycle size
                                diff -= last;
                                return diff === first || diff % first === 0 && diff / first >= 0;
                            }
                        };
                    },
                    'PSEUDO': function (pseudo, argument) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }
                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [
                                pseudo,
                                pseudo,
                                '',
                                argument
                            ];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                var idx, matched = fn(seed, argument), i = matched.length;
                                while (i--) {
                                    idx = indexOf.call(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i]);
                                }
                            }) : function (elem) {
                                return fn(elem, 0, args);
                            };
                        }
                        return fn;
                    }
                },
                pseudos: {
                    'not': markFunction(function (selector) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                            // Match elements unmatched by `matcher`
                            while (i--) {
                                if (elem = unmatched[i]) {
                                    seed[i] = !(matches[i] = elem);
                                }
                            }
                        }) : function (elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            return !results.pop();
                        };
                    }),
                    'has': markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),
                    'contains': markFunction(function (text) {
                        return function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),
                    'lang': markFunction(function (lang) {
                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || '')) {
                            Sizzle.error('unsupported lang: ' + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),
                    'target': function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },
                    'root': function (elem) {
                        return elem === docElem;
                    },
                    'focus': function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },
                    'enabled': function (elem) {
                        return elem.disabled === false;
                    },
                    'disabled': function (elem) {
                        return elem.disabled === true;
                    },
                    'checked': function (elem) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                    },
                    'selected': function (elem) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }
                        return elem.selected === true;
                    },
                    'empty': function (elem) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
                        //   not comment, processing instructions, or others
                        // Thanks to Diego Perini for the nodeName shortcut
                        //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
                                return false;
                            }
                        }
                        return true;
                    },
                    'parent': function (elem) {
                        return !Expr.pseudos['empty'](elem);
                    },
                    'header': function (elem) {
                        return rheader.test(elem.nodeName);
                    },
                    'input': function (elem) {
                        return rinputs.test(elem.nodeName);
                    },
                    'button': function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === 'input' && elem.type === 'button' || name === 'button';
                    },
                    'text': function (elem) {
                        var attr;
                        // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                        // use getAttribute instead to test this case
                        return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
                    },
                    'first': createPositionalPseudo(function () {
                        return [0];
                    }),
                    'last': createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),
                    'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),
                    'even': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'odd': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };
            Expr.pseudos['nth'] = Expr.pseudos['eq'];
            // Add button/input type pseudos
            for (i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true
                }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {
                    submit: true,
                    reset: true
                }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }
            // Easy API for creating new setFilters
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            function tokenize(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }
                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;
                while (soFar) {
                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push(tokens = []);
                    }
                    matched = false;
                    // Combinators
                    if (match = rcombinators.exec(soFar)) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, ' ')
                        });
                        soFar = soFar.slice(matched.length);
                    }
                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }
                    if (!matched) {
                        break;
                    }
                }
                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
            }
            function toSelector(tokens) {
                var i = 0, len = tokens.length, selector = '';
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }
            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
                return combinator.first ? function (elem, context, xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml);
                        }
                    }
                } : function (elem, context, xml) {
                    var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
                    // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                    if (xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                if (matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    } else {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                                    if ((data = cache[1]) === true || data === cachedruns) {
                                        return data === true;
                                    }
                                } else {
                                    cache = outerCache[dir] = [dirkey];
                                    cache[1] = matcher(elem, context, xml) || cachedruns;
                                    if (cache[1] === true) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                };
            }
            function elementMatcher(matchers) {
                return matchers.length > 1 ? function (elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false;
                        }
                    }
                    return true;
                } : matchers[0];
            }
            function condense(unmatched, map, filter, context, xml) {
                var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                for (; i < len; i++) {
                    if (elem = unmatched[i]) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }
                return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }
                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);
                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if (elem = temp[i]) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if (elem = matcherOut[i]) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push(matcherIn[i] = elem);
                                    }
                                }
                                postFinder(null, matcherOut = [], temp, xml);
                            }
                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }    // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }
            function matcherFromTokens(tokens) {
                var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0,
                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                        return indexOf.call(checkContext, elem) > -1;
                    }, implicitRelative, true), matchers = [function (elem, context, xml) {
                            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        }];
                for (; i < len; i++) {
                    if (matcher = Expr.relative[tokens[i].type]) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                        }
                        matchers.push(matcher);
                    }
                }
                return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                // A counter to specify which element is currently being matched
                var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
                        var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext,
                            // We must always have either seed elements or context
                            elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
                        if (outermost) {
                            outermostContext = context !== document && context;
                            cachedruns = matcherCachedRuns;
                        }
                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        for (; (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                while (matcher = elementMatchers[j++]) {
                                    if (matcher(elem, context, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    cachedruns = ++matcherCachedRuns;
                                }
                            }
                            // Track unmatched elements for set filters
                            if (bySet) {
                                // They will have gone through all possible matchers
                                if (elem = !matcher && elem) {
                                    matchedCount--;
                                }
                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }
                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while (matcher = setMatchers[j++]) {
                                matcher(unmatched, setMatched, context, xml);
                            }
                            if (seed) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }
                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }
                            // Add matches to results
                            push.apply(results, setMatched);
                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }
                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }
                        return unmatched;
                    };
                return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle.compile = function (selector, group) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
                if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!group) {
                        group = tokenize(selector);
                    }
                    i = group.length;
                    while (i--) {
                        cached = matcherFromTokens(group[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }
                    // Cache the compiled function
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                }
                return cached;
            };
            function multipleContexts(selector, contexts, results) {
                var i = 0, len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }
            function select(selector, context, results, seed) {
                var i, tokens, token, type, find, match = tokenize(selector);
                if (!seed) {
                    // Try to minimize operations if there is only one group
                    if (match.length === 1) {
                        // Take a shortcut and set the context if the root selector is an ID
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results;
                            }
                            selector = selector.slice(tokens.shift().value.length);
                        }
                        // Fetch a seed set for right-to-left matching
                        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
                            // Abort if we hit a combinator
                            if (Expr.relative[type = token.type]) {
                                break;
                            }
                            if (find = Expr.find[type]) {
                                // Search, expanding context for leading sibling combinators
                                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                                    // If seed is empty or no tokens remain, we can return early
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                // Compile and execute a filtering function
                // Provide `match` to avoid retokenization if we modified the selector above
                compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
                return results;
            }
            // One-time assignments
            // Sort stability
            support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
            // Support: Chrome<14
            // Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = hasDuplicate;
            // Initialize against the default document
            setDocument();
            // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
            // Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (div1) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition(document.createElement('div')) & 1;
            });
            // Support: IE<8
            // Prevent attribute/property "interpolation"
            // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!assert(function (div) {
                    div.innerHTML = '<a href=\'#\'></a>';
                    return div.firstChild.getAttribute('href') === '#';
                })) {
                addHandle('type|href|height|width', function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                    }
                });
            }
            // Support: IE<9
            // Use defaultValue in place of getAttribute("value")
            if (!support.attributes || !assert(function (div) {
                    div.innerHTML = '<input/>';
                    div.firstChild.setAttribute('value', '');
                    return div.firstChild.getAttribute('value') === '';
                })) {
                addHandle('value', function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                        return elem.defaultValue;
                    }
                });
            }
            // Support: IE<9
            // Use getAttributeNode to fetch booleans when getAttribute lies
            if (!assert(function (div) {
                    return div.getAttribute('disabled') == null;
                })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
                    }
                });
            }
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[':'] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;
        }(window));
        // String to Object options format cache
        var optionsCache = {};
        // Convert String-formatted options into Object-formatted ones and store in cache
        function createOptions(options) {
            var object = optionsCache[options] = {};
            jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
                object[flag] = true;
            });
            return object;
        }
        /*
         * Create a callback list using the following parameters:
         *
         *	options: an optional list of space-separated options that will change how
         *			the callback list behaves or a more traditional option object
         *
         * By default a callback list will act like an event callback list and can be
         * "fired" multiple times.
         *
         * Possible options:
         *
         *	once:			will ensure the callback list can only be fired once (like a Deferred)
         *
         *	memory:			will keep track of previous values and will call any callback added
         *					after the list has been fired right away with the latest "memorized"
         *					values (like a Deferred)
         *
         *	unique:			will ensure a callback can only be added once (no duplicate in the list)
         *
         *	stopOnFalse:	interrupt callings when a callback returns false
         *
         */
        jQuery.Callbacks = function (options) {
            // Convert options from String-formatted to Object-formatted if needed
            // (we check in cache first)
            options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
            var
                // Last fire value (for non-forgettable lists)
                memory,
                // Flag to know if list was already fired
                fired,
                // Flag to know if list is currently firing
                firing,
                // First callback to fire (used internally by add and fireWith)
                firingStart,
                // End of the loop when firing
                firingLength,
                // Index of currently firing callback (modified by remove if needed)
                firingIndex,
                // Actual callback list
                list = [],
                // Stack of fire calls for repeatable lists
                stack = !options.once && [],
                // Fire callbacks
                fire = function (data) {
                    memory = options.memory && data;
                    fired = true;
                    firingIndex = firingStart || 0;
                    firingStart = 0;
                    firingLength = list.length;
                    firing = true;
                    for (; list && firingIndex < firingLength; firingIndex++) {
                        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                            memory = false;
                            // To prevent further calls using add
                            break;
                        }
                    }
                    firing = false;
                    if (list) {
                        if (stack) {
                            if (stack.length) {
                                fire(stack.shift());
                            }
                        } else if (memory) {
                            list = [];
                        } else {
                            self.disable();
                        }
                    }
                },
                // Actual Callbacks object
                self = {
                    add: function () {
                        if (list) {
                            // First, we save the current length
                            var start = list.length;
                            (function add(args) {
                                jQuery.each(args, function (_, arg) {
                                    var type = jQuery.type(arg);
                                    if (type === 'function') {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && type !== 'string') {
                                        // Inspect recursively
                                        add(arg);
                                    }
                                });
                            }(arguments));
                            // Do we need to add the callbacks to the
                            // current firing batch?
                            if (firing) {
                                firingLength = list.length;    // With memory, if we're not firing then
                                                               // we should call right away
                            } else if (memory) {
                                firingStart = start;
                                fire(memory);
                            }
                        }
                        return this;
                    },
                    remove: function () {
                        if (list) {
                            jQuery.each(arguments, function (_, arg) {
                                var index;
                                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                    list.splice(index, 1);
                                    // Handle firing indexes
                                    if (firing) {
                                        if (index <= firingLength) {
                                            firingLength--;
                                        }
                                        if (index <= firingIndex) {
                                            firingIndex--;
                                        }
                                    }
                                }
                            });
                        }
                        return this;
                    },
                    has: function (fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                    },
                    empty: function () {
                        list = [];
                        firingLength = 0;
                        return this;
                    },
                    disable: function () {
                        list = stack = memory = undefined;
                        return this;
                    },
                    disabled: function () {
                        return !list;
                    },
                    lock: function () {
                        stack = undefined;
                        if (!memory) {
                            self.disable();
                        }
                        return this;
                    },
                    locked: function () {
                        return !stack;
                    },
                    fireWith: function (context, args) {
                        if (list && (!fired || stack)) {
                            args = args || [];
                            args = [
                                context,
                                args.slice ? args.slice() : args
                            ];
                            if (firing) {
                                stack.push(args);
                            } else {
                                fire(args);
                            }
                        }
                        return this;
                    },
                    fire: function () {
                        self.fireWith(this, arguments);
                        return this;
                    },
                    fired: function () {
                        return !!fired;
                    }
                };
            return self;
        };
        jQuery.extend({
            Deferred: function (func) {
                var tuples = [
                        [
                            'resolve',
                            'done',
                            jQuery.Callbacks('once memory'),
                            'resolved'
                        ],
                        [
                            'reject',
                            'fail',
                            jQuery.Callbacks('once memory'),
                            'rejected'
                        ],
                        [
                            'notify',
                            'progress',
                            jQuery.Callbacks('memory')
                        ]
                    ], state = 'pending', promise = {
                        state: function () {
                            return state;
                        },
                        always: function () {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        then: function () {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                                    // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                        } else {
                                            newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        promise: function (obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    }, deferred = {};
                // Keep pipe for back-compat
                promise.pipe = promise.then;
                // Add list-specific methods
                jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2], stateString = tuple[3];
                    // promise[ done | fail | progress ] = list.add
                    promise[tuple[1]] = list.add;
                    // Handle state
                    if (stateString) {
                        list.add(function () {
                            // state = [ resolved | rejected ]
                            state = stateString;    // [ reject_list | resolve_list ].disable; progress_list.lock
                        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                    }
                    // deferred[ resolve | reject | notify ]
                    deferred[tuple[0]] = function () {
                        deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                        return this;
                    };
                    deferred[tuple[0] + 'With'] = list.fireWith;
                });
                // Make the deferred a promise
                promise.promise(deferred);
                // Call given func if any
                if (func) {
                    func.call(deferred, deferred);
                }
                // All done!
                return deferred;
            },
            when: function (subordinate) {
                var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length,
                    // the count of uncompleted subordinates
                    remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                    // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                    // Update function for both resolve and progress values
                    updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this;
                            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                            if (values === progressValues) {
                                deferred.notifyWith(contexts, values);
                            } else if (!--remaining) {
                                deferred.resolveWith(contexts, values);
                            }
                        };
                    }, progressValues, progressContexts, resolveContexts;
                // add listeners to Deferred subordinates; treat others as resolved
                if (length > 1) {
                    progressValues = new Array(length);
                    progressContexts = new Array(length);
                    resolveContexts = new Array(length);
                    for (; i < length; i++) {
                        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                        } else {
                            --remaining;
                        }
                    }
                }
                // if we're not waiting on anything, resolve the master
                if (!remaining) {
                    deferred.resolveWith(resolveContexts, resolveValues);
                }
                return deferred.promise();
            }
        });
        jQuery.support = function (support) {
            var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
            // Finish early in limited environments
            if (!input.type) {
                return support;
            }
            input.type = 'checkbox';
            // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
            // Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
            support.checkOn = input.value !== '';
            // Must access the parent to make an option select properly
            // Support: IE9, IE10
            support.optSelected = opt.selected;
            // Will be defined later
            support.reliableMarginRight = true;
            support.boxSizingReliable = true;
            support.pixelPosition = false;
            // Make sure checked status is properly cloned
            // Support: IE9, IE10
            input.checked = true;
            support.noCloneChecked = input.cloneNode(true).checked;
            // Make sure that the options inside disabled selects aren't marked as disabled
            // (WebKit marks them as disabled)
            select.disabled = true;
            support.optDisabled = !opt.disabled;
            // Check if an input maintains its value after becoming a radio
            // Support: IE9, IE10
            input = document.createElement('input');
            input.value = 't';
            input.type = 'radio';
            support.radioValue = input.value === 't';
            // #11217 - WebKit loses check when the name is after the checked attribute
            input.setAttribute('checked', 't');
            input.setAttribute('name', 't');
            fragment.appendChild(input);
            // Support: Safari 5.1, Android 4.x, Android 2.3
            // old WebKit doesn't clone checked state correctly in fragments
            support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
            // Support: Firefox, Chrome, Safari
            // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
            support.focusinBubbles = 'onfocusin' in window;
            div.style.backgroundClip = 'content-box';
            div.cloneNode(true).style.backgroundClip = '';
            support.clearCloneStyle = div.style.backgroundClip === 'content-box';
            // Run tests that need a body at doc ready
            jQuery(function () {
                var container, marginDiv,
                    // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
                    divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
                if (!body) {
                    // Return for frameset docs that don't have a body
                    return;
                }
                container = document.createElement('div');
                container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
                // Check box-sizing and margin behavior.
                body.appendChild(container).appendChild(div);
                div.innerHTML = '';
                // Support: Firefox, Android 2.3 (Prefixed box-sizing versions).
                div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
                // Workaround failing boxSizing test due to offsetWidth returning wrong value
                // with some non-1 values of body zoom, ticket #13543
                jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                    support.boxSizing = div.offsetWidth === 4;
                });
                // Use window.getComputedStyle because jsdom on node.js will break without it.
                if (window.getComputedStyle) {
                    support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
                    support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
                    // Support: Android 2.3
                    // Check if div with explicit width and no margin-right incorrectly
                    // gets computed margin-right based on width of container. (#3333)
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                }
                body.removeChild(container);
            });
            return support;
        }({});
        /*
        	Implementation Summary
        
        	1. Enforce API surface and semantic compatibility with 1.9.x branch
        	2. Improve the module's maintainability by reducing the storage
        		paths to a single mechanism.
        	3. Use the same single mechanism to support "private" and "user" data.
        	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
        	5. Avoid exposing implementation details on user objects (eg. expando properties)
        	6. Provide a clear path for implementation upgrade to WeakMap in 2014
        */
        var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
        function Data() {
            // Support: Android < 4,
            // Old WebKit does not have Object.preventExtensions/freeze method,
            // return new empty object instead with no [[set]] accessor
            Object.defineProperty(this.cache = {}, 0, {
                get: function () {
                    return {};
                }
            });
            this.expando = jQuery.expando + Math.random();
        }
        Data.uid = 1;
        Data.accepts = function (owner) {
            // Accepts only:
            //  - Node
            //    - Node.ELEMENT_NODE
            //    - Node.DOCUMENT_NODE
            //  - Object
            //    - Any
            return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
        };
        Data.prototype = {
            key: function (owner) {
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return the key for a frozen object.
                if (!Data.accepts(owner)) {
                    return 0;
                }
                var descriptor = {},
                    // Check if the owner object already has a cache key
                    unlock = owner[this.expando];
                // If not, create one
                if (!unlock) {
                    unlock = Data.uid++;
                    // Secure it in a non-enumerable, non-writable property
                    try {
                        descriptor[this.expando] = { value: unlock };
                        Object.defineProperties(owner, descriptor);    // Support: Android < 4
                                                                       // Fallback to a less secure definition
                    } catch (e) {
                        descriptor[this.expando] = unlock;
                        jQuery.extend(owner, descriptor);
                    }
                }
                // Ensure the cache object
                if (!this.cache[unlock]) {
                    this.cache[unlock] = {};
                }
                return unlock;
            },
            set: function (owner, data, value) {
                var prop,
                    // There may be an unlock assigned to this node,
                    // if there is no entry for this "owner", create one inline
                    // and set the unlock as though an owner entry had always existed
                    unlock = this.key(owner), cache = this.cache[unlock];
                // Handle: [ owner, key, value ] args
                if (typeof data === 'string') {
                    cache[data] = value;    // Handle: [ owner, { properties } ] args
                } else {
                    // Fresh assignments by object are shallow copied
                    if (jQuery.isEmptyObject(cache)) {
                        jQuery.extend(this.cache[unlock], data);    // Otherwise, copy the properties one-by-one to the cache object
                    } else {
                        for (prop in data) {
                            cache[prop] = data[prop];
                        }
                    }
                }
                return cache;
            },
            get: function (owner, key) {
                // Either a valid cache is found, or will be created.
                // New caches will be created and the unlock returned,
                // allowing direct access to the newly created
                // empty data object. A valid owner object must be provided.
                var cache = this.cache[this.key(owner)];
                return key === undefined ? cache : cache[key];
            },
            access: function (owner, key, value) {
                var stored;
                // In cases where either:
                //
                //   1. No key was specified
                //   2. A string key was specified, but no value provided
                //
                // Take the "read" path and allow the get method to determine
                // which value to return, respectively either:
                //
                //   1. The entire cache object
                //   2. The data stored at the key
                //
                if (key === undefined || key && typeof key === 'string' && value === undefined) {
                    stored = this.get(owner, key);
                    return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
                }
                // [*]When the key is not a string, or both a key and value
                // are specified, set or extend (existing objects) with either:
                //
                //   1. An object of properties
                //   2. A key and value
                //
                this.set(owner, key, value);
                // Since the "set" path can have two possible entry points
                // return the expected data based on which path was taken[*]
                return value !== undefined ? value : key;
            },
            remove: function (owner, key) {
                var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
                if (key === undefined) {
                    this.cache[unlock] = {};
                } else {
                    // Support array or space separated string of keys
                    if (jQuery.isArray(key)) {
                        // If "name" is an array of keys...
                        // When data is initially created, via ("key", "val") signature,
                        // keys will be converted to camelCase.
                        // Since there is no way to tell _how_ a key was added, remove
                        // both plain key and camelCase key. #12786
                        // This will only penalize the array argument path.
                        name = key.concat(key.map(jQuery.camelCase));
                    } else {
                        camel = jQuery.camelCase(key);
                        // Try the string as a key before any manipulation
                        if (key in cache) {
                            name = [
                                key,
                                camel
                            ];
                        } else {
                            // If a key with the spaces exists, use it.
                            // Otherwise, create an array by matching non-whitespace
                            name = camel;
                            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
                        }
                    }
                    i = name.length;
                    while (i--) {
                        delete cache[name[i]];
                    }
                }
            },
            hasData: function (owner) {
                return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
            },
            discard: function (owner) {
                if (owner[this.expando]) {
                    delete this.cache[owner[this.expando]];
                }
            }
        };
        // These may be used throughout the jQuery core codebase
        data_user = new Data();
        data_priv = new Data();
        jQuery.extend({
            acceptData: Data.accepts,
            hasData: function (elem) {
                return data_user.hasData(elem) || data_priv.hasData(elem);
            },
            data: function (elem, name, data) {
                return data_user.access(elem, name, data);
            },
            removeData: function (elem, name) {
                data_user.remove(elem, name);
            },
            _data: function (elem, name, data) {
                return data_priv.access(elem, name, data);
            },
            _removeData: function (elem, name) {
                data_priv.remove(elem, name);
            }
        });
        jQuery.fn.extend({
            data: function (key, value) {
                var attrs, name, elem = this[0], i = 0, data = null;
                // Gets all values
                if (key === undefined) {
                    if (this.length) {
                        data = data_user.get(elem);
                        if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
                            attrs = elem.attributes;
                            for (; i < attrs.length; i++) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                            data_priv.set(elem, 'hasDataAttrs', true);
                        }
                    }
                    return data;
                }
                // Sets multiple values
                if (typeof key === 'object') {
                    return this.each(function () {
                        data_user.set(this, key);
                    });
                }
                return jQuery.access(this, function (value) {
                    var data, camelKey = jQuery.camelCase(key);
                    // The calling jQuery object (element matches) is not empty
                    // (and therefore has an element appears at this[ 0 ]) and the
                    // `value` parameter was not undefined. An empty jQuery object
                    // will result in `undefined` for elem = this[ 0 ] which will
                    // throw an exception if an attempt to read a data cache is made.
                    if (elem && value === undefined) {
                        // Attempt to get data from the cache
                        // with the key as-is
                        data = data_user.get(elem, key);
                        if (data !== undefined) {
                            return data;
                        }
                        // Attempt to get data from the cache
                        // with the key camelized
                        data = data_user.get(elem, camelKey);
                        if (data !== undefined) {
                            return data;
                        }
                        // Attempt to "discover" the data in
                        // HTML5 custom data-* attrs
                        data = dataAttr(elem, camelKey, undefined);
                        if (data !== undefined) {
                            return data;
                        }
                        // We tried really hard, but the data doesn't exist.
                        return;
                    }
                    // Set the data...
                    this.each(function () {
                        // First, attempt to store a copy or reference of any
                        // data that might've been store with a camelCased key.
                        var data = data_user.get(this, camelKey);
                        // For HTML5 data-* attribute interop, we have to
                        // store property names with dashes in a camelCase form.
                        // This might not apply to all properties...*
                        data_user.set(this, camelKey, value);
                        // *... In the case of properties that might _actually_
                        // have dashes, we need to also store a copy of that
                        // unchanged property.
                        if (key.indexOf('-') !== -1 && data !== undefined) {
                            data_user.set(this, key, value);
                        }
                    });
                }, null, value, arguments.length > 1, null, true);
            },
            removeData: function (key) {
                return this.each(function () {
                    data_user.remove(this, key);
                });
            }
        });
        function dataAttr(elem, key, data) {
            var name;
            // If nothing was found internally, try to fetch any
            // data from the HTML5 data-* attribute
            if (data === undefined && elem.nodeType === 1) {
                name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
                data = elem.getAttribute(name);
                if (typeof data === 'string') {
                    try {
                        data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
                    } catch (e) {
                    }
                    // Make sure we set the data so it isn't changed later
                    data_user.set(elem, key, data);
                } else {
                    data = undefined;
                }
            }
            return data;
        }
        jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                if (elem) {
                    type = (type || 'fx') + 'queue';
                    queue = data_priv.get(elem, type);
                    // Speed up dequeue by getting out quickly if this is just a lookup
                    if (data) {
                        if (!queue || jQuery.isArray(data)) {
                            queue = data_priv.access(elem, type, jQuery.makeArray(data));
                        } else {
                            queue.push(data);
                        }
                    }
                    return queue || [];
                }
            },
            dequeue: function (elem, type) {
                type = type || 'fx';
                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                        jQuery.dequeue(elem, type);
                    };
                // If the fx queue is dequeued, always remove the progress sentinel
                if (fn === 'inprogress') {
                    fn = queue.shift();
                    startLength--;
                }
                if (fn) {
                    // Add a progress sentinel to prevent the fx queue from being
                    // automatically dequeued
                    if (type === 'fx') {
                        queue.unshift('inprogress');
                    }
                    // clear up the last queue stop function
                    delete hooks.stop;
                    fn.call(elem, next, hooks);
                }
                if (!startLength && hooks) {
                    hooks.empty.fire();
                }
            },
            _queueHooks: function (elem, type) {
                var key = type + 'queueHooks';
                return data_priv.get(elem, key) || data_priv.access(elem, key, {
                    empty: jQuery.Callbacks('once memory').add(function () {
                        data_priv.remove(elem, [
                            type + 'queue',
                            key
                        ]);
                    })
                });
            }
        });
        jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                if (typeof type !== 'string') {
                    data = type;
                    type = 'fx';
                    setter--;
                }
                if (arguments.length < setter) {
                    return jQuery.queue(this[0], type);
                }
                return data === undefined ? this : this.each(function () {
                    var queue = jQuery.queue(this, type, data);
                    // ensure a hooks for this queue
                    jQuery._queueHooks(this, type);
                    if (type === 'fx' && queue[0] !== 'inprogress') {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type);
                });
            },
            delay: function (time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || 'fx';
                return this.queue(type, function (next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function () {
                        clearTimeout(timeout);
                    };
                });
            },
            clearQueue: function (type) {
                return this.queue(type || 'fx', []);
            },
            promise: function (type, obj) {
                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                        if (!--count) {
                            defer.resolveWith(elements, [elements]);
                        }
                    };
                if (typeof type !== 'string') {
                    obj = type;
                    type = undefined;
                }
                type = type || 'fx';
                while (i--) {
                    tmp = data_priv.get(elements[i], type + 'queueHooks');
                    if (tmp && tmp.empty) {
                        count++;
                        tmp.empty.add(resolve);
                    }
                }
                resolve();
                return defer.promise(obj);
            }
        });
        var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
        jQuery.fn.extend({
            attr: function (name, value) {
                return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name);
                });
            },
            prop: function (name, value) {
                return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name];
                });
            },
            addClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).addClass(value.call(this, j, this.className));
                    });
                }
                if (proceed) {
                    // The disjunction here is for better compressibility (see removeClass)
                    classes = (value || '').match(core_rnotwhite) || [];
                    for (; i < len; i++) {
                        elem = this[i];
                        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                    cur += clazz + ' ';
                                }
                            }
                            elem.className = jQuery.trim(cur);
                        }
                    }
                }
                return this;
            },
            removeClass: function (value) {
                var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).removeClass(value.call(this, j, this.className));
                    });
                }
                if (proceed) {
                    classes = (value || '').match(core_rnotwhite) || [];
                    for (; i < len; i++) {
                        elem = this[i];
                        // This expression is here for better compressibility (see addClass)
                        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                // Remove *all* instances
                                while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                    cur = cur.replace(' ' + clazz + ' ', ' ');
                                }
                            }
                            elem.className = value ? jQuery.trim(cur) : '';
                        }
                    }
                }
                return this;
            },
            toggleClass: function (value, stateVal) {
                var type = typeof value;
                if (typeof stateVal === 'boolean' && type === 'string') {
                    return stateVal ? this.addClass(value) : this.removeClass(value);
                }
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                    });
                }
                return this.each(function () {
                    if (type === 'string') {
                        // toggle individual class names
                        var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
                        while (className = classNames[i++]) {
                            // check each className given, space separated list
                            if (self.hasClass(className)) {
                                self.removeClass(className);
                            } else {
                                self.addClass(className);
                            }
                        }    // Toggle whole class name
                    } else if (type === core_strundefined || type === 'boolean') {
                        if (this.className) {
                            // store className if set
                            data_priv.set(this, '__className__', this.className);
                        }
                        // If the element has a class name or if we're passed "false",
                        // then remove the whole classname (if there was one, the above saved it).
                        // Otherwise bring back whatever was previously saved (if anything),
                        // falling back to the empty string if nothing was stored.
                        this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
                    }
                });
            },
            hasClass: function (selector) {
                var className = ' ' + selector + ' ', i = 0, l = this.length;
                for (; i < l; i++) {
                    if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                        return true;
                    }
                }
                return false;
            },
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0];
                if (!arguments.length) {
                    if (elem) {
                        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                        if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                            return ret;
                        }
                        ret = elem.value;
                        return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                    }
                    return;
                }
                isFunction = jQuery.isFunction(value);
                return this.each(function (i) {
                    var val;
                    if (this.nodeType !== 1) {
                        return;
                    }
                    if (isFunction) {
                        val = value.call(this, i, jQuery(this).val());
                    } else {
                        val = value;
                    }
                    // Treat null/undefined as ""; convert numbers to string
                    if (val == null) {
                        val = '';
                    } else if (typeof val === 'number') {
                        val += '';
                    } else if (jQuery.isArray(val)) {
                        val = jQuery.map(val, function (value) {
                            return value == null ? '' : value + '';
                        });
                    }
                    hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                    // If set returns undefined, fall back to normal setting
                    if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                        this.value = val;
                    }
                });
            }
        });
        jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        // attributes.value is undefined in Blackberry 4.7 but
                        // uses .value. See #6932
                        var val = elem.attributes.value;
                        return !val || val.specified ? elem.value : elem.text;
                    }
                },
                select: {
                    get: function (elem) {
                        var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                        // Loop through all the selected options
                        for (; i < max; i++) {
                            option = options[i];
                            // IE6-9 doesn't update selected after form reset (#2551)
                            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                                // Get the specific value for the option
                                value = jQuery(option).val();
                                // We don't need an array for one selects
                                if (one) {
                                    return value;
                                }
                                // Multi-Selects return an array
                                values.push(value);
                            }
                        }
                        return values;
                    },
                    set: function (elem, value) {
                        var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                        while (i--) {
                            option = options[i];
                            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
                                optionSet = true;
                            }
                        }
                        // force browsers to behave consistently when non-matching value is set
                        if (!optionSet) {
                            elem.selectedIndex = -1;
                        }
                        return values;
                    }
                }
            },
            attr: function (elem, name, value) {
                var hooks, ret, nType = elem.nodeType;
                // don't get/set attributes on text, comment and attribute nodes
                if (!elem || nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                // Fallback to prop when attributes are not supported
                if (typeof elem.getAttribute === core_strundefined) {
                    return jQuery.prop(elem, name, value);
                }
                // All attributes are lowercase
                // Grab necessary hook if one is defined
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    name = name.toLowerCase();
                    hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                }
                if (value !== undefined) {
                    if (value === null) {
                        jQuery.removeAttr(elem, name);
                    } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    } else {
                        elem.setAttribute(name, value + '');
                        return value;
                    }
                } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                } else {
                    ret = jQuery.find.attr(elem, name);
                    // Non-existent attributes return null, we normalize to undefined
                    return ret == null ? undefined : ret;
                }
            },
            removeAttr: function (elem, value) {
                var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
                if (attrNames && elem.nodeType === 1) {
                    while (name = attrNames[i++]) {
                        propName = jQuery.propFix[name] || name;
                        // Boolean attributes get special treatment (#10870)
                        if (jQuery.expr.match.bool.test(name)) {
                            // Set corresponding property to false
                            elem[propName] = false;
                        }
                        elem.removeAttribute(name);
                    }
                }
            },
            attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                            // Setting the type on a radio button after the value resets the value in IE6-9
                            // Reset value to default in case type is set after value during creation
                            var val = elem.value;
                            elem.setAttribute('type', value);
                            if (val) {
                                elem.value = val;
                            }
                            return value;
                        }
                    }
                }
            },
            propFix: {
                'for': 'htmlFor',
                'class': 'className'
            },
            prop: function (elem, name, value) {
                var ret, hooks, notxml, nType = elem.nodeType;
                // don't get/set properties on text, comment and attribute nodes
                if (!elem || nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
                if (notxml) {
                    // Fix name and attach hooks
                    name = jQuery.propFix[name] || name;
                    hooks = jQuery.propHooks[name];
                }
                if (value !== undefined) {
                    return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
                } else {
                    return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
                }
            },
            propHooks: {
                tabIndex: {
                    get: function (elem) {
                        return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                    }
                }
            }
        });
        // Hooks for boolean attributes
        boolHook = {
            set: function (elem, value, name) {
                if (value === false) {
                    // Remove boolean attributes when set to false
                    jQuery.removeAttr(elem, name);
                } else {
                    elem.setAttribute(name, name);
                }
                return name;
            }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
            var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
            jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
                var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
                // Restore handler
                jQuery.expr.attrHandle[name] = fn;
                return ret;
            };
        });
        // Support: IE9+
        // Selectedness for an option in an optgroup can be inaccurate
        if (!jQuery.support.optSelected) {
            jQuery.propHooks.selected = {
                get: function (elem) {
                    var parent = elem.parentNode;
                    if (parent && parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                    return null;
                }
            };
        }
        jQuery.each([
            'tabIndex',
            'readOnly',
            'maxLength',
            'cellSpacing',
            'cellPadding',
            'rowSpan',
            'colSpan',
            'useMap',
            'frameBorder',
            'contentEditable'
        ], function () {
            jQuery.propFix[this.toLowerCase()] = this;
        });
        // Radios and checkboxes getter/setter
        jQuery.each([
            'radio',
            'checkbox'
        ], function () {
            jQuery.valHooks[this] = {
                set: function (elem, value) {
                    if (jQuery.isArray(value)) {
                        return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                    }
                }
            };
            if (!jQuery.support.checkOn) {
                jQuery.valHooks[this].get = function (elem) {
                    // Support: Webkit
                    // "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute('value') === null ? 'on' : elem.value;
                };
            }
        });
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
        function returnTrue() {
            return true;
        }
        function returnFalse() {
            return false;
        }
        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch (err) {
            }
        }
        /*
         * Helper functions for managing events -- not part of the public interface.
         * Props to Dean Edwards' addEvent library for many of the ideas.
         */
        jQuery.event = {
            global: {},
            add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                // Don't attach events to noData or text/comment nodes (but allow plain objects)
                if (!elemData) {
                    return;
                }
                // Caller can pass in an object of custom data in lieu of the handler
                if (handler.handler) {
                    handleObjIn = handler;
                    handler = handleObjIn.handler;
                    selector = handleObjIn.selector;
                }
                // Make sure that the handler has a unique ID, used to find/remove it later
                if (!handler.guid) {
                    handler.guid = jQuery.guid++;
                }
                // Init the element's event structure and main handler, if this is the first
                if (!(events = elemData.events)) {
                    events = elemData.events = {};
                }
                if (!(eventHandle = elemData.handle)) {
                    eventHandle = elemData.handle = function (e) {
                        // Discard the second event of a jQuery.event.trigger() and
                        // when an event is called after a page has unloaded
                        return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                    };
                    // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                    eventHandle.elem = elem;
                }
                // Handle multiple events separated by a space
                types = (types || '').match(core_rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    // There *must* be a type, no attaching namespace-only handlers
                    if (!type) {
                        continue;
                    }
                    // If event changes its type, use the special event handlers for the changed type
                    special = jQuery.event.special[type] || {};
                    // If selector defined, determine special event api type, otherwise given type
                    type = (selector ? special.delegateType : special.bindType) || type;
                    // Update special based on newly reset type
                    special = jQuery.event.special[type] || {};
                    // handleObj is passed to all event handlers
                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join('.')
                    }, handleObjIn);
                    // Init the event handler queue if we're the first
                    if (!(handlers = events[type])) {
                        handlers = events[type] = [];
                        handlers.delegateCount = 0;
                        // Only use addEventListener if the special events handler returns false
                        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                            if (elem.addEventListener) {
                                elem.addEventListener(type, eventHandle, false);
                            }
                        }
                    }
                    if (special.add) {
                        special.add.call(elem, handleObj);
                        if (!handleObj.handler.guid) {
                            handleObj.handler.guid = handler.guid;
                        }
                    }
                    // Add to the element's handler list, delegates in front
                    if (selector) {
                        handlers.splice(handlers.delegateCount++, 0, handleObj);
                    } else {
                        handlers.push(handleObj);
                    }
                    // Keep track of which events have ever been used, for event optimization
                    jQuery.event.global[type] = true;
                }
                // Nullify elem to prevent memory leaks in IE
                elem = null;
            },
            remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                if (!elemData || !(events = elemData.events)) {
                    return;
                }
                // Once for each type.namespace in types; type may be omitted
                types = (types || '').match(core_rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    // Unbind all events (on this namespace, if provided) for the element
                    if (!type) {
                        for (type in events) {
                            jQuery.event.remove(elem, type + types[t], handler, selector, true);
                        }
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    handlers = events[type] || [];
                    tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                    // Remove matching events
                    origCount = j = handlers.length;
                    while (j--) {
                        handleObj = handlers[j];
                        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                            handlers.splice(j, 1);
                            if (handleObj.selector) {
                                handlers.delegateCount--;
                            }
                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }
                    }
                    // Remove generic event handler if we removed something and no more handlers exist
                    // (avoids potential for endless recursion during removal of special event handlers)
                    if (origCount && !handlers.length) {
                        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                            jQuery.removeEvent(elem, type, elemData.handle);
                        }
                        delete events[type];
                    }
                }
                // Remove the expando if it's no longer used
                if (jQuery.isEmptyObject(events)) {
                    delete elemData.handle;
                    data_priv.remove(elem, 'events');
                }
            },
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
                cur = tmp = elem = elem || document;
                // Don't do events on text and comment nodes
                if (elem.nodeType === 3 || elem.nodeType === 8) {
                    return;
                }
                // focus/blur morphs to focusin/out; ensure we're not firing them right now
                if (rfocusMorph.test(type + jQuery.event.triggered)) {
                    return;
                }
                if (type.indexOf('.') >= 0) {
                    // Namespaced trigger; create a regexp to match event type in handle()
                    namespaces = type.split('.');
                    type = namespaces.shift();
                    namespaces.sort();
                }
                ontype = type.indexOf(':') < 0 && 'on' + type;
                // Caller can pass in a jQuery.Event object, Object, or just an event type string
                event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
                // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join('.');
                event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
                // Clean up the event in case it is being reused
                event.result = undefined;
                if (!event.target) {
                    event.target = elem;
                }
                // Clone any incoming data and prepend the event, creating the handler arg list
                data = data == null ? [event] : jQuery.makeArray(data, [event]);
                // Allow special events to draw outside the lines
                special = jQuery.event.special[type] || {};
                if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                    return;
                }
                // Determine event propagation path in advance, per W3C events spec (#9951)
                // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    bubbleType = special.delegateType || type;
                    if (!rfocusMorph.test(bubbleType + type)) {
                        cur = cur.parentNode;
                    }
                    for (; cur; cur = cur.parentNode) {
                        eventPath.push(cur);
                        tmp = cur;
                    }
                    // Only add window if we got to document (e.g., not plain obj or detached DOM)
                    if (tmp === (elem.ownerDocument || document)) {
                        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                    }
                }
                // Fire handlers on the event path
                i = 0;
                while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                    event.type = i > 1 ? bubbleType : special.bindType || type;
                    // jQuery handler
                    handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
                    if (handle) {
                        handle.apply(cur, data);
                    }
                    // Native handler
                    handle = ontype && cur[ontype];
                    if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                        event.preventDefault();
                    }
                }
                event.type = type;
                // If nobody prevented the default action, do it now
                if (!onlyHandlers && !event.isDefaultPrevented()) {
                    if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                        // Call a native DOM method on the target with the same name name as the event.
                        // Don't do default actions on window, that's where global variables be (#6170)
                        if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            tmp = elem[ontype];
                            if (tmp) {
                                elem[ontype] = null;
                            }
                            // Prevent re-triggering of the same event, since we already bubbled it above
                            jQuery.event.triggered = type;
                            elem[type]();
                            jQuery.event.triggered = undefined;
                            if (tmp) {
                                elem[ontype] = tmp;
                            }
                        }
                    }
                }
                return event.result;
            },
            dispatch: function (event) {
                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix(event);
                var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                // Use the fix-ed jQuery.Event rather than the (read-only) native event
                args[0] = event;
                event.delegateTarget = this;
                // Call the preDispatch hook for the mapped type, and let it bail if desired
                if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                    return;
                }
                // Determine handlers
                handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                // Run delegates first; they may want to stop propagation beneath us
                i = 0;
                while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                    event.currentTarget = matched.elem;
                    j = 0;
                    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                        // Triggered event must either 1) have no namespace, or
                        // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                        if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                            event.handleObj = handleObj;
                            event.data = handleObj.data;
                            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                            if (ret !== undefined) {
                                if ((event.result = ret) === false) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            }
                        }
                    }
                }
                // Call the postDispatch hook for the mapped type
                if (special.postDispatch) {
                    special.postDispatch.call(this, event);
                }
                return event.result;
            },
            handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                // Find delegate handlers
                // Black-hole SVG <use> instance trees (#13180)
                // Avoid non-left-click bubbling in Firefox (#3861)
                if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                    for (; cur !== this; cur = cur.parentNode || this) {
                        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                        if (cur.disabled !== true || event.type !== 'click') {
                            matches = [];
                            for (i = 0; i < delegateCount; i++) {
                                handleObj = handlers[i];
                                // Don't conflict with Object.prototype properties (#13203)
                                sel = handleObj.selector + ' ';
                                if (matches[sel] === undefined) {
                                    matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                                }
                                if (matches[sel]) {
                                    matches.push(handleObj);
                                }
                            }
                            if (matches.length) {
                                handlerQueue.push({
                                    elem: cur,
                                    handlers: matches
                                });
                            }
                        }
                    }
                }
                // Add the remaining (directly-bound) handlers
                if (delegateCount < handlers.length) {
                    handlerQueue.push({
                        elem: this,
                        handlers: handlers.slice(delegateCount)
                    });
                }
                return handlerQueue;
            },
            props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
            fixHooks: {},
            keyHooks: {
                props: 'char charCode key keyCode'.split(' '),
                filter: function (event, original) {
                    // Add which for key events
                    if (event.which == null) {
                        event.which = original.charCode != null ? original.charCode : original.keyCode;
                    }
                    return event;
                }
            },
            mouseHooks: {
                props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
                filter: function (event, original) {
                    var eventDoc, doc, body, button = original.button;
                    // Calculate pageX/Y if missing and clientX/Y available
                    if (event.pageX == null && original.clientX != null) {
                        eventDoc = event.target.ownerDocument || document;
                        doc = eventDoc.documentElement;
                        body = eventDoc.body;
                        event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                        event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                    }
                    // Add which for click: 1 === left; 2 === middle; 3 === right
                    // Note: button is not normalized, so don't use it
                    if (!event.which && button !== undefined) {
                        event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                    }
                    return event;
                }
            },
            fix: function (event) {
                if (event[jQuery.expando]) {
                    return event;
                }
                // Create a writable copy of the event object and normalize some properties
                var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
                if (!fixHook) {
                    this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                }
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                event = new jQuery.Event(originalEvent);
                i = copy.length;
                while (i--) {
                    prop = copy[i];
                    event[prop] = originalEvent[prop];
                }
                // Support: Cordova 2.5 (WebKit) (#13255)
                // All events should have a target; Cordova deviceready doesn't
                if (!event.target) {
                    event.target = document;
                }
                // Support: Safari 6.0+, Chrome < 28
                // Target should not be a text node (#504, #13143)
                if (event.target.nodeType === 3) {
                    event.target = event.target.parentNode;
                }
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
            },
            special: {
                load: { noBubble: true },
                focus: {
                    trigger: function () {
                        if (this !== safeActiveElement() && this.focus) {
                            this.focus();
                            return false;
                        }
                    },
                    delegateType: 'focusin'
                },
                blur: {
                    trigger: function () {
                        if (this === safeActiveElement() && this.blur) {
                            this.blur();
                            return false;
                        }
                    },
                    delegateType: 'focusout'
                },
                click: {
                    trigger: function () {
                        if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                            this.click();
                            return false;
                        }
                    },
                    _default: function (event) {
                        return jQuery.nodeName(event.target, 'a');
                    }
                },
                beforeunload: {
                    postDispatch: function (event) {
                        // Support: Firefox 20+
                        // Firefox doesn't alert if the returnValue field is not set.
                        if (event.result !== undefined) {
                            event.originalEvent.returnValue = event.result;
                        }
                    }
                }
            },
            simulate: function (type, elem, event, bubble) {
                // Piggyback on a donor event to simulate a different one.
                // Fake originalEvent to avoid donor's stopPropagation, but if the
                // simulated event prevents default then we do the same on the donor.
                var e = jQuery.extend(new jQuery.Event(), event, {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    });
                if (bubble) {
                    jQuery.event.trigger(e, null, elem);
                } else {
                    jQuery.event.dispatch.call(elem, e);
                }
                if (e.isDefaultPrevented()) {
                    event.preventDefault();
                }
            }
        };
        jQuery.removeEvent = function (elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
            }
        };
        jQuery.Event = function (src, props) {
            // Allow instantiation without the 'new' keyword
            if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props);
            }
            // Event object
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                // Events bubbling up the document may have been marked as prevented
                // by a handler lower down the tree; reflect the correct value.
                this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;    // Event type
            } else {
                this.type = src;
            }
            // Put explicitly provided properties onto the event object
            if (props) {
                jQuery.extend(this, props);
            }
            // Create a timestamp if incoming event doesn't have one
            this.timeStamp = src && src.timeStamp || jQuery.now();
            // Mark it as fixed
            this[jQuery.expando] = true;
        };
        // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
        // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
        jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue;
                if (e && e.preventDefault) {
                    e.preventDefault();
                }
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue;
                if (e && e.stopPropagation) {
                    e.stopPropagation();
                }
            },
            stopImmediatePropagation: function () {
                this.isImmediatePropagationStopped = returnTrue;
                this.stopPropagation();
            }
        };
        // Create mouseenter/leave events using mouseover/out and event-time checks
        // Support: Chrome 15+
        jQuery.each({
            mouseenter: 'mouseover',
            mouseleave: 'mouseout'
        }, function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function (event) {
                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                    // For mousenter/leave call the handler if related is outside the target.
                    // NB: No relatedTarget if the mouse left/entered the browser window
                    if (!related || related !== target && !jQuery.contains(target, related)) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply(this, arguments);
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });
        // Create "bubbling" focus and blur events
        // Support: Firefox, Chrome, Safari
        if (!jQuery.support.focusinBubbles) {
            jQuery.each({
                focus: 'focusin',
                blur: 'focusout'
            }, function (orig, fix) {
                // Attach a single capturing handler while someone wants focusin/focusout
                var attaches = 0, handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };
                jQuery.event.special[fix] = {
                    setup: function () {
                        if (attaches++ === 0) {
                            document.addEventListener(orig, handler, true);
                        }
                    },
                    teardown: function () {
                        if (--attaches === 0) {
                            document.removeEventListener(orig, handler, true);
                        }
                    }
                };
            });
        }
        jQuery.fn.extend({
            on: function (types, selector, data, fn, one) {
                var origFn, type;
                // Types can be a map of types/handlers
                if (typeof types === 'object') {
                    // ( types-Object, selector, data )
                    if (typeof selector !== 'string') {
                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                    }
                    for (type in types) {
                        this.on(type, selector, data, types[type], one);
                    }
                    return this;
                }
                if (data == null && fn == null) {
                    // ( types, fn )
                    fn = selector;
                    data = selector = undefined;
                } else if (fn == null) {
                    if (typeof selector === 'string') {
                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                    } else {
                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if (fn === false) {
                    fn = returnFalse;
                } else if (!fn) {
                    return this;
                }
                if (one === 1) {
                    origFn = fn;
                    fn = function (event) {
                        // Can use an empty set, since event contains the info
                        jQuery().off(event);
                        return origFn.apply(this, arguments);
                    };
                    // Use same guid so caller can remove using origFn
                    fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                }
                return this.each(function () {
                    jQuery.event.add(this, types, fn, data, selector);
                });
            },
            one: function (types, selector, data, fn) {
                return this.on(types, selector, data, fn, 1);
            },
            off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) {
                    // ( event )  dispatched jQuery.Event
                    handleObj = types.handleObj;
                    jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                    return this;
                }
                if (typeof types === 'object') {
                    // ( types-object [, selector] )
                    for (type in types) {
                        this.off(type, selector, types[type]);
                    }
                    return this;
                }
                if (selector === false || typeof selector === 'function') {
                    // ( types [, fn] )
                    fn = selector;
                    selector = undefined;
                }
                if (fn === false) {
                    fn = returnFalse;
                }
                return this.each(function () {
                    jQuery.event.remove(this, types, fn, selector);
                });
            },
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this);
                });
            },
            triggerHandler: function (type, data) {
                var elem = this[0];
                if (elem) {
                    return jQuery.event.trigger(type, data, elem, true);
                }
            }
        });
        var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext,
            // methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
        jQuery.fn.extend({
            find: function (selector) {
                var i, ret = [], self = this, len = self.length;
                if (typeof selector !== 'string') {
                    return this.pushStack(jQuery(selector).filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    }));
                }
                for (i = 0; i < len; i++) {
                    jQuery.find(selector, self[i], ret);
                }
                // Needed because $( selector, context ) becomes $( context ).find( selector )
                ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                ret.selector = this.selector ? this.selector + ' ' + selector : selector;
                return ret;
            },
            has: function (target) {
                var targets = jQuery(target, this), l = targets.length;
                return this.filter(function () {
                    var i = 0;
                    for (; i < l; i++) {
                        if (jQuery.contains(this, targets[i])) {
                            return true;
                        }
                    }
                });
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], true));
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], false));
            },
            is: function (selector) {
                return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
            },
            closest: function (selectors, context) {
                var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        // Always skip document fragments
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            cur = matched.push(cur);
                            break;
                        }
                    }
                }
                return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
            },
            index: function (elem) {
                // No argument, return index in parent
                if (!elem) {
                    return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                }
                // index in selector
                if (typeof elem === 'string') {
                    return core_indexOf.call(jQuery(elem), this[0]);
                }
                // Locate the position of the desired element
                return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
            },
            add: function (selector, context) {
                var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
                return this.pushStack(jQuery.unique(all));
            },
            addBack: function (selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            }
        });
        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {
            }
            return cur;
        }
        jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
                return jQuery.dir(elem, 'parentNode');
            },
            parentsUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'parentNode', until);
            },
            next: function (elem) {
                return sibling(elem, 'nextSibling');
            },
            prev: function (elem) {
                return sibling(elem, 'previousSibling');
            },
            nextAll: function (elem) {
                return jQuery.dir(elem, 'nextSibling');
            },
            prevAll: function (elem) {
                return jQuery.dir(elem, 'previousSibling');
            },
            nextUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'nextSibling', until);
            },
            prevUntil: function (elem, i, until) {
                return jQuery.dir(elem, 'previousSibling', until);
            },
            siblings: function (elem) {
                return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
            },
            children: function (elem) {
                return jQuery.sibling(elem.firstChild);
            },
            contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes);
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until);
                if (name.slice(-5) !== 'Until') {
                    selector = until;
                }
                if (selector && typeof selector === 'string') {
                    matched = jQuery.filter(selector, matched);
                }
                if (this.length > 1) {
                    // Remove duplicates
                    if (!guaranteedUnique[name]) {
                        jQuery.unique(matched);
                    }
                    // Reverse order for parents* and prev-derivatives
                    if (rparentsprev.test(name)) {
                        matched.reverse();
                    }
                }
                return this.pushStack(matched);
            };
        });
        jQuery.extend({
            filter: function (expr, elems, not) {
                var elem = elems[0];
                if (not) {
                    expr = ':not(' + expr + ')';
                }
                return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                    return elem.nodeType === 1;
                }));
            },
            dir: function (elem, dir, until) {
                var matched = [], truncate = until !== undefined;
                while ((elem = elem[dir]) && elem.nodeType !== 9) {
                    if (elem.nodeType === 1) {
                        if (truncate && jQuery(elem).is(until)) {
                            break;
                        }
                        matched.push(elem);
                    }
                }
                return matched;
            },
            sibling: function (n, elem) {
                var matched = [];
                for (; n; n = n.nextSibling) {
                    if (n.nodeType === 1 && n !== elem) {
                        matched.push(n);
                    }
                }
                return matched;
            }
        });
        // Implement the identical functionality for filter and not
        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function (elem, i) {
                    /* jshint -W018 */
                    return !!qualifier.call(elem, i, elem) !== not;
                });
            }
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function (elem) {
                    return elem === qualifier !== not;
                });
            }
            if (typeof qualifier === 'string') {
                if (isSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not);
                }
                qualifier = jQuery.filter(qualifier, elements);
            }
            return jQuery.grep(elements, function (elem) {
                return core_indexOf.call(qualifier, elem) >= 0 !== not;
            });
        }
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
            // checked="checked" or checked
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            // We have to close these tags to support XHTML (#13200)
            wrapMap = {
                option: [
                    1,
                    '<select multiple=\'multiple\'>',
                    '</select>'
                ],
                thead: [
                    1,
                    '<table>',
                    '</table>'
                ],
                col: [
                    2,
                    '<table><colgroup>',
                    '</colgroup></table>'
                ],
                tr: [
                    2,
                    '<table><tbody>',
                    '</tbody></table>'
                ],
                td: [
                    3,
                    '<table><tbody><tr>',
                    '</tr></tbody></table>'
                ],
                _default: [
                    0,
                    '',
                    ''
                ]
            };
        // Support: IE 9
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        jQuery.fn.extend({
            text: function (value) {
                return jQuery.access(this, function (value) {
                    return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
                }, null, value, arguments.length);
            },
            append: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem);
                    }
                });
            },
            prepend: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild);
                    }
                });
            },
            before: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this);
                    }
                });
            },
            after: function () {
                return this.domManip(arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this.nextSibling);
                    }
                });
            },
            remove: function (selector, keepData) {
                var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
                for (; (elem = elems[i]) != null; i++) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem));
                    }
                    if (elem.parentNode) {
                        if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                            setGlobalEval(getAll(elem, 'script'));
                        }
                        elem.parentNode.removeChild(elem);
                    }
                }
                return this;
            },
            empty: function () {
                var elem, i = 0;
                for (; (elem = this[i]) != null; i++) {
                    if (elem.nodeType === 1) {
                        // Prevent memory leaks
                        jQuery.cleanData(getAll(elem, false));
                        // Remove any remaining nodes
                        elem.textContent = '';
                    }
                }
                return this;
            },
            clone: function (dataAndEvents, deepDataAndEvents) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                return this.map(function () {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
            },
            html: function (value) {
                return jQuery.access(this, function (value) {
                    var elem = this[0] || {}, i = 0, l = this.length;
                    if (value === undefined && elem.nodeType === 1) {
                        return elem.innerHTML;
                    }
                    // See if we can take a shortcut and just use innerHTML
                    if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                            '',
                            ''
                        ])[1].toLowerCase()]) {
                        value = value.replace(rxhtmlTag, '<$1></$2>');
                        try {
                            for (; i < l; i++) {
                                elem = this[i] || {};
                                // Remove element nodes and prevent memory leaks
                                if (elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem, false));
                                    elem.innerHTML = value;
                                }
                            }
                            elem = 0;    // If using innerHTML throws an exception, use the fallback method
                        } catch (e) {
                        }
                    }
                    if (elem) {
                        this.empty().append(value);
                    }
                }, null, value, arguments.length);
            },
            replaceWith: function () {
                var
                    // Snapshot the DOM in case .domManip sweeps something relevant into its fragment
                    args = jQuery.map(this, function (elem) {
                        return [
                            elem.nextSibling,
                            elem.parentNode
                        ];
                    }), i = 0;
                // Make the changes, replacing each context element with the new content
                this.domManip(arguments, function (elem) {
                    var next = args[i++], parent = args[i++];
                    if (parent) {
                        // Don't use the snapshot next if it has moved (#13810)
                        if (next && next.parentNode !== parent) {
                            next = this.nextSibling;
                        }
                        jQuery(this).remove();
                        parent.insertBefore(elem, next);
                    }    // Allow new content to include elements from the context set
                }, true);
                // Force removal if there was no new content (e.g., from empty arguments)
                return i ? this : this.remove();
            },
            detach: function (selector) {
                return this.remove(selector, true);
            },
            domManip: function (args, callback, allowIntersection) {
                // Flatten any nested arrays
                args = core_concat.apply([], args);
                var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
                // We can't cloneNode fragments that contain checked, in WebKit
                if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
                    return this.each(function (index) {
                        var self = set.eq(index);
                        if (isFunction) {
                            args[0] = value.call(this, index, self.html());
                        }
                        self.domManip(args, callback, allowIntersection);
                    });
                }
                if (l) {
                    fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
                    first = fragment.firstChild;
                    if (fragment.childNodes.length === 1) {
                        fragment = first;
                    }
                    if (first) {
                        scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                        hasScripts = scripts.length;
                        // Use the original fragment for the last item instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for (; i < l; i++) {
                            node = fragment;
                            if (i !== iNoClone) {
                                node = jQuery.clone(node, true, true);
                                // Keep references to cloned scripts for later restoration
                                if (hasScripts) {
                                    // Support: QtWebKit
                                    // jQuery.merge because core_push.apply(_, arraylike) throws
                                    jQuery.merge(scripts, getAll(node, 'script'));
                                }
                            }
                            callback.call(this[i], node, i);
                        }
                        if (hasScripts) {
                            doc = scripts[scripts.length - 1].ownerDocument;
                            // Reenable scripts
                            jQuery.map(scripts, restoreScript);
                            // Evaluate executable scripts on first document insertion
                            for (i = 0; i < hasScripts; i++) {
                                node = scripts[i];
                                if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                                    if (node.src) {
                                        // Hope ajax is available...
                                        jQuery._evalUrl(node.src);
                                    } else {
                                        jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                    }
                                }
                            }
                        }
                    }
                }
                return this;
            }
        });
        jQuery.each({
            appendTo: 'append',
            prependTo: 'prepend',
            insertBefore: 'before',
            insertAfter: 'after',
            replaceAll: 'replaceWith'
        }, function (name, original) {
            jQuery.fn[name] = function (selector) {
                var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    // Support: QtWebKit
                    // .get() because core_push.apply(_, arraylike) throws
                    core_push.apply(ret, elems.get());
                }
                return this.pushStack(ret);
            };
        });
        jQuery.extend({
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
                // Support: IE >= 9
                // Fix Cloning issues
                if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                    // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                    destElements = getAll(clone);
                    srcElements = getAll(elem);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        fixInput(srcElements[i], destElements[i]);
                    }
                }
                // Copy the events from the original to the clone
                if (dataAndEvents) {
                    if (deepDataAndEvents) {
                        srcElements = srcElements || getAll(elem);
                        destElements = destElements || getAll(clone);
                        for (i = 0, l = srcElements.length; i < l; i++) {
                            cloneCopyEvent(srcElements[i], destElements[i]);
                        }
                    } else {
                        cloneCopyEvent(elem, clone);
                    }
                }
                // Preserve script evaluation history
                destElements = getAll(clone, 'script');
                if (destElements.length > 0) {
                    setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
                }
                // Return the cloned set
                return clone;
            },
            buildFragment: function (elems, context, scripts, selection) {
                var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
                for (; i < l; i++) {
                    elem = elems[i];
                    if (elem || elem === 0) {
                        // Add nodes directly
                        if (jQuery.type(elem) === 'object') {
                            // Support: QtWebKit
                            // jQuery.merge because core_push.apply(_, arraylike) throws
                            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);    // Convert non-html into a text node
                        } else if (!rhtml.test(elem)) {
                            nodes.push(context.createTextNode(elem));    // Convert html into DOM nodes
                        } else {
                            tmp = tmp || fragment.appendChild(context.createElement('div'));
                            // Deserialize a standard representation
                            tag = (rtagName.exec(elem) || [
                                '',
                                ''
                            ])[1].toLowerCase();
                            wrap = wrapMap[tag] || wrapMap._default;
                            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                            // Descend through wrappers to the right content
                            j = wrap[0];
                            while (j--) {
                                tmp = tmp.lastChild;
                            }
                            // Support: QtWebKit
                            // jQuery.merge because core_push.apply(_, arraylike) throws
                            jQuery.merge(nodes, tmp.childNodes);
                            // Remember the top-level container
                            tmp = fragment.firstChild;
                            // Fixes #12346
                            // Support: Webkit, IE
                            tmp.textContent = '';
                        }
                    }
                }
                // Remove wrapper from fragment
                fragment.textContent = '';
                i = 0;
                while (elem = nodes[i++]) {
                    // #4087 - If origin and destination elements are the same, and this is
                    // that element, do not do anything
                    if (selection && jQuery.inArray(elem, selection) !== -1) {
                        continue;
                    }
                    contains = jQuery.contains(elem.ownerDocument, elem);
                    // Append to fragment
                    tmp = getAll(fragment.appendChild(elem), 'script');
                    // Preserve script evaluation history
                    if (contains) {
                        setGlobalEval(tmp);
                    }
                    // Capture executables
                    if (scripts) {
                        j = 0;
                        while (elem = tmp[j++]) {
                            if (rscriptType.test(elem.type || '')) {
                                scripts.push(elem);
                            }
                        }
                    }
                }
                return fragment;
            },
            cleanData: function (elems) {
                var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
                for (; (elem = elems[i]) !== undefined; i++) {
                    if (Data.accepts(elem)) {
                        key = elem[data_priv.expando];
                        if (key && (data = data_priv.cache[key])) {
                            events = Object.keys(data.events || {});
                            if (events.length) {
                                for (j = 0; (type = events[j]) !== undefined; j++) {
                                    if (special[type]) {
                                        jQuery.event.remove(elem, type);    // This is a shortcut to avoid jQuery.event.remove's overhead
                                    } else {
                                        jQuery.removeEvent(elem, type, data.handle);
                                    }
                                }
                            }
                            if (data_priv.cache[key]) {
                                // Discard any remaining `private` data
                                delete data_priv.cache[key];
                            }
                        }
                    }
                    // Discard any remaining `user` data
                    delete data_user.cache[elem[data_user.expando]];
                }
            },
            _evalUrl: function (url) {
                return jQuery.ajax({
                    url: url,
                    type: 'GET',
                    dataType: 'script',
                    async: false,
                    global: false,
                    'throws': true
                });
            }
        });
        // Support: 1.x compatibility
        // Manipulating tables requires a tbody
        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
        }
        // Replace/restore the type attribute of script elements for safe DOM manipulation
        function disableScript(elem) {
            elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
            return elem;
        }
        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            if (match) {
                elem.type = match[1];
            } else {
                elem.removeAttribute('type');
            }
            return elem;
        }
        // Mark scripts as having already been evaluated
        function setGlobalEval(elems, refElements) {
            var l = elems.length, i = 0;
            for (; i < l; i++) {
                data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
            }
        }
        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
                return;
            }
            // 1. Copy private data: events, handlers, etc.
            if (data_priv.hasData(src)) {
                pdataOld = data_priv.access(src);
                pdataCur = data_priv.set(dest, pdataOld);
                events = pdataOld.events;
                if (events) {
                    delete pdataCur.handle;
                    pdataCur.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }
            }
            // 2. Copy user data
            if (data_user.hasData(src)) {
                udataOld = data_user.access(src);
                udataCur = jQuery.extend({}, udataOld);
                data_user.set(dest, udataCur);
            }
        }
        function getAll(context, tag) {
            var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
            return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
        }
        // Support: IE >= 9
        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            // Fails to persist the checked state of a cloned checkbox or radio button.
            if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
                dest.checked = src.checked;    // Fails to return the selected option to the default selected state when cloning options
            } else if (nodeName === 'input' || nodeName === 'textarea') {
                dest.defaultValue = src.defaultValue;
            }
        }
        jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapAll(html.call(this, i));
                    });
                }
                if (this[0]) {
                    // The elements to wrap the target around
                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                    if (this[0].parentNode) {
                        wrap.insertBefore(this[0]);
                    }
                    wrap.map(function () {
                        var elem = this;
                        while (elem.firstElementChild) {
                            elem = elem.firstElementChild;
                        }
                        return elem;
                    }).append(this);
                }
                return this;
            },
            wrapInner: function (html) {
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapInner(html.call(this, i));
                    });
                }
                return this.each(function () {
                    var self = jQuery(this), contents = self.contents();
                    if (contents.length) {
                        contents.wrapAll(html);
                    } else {
                        self.append(html);
                    }
                });
            },
            wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                });
            },
            unwrap: function () {
                return this.parent().each(function () {
                    if (!jQuery.nodeName(this, 'body')) {
                        jQuery(this).replaceWith(this.childNodes);
                    }
                }).end();
            }
        });
        var curCSS, iframe,
            // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
            // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
                position: 'absolute',
                visibility: 'hidden',
                display: 'block'
            }, cssNormalTransform = {
                letterSpacing: 0,
                fontWeight: 400
            }, cssExpand = [
                'Top',
                'Right',
                'Bottom',
                'Left'
            ], cssPrefixes = [
                'Webkit',
                'O',
                'Moz',
                'ms'
            ];
        // return a css property mapped to a potentially vendor prefixed property
        function vendorPropName(style, name) {
            // shortcut for names that are not vendor prefixed
            if (name in style) {
                return name;
            }
            // check for vendor prefixed names
            var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
            while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in style) {
                    return name;
                }
            }
            return origName;
        }
        function isHidden(elem, el) {
            // isHidden might be called from jQuery#filter function;
            // in that case, element will be second argument
            elem = el || elem;
            return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
        }
        // NOTE: we've included the "window" in window.getComputedStyle
        // because jsdom on node.js will break without it.
        function getStyles(elem) {
            return window.getComputedStyle(elem, null);
        }
        function showHide(elements, show) {
            var display, elem, hidden, values = [], index = 0, length = elements.length;
            for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                values[index] = data_priv.get(elem, 'olddisplay');
                display = elem.style.display;
                if (show) {
                    // Reset the inline display of this element to learn if it is
                    // being hidden by cascaded rules or not
                    if (!values[index] && display === 'none') {
                        elem.style.display = '';
                    }
                    // Set elements which have been overridden with display: none
                    // in a stylesheet to whatever the default browser style is
                    // for such an element
                    if (elem.style.display === '' && isHidden(elem)) {
                        values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
                    }
                } else {
                    if (!values[index]) {
                        hidden = isHidden(elem);
                        if (display && display !== 'none' || !hidden) {
                            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                        }
                    }
                }
            }
            // Set the display of most of the elements in a second loop
            // to avoid the constant reflow
            for (index = 0; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                if (!show || elem.style.display === 'none' || elem.style.display === '') {
                    elem.style.display = show ? values[index] || '' : 'none';
                }
            }
            return elements;
        }
        jQuery.fn.extend({
            css: function (name, value) {
                return jQuery.access(this, function (elem, name, value) {
                    var styles, len, map = {}, i = 0;
                    if (jQuery.isArray(name)) {
                        styles = getStyles(elem);
                        len = name.length;
                        for (; i < len; i++) {
                            map[name[i]] = jQuery.css(elem, name[i], false, styles);
                        }
                        return map;
                    }
                    return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                }, name, value, arguments.length > 1);
            },
            show: function () {
                return showHide(this, true);
            },
            hide: function () {
                return showHide(this);
            },
            toggle: function (state) {
                if (typeof state === 'boolean') {
                    return state ? this.show() : this.hide();
                }
                return this.each(function () {
                    if (isHidden(this)) {
                        jQuery(this).show();
                    } else {
                        jQuery(this).hide();
                    }
                });
            }
        });
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            // We should always get a number back from opacity
                            var ret = curCSS(elem, 'opacity');
                            return ret === '' ? '1' : ret;
                        }
                    }
                }
            },
            cssNumber: {
                'columnCount': true,
                'fillOpacity': true,
                'fontWeight': true,
                'lineHeight': true,
                'opacity': true,
                'order': true,
                'orphans': true,
                'widows': true,
                'zIndex': true,
                'zoom': true
            },
            cssProps: { 'float': 'cssFloat' },
            style: function (elem, name, value, extra) {
                // Don't set styles on text and comment nodes
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                    return;
                }
                // Make sure that we're working with the right name
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
                // gets hook for the prefixed version
                // followed by the unprefixed version
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                // Check if we're setting a value
                if (value !== undefined) {
                    type = typeof value;
                    // convert relative number strings (+= or -=) to relative numbers. #7345
                    if (type === 'string' && (ret = rrelNum.exec(value))) {
                        value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                        // Fixes bug #9237
                        type = 'number';
                    }
                    // Make sure that NaN and null values aren't set. See: #7116
                    if (value == null || type === 'number' && isNaN(value)) {
                        return;
                    }
                    // If a number was passed in, add 'px' to the (except for certain CSS properties)
                    if (type === 'number' && !jQuery.cssNumber[origName]) {
                        value += 'px';
                    }
                    // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
                    // but it would mean to define eight (for every problematic property) identical functions
                    if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                        style[name] = 'inherit';
                    }
                    // If a hook was provided, use that value, otherwise just set the specified value
                    if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                        style[name] = value;
                    }
                } else {
                    // If a hook was provided get the non-computed value from there
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                        return ret;
                    }
                    // Otherwise just get the value from the style object
                    return style[name];
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                // Make sure that we're working with the right name
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
                // gets hook for the prefixed version
                // followed by the unprefixed version
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                // If a hook was provided get the computed value from there
                if (hooks && 'get' in hooks) {
                    val = hooks.get(elem, true, extra);
                }
                // Otherwise, if a way to get the computed value exists, use that
                if (val === undefined) {
                    val = curCSS(elem, name, styles);
                }
                //convert "normal" to computed value
                if (val === 'normal' && name in cssNormalTransform) {
                    val = cssNormalTransform[name];
                }
                // Return, converting to number if forced or a qualifier was provided and val looks numeric
                if (extra === '' || extra) {
                    num = parseFloat(val);
                    return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                }
                return val;
            }
        });
        curCSS = function (elem, name, _computed) {
            var width, minWidth, maxWidth, computed = _computed || getStyles(elem),
                // Support: IE9
                // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                // Support: Safari 5.1
                // A tribute to the "awesome hack by Dean Edwards"
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    // Remember the original values
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    // Put in the new values to get a computed value out
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    // Revert the changed values
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret;
        };
        function setPositiveNumber(elem, value, subtract) {
            var matches = rnumsplit.exec(value);
            return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
        }
        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
            for (; i < 4; i += 2) {
                // both box models exclude margin, so add it if we want it
                if (extra === 'margin') {
                    val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                }
                if (isBorderBox) {
                    // border-box includes padding, so remove it if we want content
                    if (extra === 'content') {
                        val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    }
                    // at this point, extra isn't border nor margin, so remove border
                    if (extra !== 'margin') {
                        val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                } else {
                    // at this point, extra isn't content, so add padding
                    val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    // at this point, extra isn't content nor padding, so add border
                    if (extra !== 'padding') {
                        val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                }
            }
            return val;
        }
        function getWidthOrHeight(elem, name, extra) {
            // Start with offset property, which is equivalent to the border-box value
            var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
            // some non-html elements return undefined for offsetWidth, so check for null/undefined
            // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
            // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
            if (val <= 0 || val == null) {
                // Fall back to computed then uncomputed css if necessary
                val = curCSS(elem, name, styles);
                if (val < 0 || val == null) {
                    val = elem.style[name];
                }
                // Computed unit is not pixels. Stop here and return.
                if (rnumnonpx.test(val)) {
                    return val;
                }
                // we need the check for style in case a browser which returns unreliable values
                // for getComputedStyle silently falls back to the reliable elem.style
                valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
                // Normalize "", auto, and prepare for extra
                val = parseFloat(val) || 0;
            }
            // use the active box-sizing model to add/subtract irrelevant styles
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
        }
        // Try to determine the default display value of an element
        function css_defaultDisplay(nodeName) {
            var doc = document, display = elemdisplay[nodeName];
            if (!display) {
                display = actualDisplay(nodeName, doc);
                // If the simple way fails, read from inside an iframe
                if (display === 'none' || !display) {
                    // Use the already-created iframe if possible
                    iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
                    // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                    doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                    doc.write('<!doctype html><html><body>');
                    doc.close();
                    display = actualDisplay(nodeName, doc);
                    iframe.detach();
                }
                // Store the correct default display
                elemdisplay[nodeName] = display;
            }
            return display;
        }
        // Called ONLY from within css_defaultDisplay
        function actualDisplay(name, doc) {
            var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
            elem.remove();
            return display;
        }
        jQuery.each([
            'height',
            'width'
        ], function (i, name) {
            jQuery.cssHooks[name] = {
                get: function (elem, computed, extra) {
                    if (computed) {
                        // certain elements can have dimension info if we invisibly show them
                        // however, it must have a current display style that would benefit from this
                        return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, name, extra);
                        }) : getWidthOrHeight(elem, name, extra);
                    }
                },
                set: function (elem, value, extra) {
                    var styles = extra && getStyles(elem);
                    return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
                }
            };
        });
        // These hooks cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        jQuery(function () {
            // Support: Android 2.3
            if (!jQuery.support.reliableMarginRight) {
                jQuery.cssHooks.marginRight = {
                    get: function (elem, computed) {
                        if (computed) {
                            // Support: Android 2.3
                            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                            // Work around by temporarily setting element display to inline-block
                            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                                elem,
                                'marginRight'
                            ]);
                        }
                    }
                };
            }
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // getComputedStyle returns percent when specified for top/left/bottom/right
            // rather than make the css module depend on the offset module, we just check for it here
            if (!jQuery.support.pixelPosition && jQuery.fn.position) {
                jQuery.each([
                    'top',
                    'left'
                ], function (i, prop) {
                    jQuery.cssHooks[prop] = {
                        get: function (elem, computed) {
                            if (computed) {
                                computed = curCSS(elem, prop);
                                // if curCSS returns percentage, fallback to offset
                                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
                            }
                        }
                    };
                });
            }
        });
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.hidden = function (elem) {
                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
            };
            jQuery.expr.filters.visible = function (elem) {
                return !jQuery.expr.filters.hidden(elem);
            };
        }
        // These hooks are used by animate to expand properties
        jQuery.each({
            margin: '',
            padding: '',
            border: 'Width'
        }, function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    var i = 0, expanded = {},
                        // assumes a single number if not a string
                        parts = typeof value === 'string' ? value.split(' ') : [value];
                    for (; i < 4; i++) {
                        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    }
                    return expanded;
                }
            };
            if (!rmargin.test(prefix)) {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
        });
        var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray());
            },
            serializeArray: function () {
                return this.map(function () {
                    // Can add propHook for "elements" to filter or add form elements
                    var elements = jQuery.prop(this, 'elements');
                    return elements ? jQuery.makeArray(elements) : this;
                }).filter(function () {
                    var type = this.type;
                    // Use .is(":disabled") so that fieldset[disabled] works
                    return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }).get();
            }
        });
        //Serialize an array of form elements or a set of
        //key/values into a query string
        jQuery.param = function (a, traditional) {
            var prefix, s = [], add = function (key, value) {
                    // If value is a function, invoke it and return its value
                    value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                    s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
                };
            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
            }
            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });
            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }
            // Return the resulting serialization
            return s.join('&').replace(r20, '+');
        };
        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) {
                // Serialize array item.
                jQuery.each(obj, function (i, v) {
                    if (traditional || rbracket.test(prefix)) {
                        // Treat each array item as a scalar.
                        add(prefix, v);
                    } else {
                        // Item is non-scalar (array or object), encode its numeric index.
                        buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                    }
                });
            } else if (!traditional && jQuery.type(obj) === 'object') {
                // Serialize object item.
                for (name in obj) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            } else {
                // Serialize scalar item.
                add(prefix, obj);
            }
        }
        jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        });
        jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            },
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn);
            },
            unbind: function (types, fn) {
                return this.off(types, null, fn);
            },
            delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn);
            },
            undelegate: function (selector, types, fn) {
                // ( namespace ) or ( selector, types [, fn] )
                return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
            }
        });
        var
            // Document location
            ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            // #7653, #8125, #8152: local protocol detection
            rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
            // Keep a copy of the old load method
            _load = jQuery.fn.load,
            /* Prefilters
            * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
            * 2) These are called:
            *    - BEFORE asking for a transport
            *    - AFTER param serialization (s.data is a string if s.processData is true)
            * 3) key is the dataType
            * 4) the catchall symbol "*" can be used
            * 5) execution will start with transport dataType and THEN continue down to "*" if needed
            */
            prefilters = {},
            /* Transports bindings
            * 1) key is the dataType
            * 2) the catchall symbol "*" can be used
            * 3) selection will start with transport dataType and THEN go to "*" if needed
            */
            transports = {},
            // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            allTypes = '*/'.concat('*');
        // #8138, IE may throw an exception when accessing
        // a field from window.location if document.domain has been set
        try {
            ajaxLocation = location.href;
        } catch (e) {
            // Use the href attribute of an A element
            // since IE will modify it given document.location
            ajaxLocation = document.createElement('a');
            ajaxLocation.href = '';
            ajaxLocation = ajaxLocation.href;
        }
        // Segment location into parts
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
        // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
        function addToPrefiltersOrTransports(structure) {
            // dataTypeExpression is optional and defaults to "*"
            return function (dataTypeExpression, func) {
                if (typeof dataTypeExpression !== 'string') {
                    func = dataTypeExpression;
                    dataTypeExpression = '*';
                }
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
                if (jQuery.isFunction(func)) {
                    // For each dataType in the dataTypeExpression
                    while (dataType = dataTypes[i++]) {
                        // Prepend if requested
                        if (dataType[0] === '+') {
                            dataType = dataType.slice(1) || '*';
                            (structure[dataType] = structure[dataType] || []).unshift(func);    // Otherwise append
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    }
                }
            };
        }
        // Base inspection function for prefilters and transports
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                        options.dataTypes.unshift(dataTypeOrTransport);
                        inspect(dataTypeOrTransport);
                        return false;
                    } else if (seekingTransport) {
                        return !(selected = dataTypeOrTransport);
                    }
                });
                return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
        }
        // A special extend for ajax options
        // that takes "flat" options (not to be deep extended)
        // Fixes #9887
        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
                if (src[key] !== undefined) {
                    (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                }
            }
            if (deep) {
                jQuery.extend(true, target, deep);
            }
            return target;
        }
        jQuery.fn.load = function (url, params, callback) {
            if (typeof url !== 'string' && _load) {
                return _load.apply(this, arguments);
            }
            var selector, type, response, self = this, off = url.indexOf(' ');
            if (off >= 0) {
                selector = url.slice(off);
                url = url.slice(0, off);
            }
            // If it's a function
            if (jQuery.isFunction(params)) {
                // We assume that it's the callback
                callback = params;
                params = undefined;    // Otherwise, build a param string
            } else if (params && typeof params === 'object') {
                type = 'POST';
            }
            // If we have elements to modify, make the request
            if (self.length > 0) {
                jQuery.ajax({
                    url: url,
                    type: type,
                    dataType: 'html',
                    data: params
                }).done(function (responseText) {
                    // Save response for use in complete callback
                    response = arguments;
                    self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                }).complete(callback && function (jqXHR, status) {
                    self.each(callback, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            }
            return this;
        };
        // Attach a bunch of functions for handling common AJAX events
        jQuery.each([
            'ajaxStart',
            'ajaxStop',
            'ajaxComplete',
            'ajaxError',
            'ajaxSuccess',
            'ajaxSend'
        ], function (i, type) {
            jQuery.fn[type] = function (fn) {
                return this.on(type, fn);
            };
        });
        jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ajaxLocation,
                type: 'GET',
                isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                global: true,
                processData: true,
                async: true,
                contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                accepts: {
                    '*': allTypes,
                    text: 'text/plain',
                    html: 'text/html',
                    xml: 'application/xml, text/xml',
                    json: 'application/json, text/javascript'
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: 'responseXML',
                    text: 'responseText',
                    json: 'responseJSON'
                },
                converters: {
                    '* text': String,
                    'text html': true,
                    'text json': jQuery.parseJSON,
                    'text xml': jQuery.parseXML
                },
                flatOptions: {
                    url: true,
                    context: true
                }
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                // If url is an object, simulate pre-1.5 signature
                if (typeof url === 'object') {
                    options = url;
                    url = undefined;
                }
                // Force options to be an object
                options = options || {};
                var transport,
                    // URL without anti-cache param
                    cacheURL,
                    // Response headers
                    responseHeadersString, responseHeaders,
                    // timeout handle
                    timeoutTimer,
                    // Cross-domain detection vars
                    parts,
                    // To know if global events are to be dispatched
                    fireGlobals,
                    // Loop variable
                    i,
                    // Create the final options object
                    s = jQuery.ajaxSetup({}, options),
                    // Callbacks context
                    callbackContext = s.context || s,
                    // Context for global events is callbackContext if it is a DOM node or jQuery collection
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    // Deferreds
                    deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'),
                    // Status-dependent callbacks
                    statusCode = s.statusCode || {},
                    // Headers (they are sent all at once)
                    requestHeaders = {}, requestHeadersNames = {},
                    // The jqXHR state
                    state = 0,
                    // Default abort message
                    strAbort = 'canceled',
                    // Fake xhr
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function (key) {
                            var match;
                            if (state === 2) {
                                if (!responseHeaders) {
                                    responseHeaders = {};
                                    while (match = rheaders.exec(responseHeadersString)) {
                                        responseHeaders[match[1].toLowerCase()] = match[2];
                                    }
                                }
                                match = responseHeaders[key.toLowerCase()];
                            }
                            return match == null ? null : match;
                        },
                        getAllResponseHeaders: function () {
                            return state === 2 ? responseHeadersString : null;
                        },
                        setRequestHeader: function (name, value) {
                            var lname = name.toLowerCase();
                            if (!state) {
                                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                requestHeaders[name] = value;
                            }
                            return this;
                        },
                        overrideMimeType: function (type) {
                            if (!state) {
                                s.mimeType = type;
                            }
                            return this;
                        },
                        statusCode: function (map) {
                            var code;
                            if (map) {
                                if (state < 2) {
                                    for (code in map) {
                                        // Lazy-add the new callback in a way that preserves old ones
                                        statusCode[code] = [
                                            statusCode[code],
                                            map[code]
                                        ];
                                    }
                                } else {
                                    // Execute the appropriate callbacks
                                    jqXHR.always(map[jqXHR.status]);
                                }
                            }
                            return this;
                        },
                        abort: function (statusText) {
                            var finalText = statusText || strAbort;
                            if (transport) {
                                transport.abort(finalText);
                            }
                            done(0, finalText);
                            return this;
                        }
                    };
                // Attach deferreds
                deferred.promise(jqXHR).complete = completeDeferred.add;
                jqXHR.success = jqXHR.done;
                jqXHR.error = jqXHR.fail;
                // Remove hash character (#7531: and string promotion)
                // Add protocol if not provided (prefilters might expect it)
                // Handle falsy url in the settings object (#10093: consistency with old signature)
                // We also use the url parameter if available
                s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
                // Alias method option to type as per ticket #12004
                s.type = options.method || options.type || s.method || s.type;
                // Extract dataTypes list
                s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
                // A cross-domain request is in order when we have a protocol:host:port mismatch
                if (s.crossDomain == null) {
                    parts = rurl.exec(s.url.toLowerCase());
                    s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
                }
                // Convert data if not already a string
                if (s.data && s.processData && typeof s.data !== 'string') {
                    s.data = jQuery.param(s.data, s.traditional);
                }
                // Apply prefilters
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                // If request was aborted inside a prefilter, stop there
                if (state === 2) {
                    return jqXHR;
                }
                // We can fire global events as of now if asked to
                fireGlobals = s.global;
                // Watch for a new set of requests
                if (fireGlobals && jQuery.active++ === 0) {
                    jQuery.event.trigger('ajaxStart');
                }
                // Uppercase the type
                s.type = s.type.toUpperCase();
                // Determine if request has content
                s.hasContent = !rnoContent.test(s.type);
                // Save the URL in case we're toying with the If-Modified-Since
                // and/or If-None-Match header later on
                cacheURL = s.url;
                // More options handling for requests with no content
                if (!s.hasContent) {
                    // If data is available, append data to url
                    if (s.data) {
                        cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
                        // #9682: remove data so that it's not used in an eventual retry
                        delete s.data;
                    }
                    // Add anti-cache in url if needed
                    if (s.cache === false) {
                        s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
                    }
                }
                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if (s.ifModified) {
                    if (jQuery.lastModified[cacheURL]) {
                        jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                    }
                    if (jQuery.etag[cacheURL]) {
                        jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                    }
                }
                // Set the correct header, if data is being sent
                if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                    jqXHR.setRequestHeader('Content-Type', s.contentType);
                }
                // Set the Accepts header for the server, depending on the dataType
                jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
                // Check for headers option
                for (i in s.headers) {
                    jqXHR.setRequestHeader(i, s.headers[i]);
                }
                // Allow custom headers/mimetypes and early abort
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                    // Abort if not done already and return
                    return jqXHR.abort();
                }
                // aborting is no longer a cancellation
                strAbort = 'abort';
                // Install callbacks on deferreds
                for (i in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) {
                    jqXHR[i](s[i]);
                }
                // Get transport
                transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                // If no transport, we auto-abort
                if (!transport) {
                    done(-1, 'No Transport');
                } else {
                    jqXHR.readyState = 1;
                    // Send global event
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxSend', [
                            jqXHR,
                            s
                        ]);
                    }
                    // Timeout
                    if (s.async && s.timeout > 0) {
                        timeoutTimer = setTimeout(function () {
                            jqXHR.abort('timeout');
                        }, s.timeout);
                    }
                    try {
                        state = 1;
                        transport.send(requestHeaders, done);
                    } catch (e) {
                        // Propagate exception as error if not done
                        if (state < 2) {
                            done(-1, e);    // Simply rethrow otherwise
                        } else {
                            throw e;
                        }
                    }
                }
                // Callback for when everything is done
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    // Called once
                    if (state === 2) {
                        return;
                    }
                    // State is "done" now
                    state = 2;
                    // Clear timeout if it exists
                    if (timeoutTimer) {
                        clearTimeout(timeoutTimer);
                    }
                    // Dereference transport for early garbage collection
                    // (no matter how long the jqXHR object will be used)
                    transport = undefined;
                    // Cache response headers
                    responseHeadersString = headers || '';
                    // Set readyState
                    jqXHR.readyState = status > 0 ? 4 : 0;
                    // Determine if successful
                    isSuccess = status >= 200 && status < 300 || status === 304;
                    // Get response data
                    if (responses) {
                        response = ajaxHandleResponses(s, jqXHR, responses);
                    }
                    // Convert no matter what (that way responseXXX fields are always set)
                    response = ajaxConvert(s, response, jqXHR, isSuccess);
                    // If successful, handle type chaining
                    if (isSuccess) {
                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                        if (s.ifModified) {
                            modified = jqXHR.getResponseHeader('Last-Modified');
                            if (modified) {
                                jQuery.lastModified[cacheURL] = modified;
                            }
                            modified = jqXHR.getResponseHeader('etag');
                            if (modified) {
                                jQuery.etag[cacheURL] = modified;
                            }
                        }
                        // if no content
                        if (status === 204 || s.type === 'HEAD') {
                            statusText = 'nocontent';    // if not modified
                        } else if (status === 304) {
                            statusText = 'notmodified';    // If we have data, let's convert it
                        } else {
                            statusText = response.state;
                            success = response.data;
                            error = response.error;
                            isSuccess = !error;
                        }
                    } else {
                        // We extract error from statusText
                        // then normalize statusText and status for non-aborts
                        error = statusText;
                        if (status || !statusText) {
                            statusText = 'error';
                            if (status < 0) {
                                status = 0;
                            }
                        }
                    }
                    // Set data for the fake xhr object
                    jqXHR.status = status;
                    jqXHR.statusText = (nativeStatusText || statusText) + '';
                    // Success/Error
                    if (isSuccess) {
                        deferred.resolveWith(callbackContext, [
                            success,
                            statusText,
                            jqXHR
                        ]);
                    } else {
                        deferred.rejectWith(callbackContext, [
                            jqXHR,
                            statusText,
                            error
                        ]);
                    }
                    // Status-dependent callbacks
                    jqXHR.statusCode(statusCode);
                    statusCode = undefined;
                    if (fireGlobals) {
                        globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                            jqXHR,
                            s,
                            isSuccess ? success : error
                        ]);
                    }
                    // Complete
                    completeDeferred.fireWith(callbackContext, [
                        jqXHR,
                        statusText
                    ]);
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxComplete', [
                            jqXHR,
                            s
                        ]);
                        // Handle the global AJAX counter
                        if (!--jQuery.active) {
                            jQuery.event.trigger('ajaxStop');
                        }
                    }
                }
                return jqXHR;
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, 'json');
            },
            getScript: function (url, callback) {
                return jQuery.get(url, undefined, callback, 'script');
            }
        });
        jQuery.each([
            'get',
            'post'
        ], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
                // shift arguments if data argument was omitted
                if (jQuery.isFunction(data)) {
                    type = type || callback;
                    callback = data;
                    data = undefined;
                }
                return jQuery.ajax({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                });
            };
        });
        /* Handles responses to an ajax request:
         * - finds the right dataType (mediates between content-type and expected dataType)
         * - returns the corresponding response
         */
        function ajaxHandleResponses(s, jqXHR, responses) {
            var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
            // Remove auto dataType and get content-type in the process
            while (dataTypes[0] === '*') {
                dataTypes.shift();
                if (ct === undefined) {
                    ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
                }
            }
            // Check if we're dealing with a known content-type
            if (ct) {
                for (type in contents) {
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break;
                    }
                }
            }
            // Check to see if we have a response for the expected dataType
            if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0];
            } else {
                // Try convertible dataTypes
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                        finalDataType = type;
                        break;
                    }
                    if (!firstDataType) {
                        firstDataType = type;
                    }
                }
                // Or just use first one
                finalDataType = finalDataType || firstDataType;
            }
            // If we found a dataType
            // We add the dataType to the list if needed
            // and return the corresponding response
            if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                    dataTypes.unshift(finalDataType);
                }
                return responses[finalDataType];
            }
        }
        /* Chain conversions given the request and the original response
         * Also sets the responseXXX fields on the jqXHR instance
         */
        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {},
                // Work with a copy of dataTypes in case we need to modify it for conversion
                dataTypes = s.dataTypes.slice();
            // Create converters map with lowercased keys
            if (dataTypes[1]) {
                for (conv in s.converters) {
                    converters[conv.toLowerCase()] = s.converters[conv];
                }
            }
            current = dataTypes.shift();
            // Convert to each sequential dataType
            while (current) {
                if (s.responseFields[current]) {
                    jqXHR[s.responseFields[current]] = response;
                }
                // Apply the dataFilter if provided
                if (!prev && isSuccess && s.dataFilter) {
                    response = s.dataFilter(response, s.dataType);
                }
                prev = current;
                current = dataTypes.shift();
                if (current) {
                    // There's only work to do if current dataType is non-auto
                    if (current === '*') {
                        current = prev;    // Convert response if prev dataType is non-auto and differs from current
                    } else if (prev !== '*' && prev !== current) {
                        // Seek a direct converter
                        conv = converters[prev + ' ' + current] || converters['* ' + current];
                        // If none found, seek a pair
                        if (!conv) {
                            for (conv2 in converters) {
                                // If conv2 outputs current
                                tmp = conv2.split(' ');
                                if (tmp[1] === current) {
                                    // If prev can be converted to accepted input
                                    conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                    if (conv) {
                                        // Condense equivalence converters
                                        if (conv === true) {
                                            conv = converters[conv2];    // Otherwise, insert the intermediate dataType
                                        } else if (converters[conv2] !== true) {
                                            current = tmp[0];
                                            dataTypes.unshift(tmp[1]);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        // Apply converter (if not an equivalence)
                        if (conv !== true) {
                            // Unless errors are allowed to bubble, catch and return them
                            if (conv && s['throws']) {
                                response = conv(response);
                            } else {
                                try {
                                    response = conv(response);
                                } catch (e) {
                                    return {
                                        state: 'parsererror',
                                        error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                    };
                                }
                            }
                        }
                    }
                }
            }
            return {
                state: 'success',
                data: response
            };
        }
        // Install script dataType
        jQuery.ajaxSetup({
            accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
            contents: { script: /(?:java|ecma)script/ },
            converters: {
                'text script': function (text) {
                    jQuery.globalEval(text);
                    return text;
                }
            }
        });
        // Handle cache's special case and crossDomain
        jQuery.ajaxPrefilter('script', function (s) {
            if (s.cache === undefined) {
                s.cache = false;
            }
            if (s.crossDomain) {
                s.type = 'GET';
            }
        });
        // Bind script tag hack transport
        jQuery.ajaxTransport('script', function (s) {
            // This transport only deals with cross domain requests
            if (s.crossDomain) {
                var script, callback;
                return {
                    send: function (_, complete) {
                        script = jQuery('<script>').prop({
                            async: true,
                            charset: s.scriptCharset,
                            src: s.url
                        }).on('load error', callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === 'error' ? 404 : 200, evt.type);
                            }
                        });
                        document.head.appendChild(script[0]);
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        // Default jsonp settings
        jQuery.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
                this[callback] = true;
                return callback;
            }
        });
        // Detect, normalize options and install callbacks for jsonp requests
        jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
            // Handle iff the expected data type is "jsonp" or we have a parameter to set
            if (jsonProp || s.dataTypes[0] === 'jsonp') {
                // Get callback name, remembering preexisting value associated with it
                callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                // Insert callback into url or form data
                if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
                } else if (s.jsonp !== false) {
                    s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
                }
                // Use data converter to retrieve json after script execution
                s.converters['script json'] = function () {
                    if (!responseContainer) {
                        jQuery.error(callbackName + ' was not called');
                    }
                    return responseContainer[0];
                };
                // force json dataType
                s.dataTypes[0] = 'json';
                // Install callback
                overwritten = window[callbackName];
                window[callbackName] = function () {
                    responseContainer = arguments;
                };
                // Clean-up function (fires after converters)
                jqXHR.always(function () {
                    // Restore preexisting value
                    window[callbackName] = overwritten;
                    // Save back as free
                    if (s[callbackName]) {
                        // make sure that re-using the options doesn't screw things around
                        s.jsonpCallback = originalSettings.jsonpCallback;
                        // save the callback name for future use
                        oldCallbacks.push(callbackName);
                    }
                    // Call if it was a function and we have a response
                    if (responseContainer && jQuery.isFunction(overwritten)) {
                        overwritten(responseContainer[0]);
                    }
                    responseContainer = overwritten = undefined;
                });
                // Delegate to script
                return 'script';
            }
        });
        jQuery.ajaxSettings.xhr = function () {
            try {
                return new XMLHttpRequest();
            } catch (e) {
            }
        };
        var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
                0: 200,
                1223: 204
            },
            // Support: IE9
            // We need to keep track of outbound xhr and abort them manually
            // because IE is not smart enough to do it all by itself
            xhrId = 0, xhrCallbacks = {};
        if (window.ActiveXObject) {
            jQuery(window).on('unload', function () {
                for (var key in xhrCallbacks) {
                    xhrCallbacks[key]();
                }
                xhrCallbacks = undefined;
            });
        }
        jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
        jQuery.support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function (options) {
            var callback;
            // Cross domain only allowed if supported through XMLHttpRequest
            if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
                return {
                    send: function (headers, complete) {
                        var i, id, xhr = options.xhr();
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        // Apply custom fields if provided
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        // Override mime type if needed
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        // Set headers
                        for (i in headers) {
                            xhr.setRequestHeader(i, headers[i]);
                        }
                        // Callback
                        callback = function (type) {
                            return function () {
                                if (callback) {
                                    delete xhrCallbacks[id];
                                    callback = xhr.onload = xhr.onerror = null;
                                    if (type === 'abort') {
                                        xhr.abort();
                                    } else if (type === 'error') {
                                        complete(xhr.status || 404, xhr.statusText);
                                    } else {
                                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                                    }
                                }
                            };
                        };
                        // Listen to events
                        xhr.onload = callback();
                        xhr.onerror = callback('error');
                        // Create the abort callback
                        callback = xhrCallbacks[id = xhrId++] = callback('abort');
                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send(options.hasContent && options.data || null);
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
                '*': [function (prop, value) {
                        var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'),
                            // Starting value computation is required for potential unit mismatches
                            start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                        if (start && start[3] !== unit) {
                            // Trust units reported by jQuery.css
                            unit = unit || start[3];
                            // Make sure we update the tween properties later on
                            parts = parts || [];
                            // Iteratively approximate from a nonzero starting point
                            start = +target || 1;
                            do {
                                // If previous iteration zeroed out, double until we get *something*
                                // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                                scale = scale || '.5';
                                // Adjust and apply
                                start = start / scale;
                                jQuery.style(tween.elem, prop, start + unit);    // Update scale, tolerating zero or NaN from tween.cur()
                                                                                 // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                        }
                        // Update tween properties
                        if (parts) {
                            start = tween.start = +start || +target || 0;
                            tween.unit = unit;
                            // If a +=/-= token was provided, we're doing a relative animation
                            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                        }
                        return tween;
                    }]
            };
        // Animations created synchronously will run synchronously
        function createFxNow() {
            setTimeout(function () {
                fxNow = undefined;
            });
            return fxNow = jQuery.now();
        }
        function createTween(value, prop, animation) {
            var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
            for (; index < length; index++) {
                if (tween = collection[index].call(animation, prop, value)) {
                    // we're done with this property
                    return tween;
                }
            }
        }
        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                    // don't match elem in the :animated selector
                    delete tick.elem;
                }), tick = function () {
                    if (stopped) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                        // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                        temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                    for (; index < length; index++) {
                        animation.tweens[index].run(percent);
                    }
                    deferred.notifyWith(elem, [
                        animation,
                        percent,
                        remaining
                    ]);
                    if (percent < 1 && length) {
                        return remaining;
                    } else {
                        deferred.resolveWith(elem, [animation]);
                        return false;
                    }
                }, animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(true, { specialEasing: {} }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function (prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        animation.tweens.push(tween);
                        return tween;
                    },
                    stop: function (gotoEnd) {
                        var index = 0,
                            // if we are going to the end, we want to run all the tweens
                            // otherwise we skip this part
                            length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) {
                            return this;
                        }
                        stopped = true;
                        for (; index < length; index++) {
                            animation.tweens[index].run(1);
                        }
                        // resolve when we played the last frame
                        // otherwise, reject
                        if (gotoEnd) {
                            deferred.resolveWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        } else {
                            deferred.rejectWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        }
                        return this;
                    }
                }), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
                result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                if (result) {
                    return result;
                }
            }
            jQuery.map(props, createTween, animation);
            if (jQuery.isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation);
            }
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            }));
            // attach callbacks from options
            return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        }
        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            // camelCase, specialEasing and expand cssHook pass
            for (index in props) {
                name = jQuery.camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (jQuery.isArray(value)) {
                    easing = value[1];
                    value = props[index] = value[0];
                }
                if (index !== name) {
                    props[name] = value;
                    delete props[index];
                }
                hooks = jQuery.cssHooks[name];
                if (hooks && 'expand' in hooks) {
                    value = hooks.expand(value);
                    delete props[name];
                    // not quite $.extend, this wont overwrite keys already present.
                    // also - reusing 'index' from above because we have the correct "name"
                    for (index in value) {
                        if (!(index in props)) {
                            props[index] = value[index];
                            specialEasing[index] = easing;
                        }
                    }
                } else {
                    specialEasing[name] = easing;
                }
            }
        }
        jQuery.Animation = jQuery.extend(Animation, {
            tweener: function (props, callback) {
                if (jQuery.isFunction(props)) {
                    callback = props;
                    props = ['*'];
                } else {
                    props = props.split(' ');
                }
                var prop, index = 0, length = props.length;
                for (; index < length; index++) {
                    prop = props[index];
                    tweeners[prop] = tweeners[prop] || [];
                    tweeners[prop].unshift(callback);
                }
            },
            prefilter: function (callback, prepend) {
                if (prepend) {
                    animationPrefilters.unshift(callback);
                } else {
                    animationPrefilters.push(callback);
                }
            }
        });
        function defaultPrefilter(elem, props, opts) {
            /* jshint validthis: true */
            var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
            // handle queue: false promises
            if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, 'fx');
                if (hooks.unqueued == null) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function () {
                        if (!hooks.unqueued) {
                            oldfire();
                        }
                    };
                }
                hooks.unqueued++;
                anim.always(function () {
                    // doing this makes sure that the complete handler will be called
                    // before this completes
                    anim.always(function () {
                        hooks.unqueued--;
                        if (!jQuery.queue(elem, 'fx').length) {
                            hooks.empty.fire();
                        }
                    });
                });
            }
            // height/width overflow pass
            if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
                // Make sure that nothing sneaks out
                // Record all 3 overflow attributes because IE9-10 do not
                // change the overflow attribute when overflowX and
                // overflowY are set to the same value
                opts.overflow = [
                    style.overflow,
                    style.overflowX,
                    style.overflowY
                ];
                // Set display property to inline-block for height/width
                // animations on inline elements that are having width/height animated
                if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
                    style.display = 'inline-block';
                }
            }
            if (opts.overflow) {
                style.overflow = 'hidden';
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
            // show/hide pass
            for (prop in props) {
                value = props[prop];
                if (rfxtypes.exec(value)) {
                    delete props[prop];
                    toggle = toggle || value === 'toggle';
                    if (value === (hidden ? 'hide' : 'show')) {
                        // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                        if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                            hidden = true;
                        } else {
                            continue;
                        }
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                }
            }
            if (!jQuery.isEmptyObject(orig)) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = data_priv.access(elem, 'fxshow', {});
                }
                // store state if its toggle - enables .stop().toggle() to "reverse"
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    jQuery(elem).show();
                } else {
                    anim.done(function () {
                        jQuery(elem).hide();
                    });
                }
                anim.done(function () {
                    var prop;
                    data_priv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
                for (prop in orig) {
                    tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                    if (!(prop in dataShow)) {
                        dataShow[prop] = tween.start;
                        if (hidden) {
                            tween.end = tween.start;
                            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                        }
                    }
                }
            }
        }
        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || 'swing';
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                if (this.options.duration) {
                    this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                } else {
                    this.pos = eased = percent;
                }
                this.now = (this.end - this.start) * eased + this.start;
                if (this.options.step) {
                    this.options.step.call(this.elem, this.now, this);
                }
                if (hooks && hooks.set) {
                    hooks.set(this);
                } else {
                    Tween.propHooks._default.set(this);
                }
                return this;
            }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                        return tween.elem[tween.prop];
                    }
                    // passing an empty string as a 3rd parameter to .css will automatically
                    // attempt a parseFloat and fallback to a string if the parse fails
                    // so, simple values such as "10px" are parsed to Float.
                    // complex values such as "rotate(1rad)" are returned as is.
                    result = jQuery.css(tween.elem, tween.prop, '');
                    // Empty strings, null, undefined and "auto" are converted to 0.
                    return !result || result === 'auto' ? 0 : result;
                },
                set: function (tween) {
                    // use step hook for back compat - use cssHook if its there - use .style if its
                    // available and use plain properties where available
                    if (jQuery.fx.step[tween.prop]) {
                        jQuery.fx.step[tween.prop](tween);
                    } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                    } else {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            }
        };
        // Support: IE9
        // Panic based approach to setting things on disconnected nodes
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                if (tween.elem.nodeType && tween.elem.parentNode) {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        };
        jQuery.each([
            'toggle',
            'show',
            'hide'
        ], function (i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function (speed, easing, callback) {
                return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
        });
        jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
                // show any hidden elements after setting opacity to 0
                return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
            },
            animate: function (prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                        // Operate on a copy of prop so per-property easing won't be lost
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        // Empty animations, or finishing resolves immediately
                        if (empty || data_priv.get(this, 'finish')) {
                            anim.stop(true);
                        }
                    };
                doAnimation.finish = doAnimation;
                return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function (type, clearQueue, gotoEnd) {
                var stopQueue = function (hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop;
                    stop(gotoEnd);
                };
                if (typeof type !== 'string') {
                    gotoEnd = clearQueue;
                    clearQueue = type;
                    type = undefined;
                }
                if (clearQueue && type !== false) {
                    this.queue(type || 'fx', []);
                }
                return this.each(function () {
                    var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
                    if (index) {
                        if (data[index] && data[index].stop) {
                            stopQueue(data[index]);
                        }
                    } else {
                        for (index in data) {
                            if (data[index] && data[index].stop && rrun.test(index)) {
                                stopQueue(data[index]);
                            }
                        }
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                            timers[index].anim.stop(gotoEnd);
                            dequeue = false;
                            timers.splice(index, 1);
                        }
                    }
                    // start the next in the queue if the last step wasn't forced
                    // timers currently will call their complete callbacks, which will dequeue
                    // but only if they were gotoEnd
                    if (dequeue || !gotoEnd) {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            finish: function (type) {
                if (type !== false) {
                    type = type || 'fx';
                }
                return this.each(function () {
                    var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                    // enable finishing flag on private data
                    data.finish = true;
                    // empty the queue first
                    jQuery.queue(this, type, []);
                    if (hooks && hooks.stop) {
                        hooks.stop.call(this, true);
                    }
                    // look for any active animations, and finish them
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && timers[index].queue === type) {
                            timers[index].anim.stop(true);
                            timers.splice(index, 1);
                        }
                    }
                    // look for any animations in the old queue and finish them
                    for (index = 0; index < length; index++) {
                        if (queue[index] && queue[index].finish) {
                            queue[index].finish.call(this);
                        }
                    }
                    // turn off finishing flag
                    delete data.finish;
                });
            }
        });
        // Generate parameters to create a standard animation
        function genFx(type, includeWidth) {
            var which, attrs = { height: type }, i = 0;
            // if we include width, step value is 1 to do all cssExpand values,
            // if we don't include width, step value is 2 to skip over Left and Right
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs['margin' + which] = attrs['padding' + which] = type;
            }
            if (includeWidth) {
                attrs.opacity = attrs.width = type;
            }
            return attrs;
        }
        // Generate shortcuts for custom animations
        jQuery.each({
            slideDown: genFx('show'),
            slideUp: genFx('hide'),
            slideToggle: genFx('toggle'),
            fadeIn: { opacity: 'show' },
            fadeOut: { opacity: 'hide' },
            fadeToggle: { opacity: 'toggle' }
        }, function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        });
        jQuery.speed = function (speed, easing, fn) {
            var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
            // normalize opt.queue - true/undefined/null -> "fx"
            if (opt.queue == null || opt.queue === true) {
                opt.queue = 'fx';
            }
            // Queueing
            opt.old = opt.complete;
            opt.complete = function () {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }
                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue);
                }
            };
            return opt;
        };
        jQuery.easing = {
            linear: function (p) {
                return p;
            },
            swing: function (p) {
                return 0.5 - Math.cos(p * Math.PI) / 2;
            }
        };
        jQuery.timers = [];
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.tick = function () {
            var timer, timers = jQuery.timers, i = 0;
            fxNow = jQuery.now();
            for (; i < timers.length; i++) {
                timer = timers[i];
                // Checks the timer has not already been removed
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1);
                }
            }
            if (!timers.length) {
                jQuery.fx.stop();
            }
            fxNow = undefined;
        };
        jQuery.fx.timer = function (timer) {
            if (timer() && jQuery.timers.push(timer)) {
                jQuery.fx.start();
            }
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function () {
            if (!timerId) {
                timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
            }
        };
        jQuery.fx.stop = function () {
            clearInterval(timerId);
            timerId = null;
        };
        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        };
        // Back Compat <1.8 extension point
        jQuery.fx.step = {};
        if (jQuery.expr && jQuery.expr.filters) {
            jQuery.expr.filters.animated = function (elem) {
                return jQuery.grep(jQuery.timers, function (fn) {
                    return elem === fn.elem;
                }).length;
            };
        }
        jQuery.fn.offset = function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                    top: 0,
                    left: 0
                }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if (typeof elem.getBoundingClientRect !== core_strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        };
        jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
                // Set position first, in-case top/left are set even on static elem
                if (position === 'static') {
                    elem.style.position = 'relative';
                }
                curOffset = curElem.offset();
                curCSSTop = jQuery.css(elem, 'top');
                curCSSLeft = jQuery.css(elem, 'left');
                calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
                // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
                if (calculatePosition) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }
                if (jQuery.isFunction(options)) {
                    options = options.call(elem, i, curOffset);
                }
                if (options.top != null) {
                    props.top = options.top - curOffset.top + curTop;
                }
                if (options.left != null) {
                    props.left = options.left - curOffset.left + curLeft;
                }
                if ('using' in options) {
                    options.using.call(elem, props);
                } else {
                    curElem.css(props);
                }
            }
        };
        jQuery.fn.extend({
            position: function () {
                if (!this[0]) {
                    return;
                }
                var offsetParent, offset, elem = this[0], parentOffset = {
                        top: 0,
                        left: 0
                    };
                // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
                if (jQuery.css(elem, 'position') === 'fixed') {
                    // We assume that getBoundingClientRect is available when computed position is fixed
                    offset = elem.getBoundingClientRect();
                } else {
                    // Get *real* offsetParent
                    offsetParent = this.offsetParent();
                    // Get correct offsets
                    offset = this.offset();
                    if (!jQuery.nodeName(offsetParent[0], 'html')) {
                        parentOffset = offsetParent.offset();
                    }
                    // Add offsetParent borders
                    parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                    parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
                }
                // Subtract parent offsets and element margins
                return {
                    top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                    left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
                };
            },
            offsetParent: function () {
                return this.map(function () {
                    var offsetParent = this.offsetParent || docElem;
                    while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || docElem;
                });
            }
        });
        // Create scrollLeft and scrollTop methods
        jQuery.each({
            scrollLeft: 'pageXOffset',
            scrollTop: 'pageYOffset'
        }, function (method, prop) {
            var top = 'pageYOffset' === prop;
            jQuery.fn[method] = function (val) {
                return jQuery.access(this, function (elem, method, val) {
                    var win = getWindow(elem);
                    if (val === undefined) {
                        return win ? win[prop] : elem[method];
                    }
                    if (win) {
                        win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                    } else {
                        elem[method] = val;
                    }
                }, method, val, arguments.length, null);
            };
        });
        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
        }
        // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
        jQuery.each({
            Height: 'height',
            Width: 'width'
        }, function (name, type) {
            jQuery.each({
                padding: 'inner' + name,
                content: type,
                '': 'outer' + name
            }, function (defaultExtra, funcName) {
                // margin is only for outerHeight, outerWidth
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                    return jQuery.access(this, function (elem, type, value) {
                        var doc;
                        if (jQuery.isWindow(elem)) {
                            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                            // isn't a whole lot we can do. See pull request at this URL for discussion:
                            // https://github.com/jquery/jquery/pull/764
                            return elem.document.documentElement['client' + name];
                        }
                        // Get document width or height
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;
                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                        }
                        return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable, null);
                };
            });
        });
        // Limit scope pollution from any deprecated API
        // (function() {
        // The number of elements contained in the matched element set
        jQuery.fn.size = function () {
            return this.length;
        };
        jQuery.fn.andSelf = jQuery.fn.addBack;
        // })();
        if (typeof module === 'object' && module && typeof module.exports === 'object') {
            // Expose jQuery as module.exports in loaders that implement the Node
            // module pattern (including browserify). Do not create the global, since
            // the user will be storing it themselves locally, and globals are frowned
            // upon in the Node module world.
            module.exports = jQuery;
        } else {
            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.
            if (true) {
                jquery = function () {
                    return jQuery;
                }();
            }
        }
        // If there is a window object, that at least has a document property,
        // define jQuery and $ identifiers
        if (typeof window === 'object' && typeof window.document === 'object') {
            window.jQuery = window.$ = jQuery;
        }
    }(window));    /**
                    * @license
                    * Lo-Dash 1.3.1 (Custom Build) <http://lodash.com/>
                    * Build: `lodash -o ./dist/lodash.compat.js`
                    * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
                    * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
                    * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
                    * Available under MIT license <http://lodash.com/license>
                    */
    (function (window) {
        /** Used as a safe reference for `undefined` in pre ES5 environments */
        var undefined;
        /** Used to pool arrays and objects used internally */
        var arrayPool = [], objectPool = [];
        /** Used to generate unique IDs */
        var idCounter = 0;
        /** Used internally to indicate various things */
        var indicatorObject = {};
        /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
        var keyPrefix = +new Date() + '';
        /** Used as the size when optimizations are enabled for large arrays */
        var largeArraySize = 75;
        /** Used as the max size of the `arrayPool` and `objectPool` */
        var maxPoolSize = 40;
        /** Used to match empty string literals in compiled template source */
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        /** Used to match HTML entities */
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
        /**
         * Used to match ES6 template delimiters
         * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        /** Used to match regexp flags from their coerced string values */
        var reFlags = /\w*$/;
        /** Used to match "interpolate" template delimiters */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
        /** Used to detect functions containing a `this` reference */
        var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;
        /** Used to detect and test whitespace */
        var whitespace = ' \t\x0B\f\xa0\ufeff' + '\n\r\u2028\u2029' + '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
        /** Used to match leading whitespace and zeros to be removed */
        var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
        /** Used to ensure capturing order of template delimiters */
        var reNoMatch = /($^)/;
        /** Used to match HTML characters */
        var reUnescapedHtml = /[&<>"']/g;
        /** Used to match unescaped characters in compiled string literals */
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
        /** Used to assign default `context` object properties */
        var contextProps = [
                'Array',
                'Boolean',
                'Date',
                'Error',
                'Function',
                'Math',
                'Number',
                'Object',
                'RegExp',
                'String',
                '_',
                'attachEvent',
                'clearTimeout',
                'isFinite',
                'isNaN',
                'parseInt',
                'setImmediate',
                'setTimeout'
            ];
        /** Used to fix the JScript [[DontEnum]] bug */
        var shadowedProps = [
                'constructor',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'toLocaleString',
                'toString',
                'valueOf'
            ];
        /** Used to make template sourceURLs easier to identify */
        var templateCounter = 0;
        /** `Object#toString` result shortcuts */
        var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', errorClass = '[object Error]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
        /** Used to identify object classifications that `_.clone` supports */
        var cloneableClasses = {};
        cloneableClasses[funcClass] = false;
        cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
        /** Used to determine if values are of the language type Object */
        var objectTypes = {
                'boolean': false,
                'function': true,
                'object': true,
                'number': false,
                'string': false,
                'undefined': false
            };
        /** Used to escape characters for inclusion in compiled string literals */
        var stringEscapes = {
                '\\': '\\',
                '\'': '\'',
                '\n': 'n',
                '\r': 'r',
                '\t': 't',
                '\u2028': 'u2028',
                '\u2029': 'u2029'
            };
        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports] && exports;
        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module] && module && module.exports == freeExports && module;
        /** Detect free variable `global`, from Node.js or Browserified code, and use it as `window` */
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
            window = freeGlobal;
        }
        /*--------------------------------------------------------------------------*/
        /**
         * A basic implementation of `_.indexOf` without support for binary searches
         * or `fromIndex` constraints.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {Mixed} value The value to search for.
         * @param {Number} [fromIndex=0] The index to search from.
         * @returns {Number} Returns the index of the matched value or `-1`.
         */
        function basicIndexOf(array, value, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array.length;
            while (++index < length) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        /**
         * An implementation of `_.contains` for cache objects that mimics the return
         * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache object to inspect.
         * @param {Mixed} value The value to search for.
         * @returns {Number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
            var type = typeof value;
            cache = cache.cache;
            if (type == 'boolean' || value == null) {
                return cache[value];
            }
            if (type != 'number' && type != 'string') {
                type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value;
            cache = cache[type] || (cache[type] = {});
            return type == 'object' ? cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1 : cache[key] ? 0 : -1;
        }
        /**
         * Adds a given `value` to the corresponding cache object.
         *
         * @private
         * @param {Mixed} value The value to add to the cache.
         */
        function cachePush(value) {
            var cache = this.cache, type = typeof value;
            if (type == 'boolean' || value == null) {
                cache[value] = true;
            } else {
                if (type != 'number' && type != 'string') {
                    type = 'object';
                }
                var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                if (type == 'object') {
                    if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
                        cache[type] = false;
                    }
                } else {
                    typeCache[key] = true;
                }
            }
        }
        /**
         * Used by `_.max` and `_.min` as the default `callback` when a given
         * `collection` is a string value.
         *
         * @private
         * @param {String} value The character to inspect.
         * @returns {Number} Returns the code unit of given character.
         */
        function charAtCallback(value) {
            return value.charCodeAt(0);
        }
        /**
         * Used by `sortBy` to compare transformed `collection` values, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {Number} Returns the sort order indicator of `1` or `-1`.
         */
        function compareAscending(a, b) {
            var ai = a.index, bi = b.index;
            a = a.criteria;
            b = b.criteria;
            // ensure a stable sort in V8 and other engines
            // http://code.google.com/p/v8/issues/detail?id=90
            if (a !== b) {
                if (a > b || typeof a == 'undefined') {
                    return 1;
                }
                if (a < b || typeof b == 'undefined') {
                    return -1;
                }
            }
            return ai < bi ? -1 : 1;
        }
        /**
         * Creates a cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [array=[]] The array to search.
         * @returns {Null|Object} Returns the cache object or `null` if caching should not be used.
         */
        function createCache(array) {
            var index = -1, length = array.length;
            var cache = getObject();
            cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
            var result = getObject();
            result.array = array;
            result.cache = cache;
            result.push = cachePush;
            while (++index < length) {
                result.push(array[index]);
            }
            return cache.object === false ? (releaseObject(result), null) : result;
        }
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {String} match The matched character to escape.
         * @returns {String} Returns the escaped character.
         */
        function escapeStringChar(match) {
            return '\\' + stringEscapes[match];
        }
        /**
         * Gets an array from the array pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Array} The array from the pool.
         */
        function getArray() {
            return arrayPool.pop() || [];
        }
        /**
         * Gets an object from the object pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Object} The object from the pool.
         */
        function getObject() {
            return objectPool.pop() || {
                'args': '',
                'array': null,
                'bottom': '',
                'cache': null,
                'criteria': null,
                'false': false,
                'firstArg': '',
                'index': 0,
                'init': '',
                'leading': false,
                'loop': '',
                'maxWait': 0,
                'null': false,
                'number': null,
                'object': null,
                'push': null,
                'shadowedProps': null,
                'string': null,
                'top': '',
                'trailing': false,
                'true': false,
                'undefined': false,
                'useHas': false,
                'useKeys': false,
                'value': null
            };
        }
        /**
         * Checks if `value` is a DOM node in IE < 9.
         *
         * @private
         * @param {Mixed} value The value to check.
         * @returns {Boolean} Returns `true` if the `value` is a DOM node, else `false`.
         */
        function isNode(value) {
            // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
            // methods that are `typeof` "string" and still can coerce nodes to strings
            return typeof value.toString != 'function' && typeof (value + '') == 'string';
        }
        /**
         * A no-operation function.
         *
         * @private
         */
        function noop() {
        }
        /**
         * Releases the given `array` back to the array pool.
         *
         * @private
         * @param {Array} [array] The array to release.
         */
        function releaseArray(array) {
            array.length = 0;
            if (arrayPool.length < maxPoolSize) {
                arrayPool.push(array);
            }
        }
        /**
         * Releases the given `object` back to the object pool.
         *
         * @private
         * @param {Object} [object] The object to release.
         */
        function releaseObject(object) {
            var cache = object.cache;
            if (cache) {
                releaseObject(cache);
            }
            object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
            if (objectPool.length < maxPoolSize) {
                objectPool.push(object);
            }
        }
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used, instead of `Array#slice`, to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|String} collection The collection to slice.
         * @param {Number} start The start index.
         * @param {Number} end The end index.
         * @returns {Array} Returns the new array.
         */
        function slice(array, start, end) {
            start || (start = 0);
            if (typeof end == 'undefined') {
                end = array ? array.length : 0;
            }
            var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = array[start + index];
            }
            return result;
        }
        /*--------------------------------------------------------------------------*/
        /**
         * Create a new `lodash` function using the given `context` object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} [context=window] The context object.
         * @returns {Function} Returns the `lodash` function.
         */
        function runInContext(context) {
            // Avoid issues with some ES3 environments that attempt to use values, named
            // after built-in constructors like `Object`, for the creation of literals.
            // ES5 clears this up by stating that literals must use built-in constructors.
            // See http://es5.github.com/#x11.1.5.
            context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;
            /** Native constructor references */
            var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
            /**
             * Used for `Array` method references.
             *
             * Normally `Array.prototype` would suffice, however, using an array literal
             * avoids issues in Narwhal.
             */
            var arrayRef = [];
            /** Used for native method references */
            var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
            /** Used to restore the original `_` reference in `noConflict` */
            var oldDash = context._;
            /** Used to detect if a method is native */
            var reNative = RegExp('^' + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/valueOf|for [^\]]+/g, '.+?') + '$');
            /** Native method shortcuts */
            var ceil = Math.ceil, clearTimeout = context.clearTimeout, concat = arrayRef.concat, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setImmediate = context.setImmediate, setTimeout = context.setTimeout, toString = objectProto.toString;
            /* Native method shortcuts for methods with the same name as other `lodash` methods */
            var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice;
            /** Detect various environments */
            var isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);
            /** Used to lookup a built-in constructor by [[Class]] */
            var ctorByClass = {};
            ctorByClass[arrayClass] = Array;
            ctorByClass[boolClass] = Boolean;
            ctorByClass[dateClass] = Date;
            ctorByClass[funcClass] = Function;
            ctorByClass[objectClass] = Object;
            ctorByClass[numberClass] = Number;
            ctorByClass[regexpClass] = RegExp;
            ctorByClass[stringClass] = String;
            /** Used to avoid iterating non-enumerable properties in IE < 9 */
            var nonEnumProps = {};
            nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
                'constructor': true,
                'toLocaleString': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
                'constructor': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
                'constructor': true,
                'toString': true
            };
            nonEnumProps[objectClass] = { 'constructor': true };
            (function () {
                var length = shadowedProps.length;
                while (length--) {
                    var prop = shadowedProps[length];
                    for (var className in nonEnumProps) {
                        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], prop)) {
                            nonEnumProps[className][prop] = false;
                        }
                    }
                }
            }());
            /*--------------------------------------------------------------------------*/
            /**
             * Creates a `lodash` object, which wraps the given `value`, to enable method
             * chaining.
             *
             * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
             * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
             * and `unshift`
             *
             * Chaining is supported in custom builds as long as the `value` method is
             * implicitly or explicitly included in the build.
             *
             * The chainable wrapper functions are:
             * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
             * `compose`, `concat`, `countBy`, `createCallback`, `debounce`, `defaults`,
             * `defer`, `delay`, `difference`, `filter`, `flatten`, `forEach`, `forIn`,
             * `forOwn`, `functions`, `groupBy`, `initial`, `intersection`, `invert`,
             * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
             * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `push`, `range`,
             * `reject`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`,
             * `tap`, `throttle`, `times`, `toArray`, `transform`, `union`, `uniq`, `unshift`,
             * `unzip`, `values`, `where`, `without`, `wrap`, and `zip`
             *
             * The non-chainable wrapper functions are:
             * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `has`,
             * `identity`, `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`,
             * `isElement`, `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`,
             * `isNull`, `isNumber`, `isObject`, `isPlainObject`, `isRegExp`, `isString`,
             * `isUndefined`, `join`, `lastIndexOf`, `mixin`, `noConflict`, `parseInt`,
             * `pop`, `random`, `reduce`, `reduceRight`, `result`, `shift`, `size`, `some`,
             * `sortedIndex`, `runInContext`, `template`, `unescape`, `uniqueId`, and `value`
             *
             * The wrapper functions `first` and `last` return wrapped values when `n` is
             * passed, otherwise they return unwrapped values.
             *
             * @name _
             * @constructor
             * @alias chain
             * @category Chaining
             * @param {Mixed} value The value to wrap in a `lodash` instance.
             * @returns {Object} Returns a `lodash` instance.
             * @example
             *
             * var wrapped = _([1, 2, 3]);
             *
             * // returns an unwrapped value
             * wrapped.reduce(function(sum, num) {
             *   return sum + num;
             * });
             * // => 6
             *
             * // returns a wrapped value
             * var squares = wrapped.map(function(num) {
             *   return num * num;
             * });
             *
             * _.isArray(squares);
             * // => false
             *
             * _.isArray(squares.value());
             * // => true
             */
            function lodash(value) {
                // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
                return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
            }
            /**
             * A fast path for creating `lodash` wrapper objects.
             *
             * @private
             * @param {Mixed} value The value to wrap in a `lodash` instance.
             * @returns {Object} Returns a `lodash` instance.
             */
            function lodashWrapper(value) {
                this.__wrapped__ = value;
            }
            // ensure `new lodashWrapper` is an instance of `lodash`
            lodashWrapper.prototype = lodash.prototype;
            /**
             * An object used to flag environments features.
             *
             * @static
             * @memberOf _
             * @type Object
             */
            var support = lodash.support = {};
            (function () {
                var ctor = function () {
                        this.x = 1;
                    }, object = {
                        '0': 1,
                        'length': 1
                    }, props = [];
                ctor.prototype = {
                    'valueOf': 1,
                    'y': 1
                };
                for (var prop in new ctor()) {
                    props.push(prop);
                }
                for (prop in arguments) {
                }
                /**
                 * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
                /**
                 * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.argsClass = isArguments(arguments);
                /**
                 * Detect if `name` or `message` properties of `Error.prototype` are
                 * enumerable by default. (IE < 9, Safari < 5.1)
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
                /**
                 * Detect if `prototype` properties are enumerable by default.
                 *
                 * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
                 * (if the prototype or a property on the prototype has been set)
                 * incorrectly sets a function's `prototype` property [[Enumerable]]
                 * value to `true`.
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
                /**
                 * Detect if `Function#bind` exists and is inferred to be fast (all but V8).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.fastBind = nativeBind && !isV8;
                /**
                 * Detect if own properties are iterated after inherited properties (all but IE < 9).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.ownLast = props[0] != 'x';
                /**
                 * Detect if `arguments` object indexes are non-enumerable
                 * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.nonEnumArgs = prop != 0;
                /**
                 * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
                 *
                 * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
                 * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.nonEnumShadows = !/valueOf/.test(props);
                /**
                 * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
                 *
                 * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
                 * and `splice()` functions that fail to remove the last element, `value[0]`,
                 * of array-like objects even though the `length` property is set to `0`.
                 * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
                 * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
                /**
                 * Detect lack of support for accessing string characters by index.
                 *
                 * IE < 8 can't access characters by index and IE 8 can only access
                 * characters by index on string literals.
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                support.unindexedChars = 'x'[0] + Object('x')[0] != 'xx';
                /**
                 * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
                 * and that the JS engine errors when attempting to coerce an object to
                 * a string without a `toString` function.
                 *
                 * @memberOf _.support
                 * @type Boolean
                 */
                try {
                    support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
                } catch (e) {
                    support.nodeClass = true;
                }
            }(1));
            /**
             * By default, the template delimiters used by Lo-Dash are similar to those in
             * embedded Ruby (ERB). Change the following template settings to use alternative
             * delimiters.
             *
             * @static
             * @memberOf _
             * @type Object
             */
            lodash.templateSettings = {
                'escape': /<%-([\s\S]+?)%>/g,
                'evaluate': /<%([\s\S]+?)%>/g,
                'interpolate': reInterpolate,
                'variable': '',
                'imports': { '_': lodash }
            };
            /*--------------------------------------------------------------------------*/
            /**
             * The template used to create iterator functions.
             *
             * @private
             * @param {Object} data The data object used to populate the text.
             * @returns {String} Returns the interpolated text.
             */
            var iteratorTemplate = function (obj) {
                var __p = 'var index, iterable = ' + obj.firstArg + ', result = ' + obj.init + ';\nif (!iterable) return result;\n' + obj.top + ';';
                if (obj.array) {
                    __p += '\nvar length = iterable.length; index = -1;\nif (' + obj.array + ') {  ';
                    if (support.unindexedChars) {
                        __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
                    }
                    __p += '\n  while (++index < length) {\n    ' + obj.loop + ';\n  }\n}\nelse {  ';
                } else if (support.nonEnumArgs) {
                    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' + obj.loop + ';\n    }\n  } else {  ';
                }
                if (support.enumPrototypes) {
                    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
                }
                if (support.enumErrorProps) {
                    __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
                }
                var conditions = [];
                if (support.enumPrototypes) {
                    conditions.push('!(skipProto && index == "prototype")');
                }
                if (support.enumErrorProps) {
                    conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
                }
                if (obj.useHas && obj.useKeys) {
                    __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
                    if (conditions.length) {
                        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
                    }
                    __p += obj.loop + ';    ';
                    if (conditions.length) {
                        __p += '\n    }';
                    }
                    __p += '\n  }  ';
                } else {
                    __p += '\n  for (index in iterable) {\n';
                    if (obj.useHas) {
                        conditions.push('hasOwnProperty.call(iterable, index)');
                    }
                    if (conditions.length) {
                        __p += '    if (' + conditions.join(' && ') + ') {\n  ';
                    }
                    __p += obj.loop + ';    ';
                    if (conditions.length) {
                        __p += '\n    }';
                    }
                    __p += '\n  }    ';
                    if (support.nonEnumShadows) {
                        __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
                        for (k = 0; k < 7; k++) {
                            __p += '\n    index = \'' + obj.shadowedProps[k] + '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
                            if (!obj.useHas) {
                                __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
                            }
                            __p += ') {\n      ' + obj.loop + ';\n    }      ';
                        }
                        __p += '\n  }    ';
                    }
                }
                if (obj.array || support.nonEnumArgs) {
                    __p += '\n}';
                }
                __p += obj.bottom + ';\nreturn result';
                return __p;
            };
            /** Reusable iterator options for `assign` and `defaults` */
            var defaultsIteratorOptions = {
                    'args': 'object, source, guard',
                    'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + '    argsLength = typeof guard == \'number\' ? 2 : args.length;\n' + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
                    'loop': 'if (typeof result[index] == \'undefined\') result[index] = iterable[index]',
                    'bottom': '  }\n}'
                };
            /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
            var eachIteratorOptions = {
                    'args': 'collection, callback, thisArg',
                    'top': 'callback = callback && typeof thisArg == \'undefined\' ? callback : lodash.createCallback(callback, thisArg)',
                    'array': 'typeof length == \'number\'',
                    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
                };
            /** Reusable iterator options for `forIn` and `forOwn` */
            var forOwnIteratorOptions = {
                    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
                    'array': false
                };
            /*--------------------------------------------------------------------------*/
            /**
             * Creates a function that, when called, invokes `func` with the `this` binding
             * of `thisArg` and prepends any `partialArgs` to the arguments passed to the
             * bound function.
             *
             * @private
             * @param {Function|String} func The function to bind or the method name.
             * @param {Mixed} [thisArg] The `this` binding of `func`.
             * @param {Array} partialArgs An array of arguments to be partially applied.
             * @param {Object} [idicator] Used to indicate binding by key or partially
             *  applying arguments from the right.
             * @returns {Function} Returns the new bound function.
             */
            function createBound(func, thisArg, partialArgs, indicator) {
                var isFunc = isFunction(func), isPartial = !partialArgs, key = thisArg;
                // juggle arguments
                if (isPartial) {
                    var rightIndicator = indicator;
                    partialArgs = thisArg;
                } else if (!isFunc) {
                    if (!indicator) {
                        throw new TypeError();
                    }
                    thisArg = func;
                }
                function bound() {
                    // `Function#bind` spec
                    // http://es5.github.com/#x15.3.4.5
                    var args = arguments, thisBinding = isPartial ? this : thisArg;
                    if (!isFunc) {
                        func = thisArg[key];
                    }
                    if (partialArgs.length) {
                        args = args.length ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args)) : partialArgs;
                    }
                    if (this instanceof bound) {
                        // ensure `new bound` is an instance of `func`
                        thisBinding = createObject(func.prototype);
                        // mimic the constructor's `return` behavior
                        // http://es5.github.com/#x13.2.2
                        var result = func.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding;
                    }
                    return func.apply(thisBinding, args);
                }
                return bound;
            }
            /**
             * Creates compiled iteration functions.
             *
             * @private
             * @param {Object} [options1, options2, ...] The compile options object(s).
             *  array - A string of code to determine if the iterable is an array or array-like.
             *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.
             *  useKeys - A boolean to specify using `_.keys` for own property iteration.
             *  args - A string of comma separated arguments the iteration function will accept.
             *  top - A string of code to execute before the iteration branches.
             *  loop - A string of code to execute in the object loop.
             *  bottom - A string of code to execute after the iteration branches.
             * @returns {Function} Returns the compiled function.
             */
            function createIterator() {
                var data = getObject();
                // data properties
                data.shadowedProps = shadowedProps;
                // iterator options
                data.array = data.bottom = data.loop = data.top = '';
                data.init = 'iterable';
                data.useHas = true;
                data.useKeys = !!keys;
                // merge options into a template data object
                for (var object, index = 0; object = arguments[index]; index++) {
                    for (var key in object) {
                        data[key] = object[key];
                    }
                }
                var args = data.args;
                data.firstArg = /^[^,]+/.exec(args)[0];
                // create the function factory
                var factory = Function('errorClass, errorProto, hasOwnProperty, isArguments, isArray, ' + 'isString, keys, lodash, objectProto, objectTypes, nonEnumProps, ' + 'stringClass, stringProto, toString', 'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}');
                releaseObject(data);
                // return the compiled function
                return factory(errorClass, errorProto, hasOwnProperty, isArguments, isArray, isString, keys, lodash, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
            }
            /**
             * Creates a new object with the specified `prototype`.
             *
             * @private
             * @param {Object} prototype The prototype object.
             * @returns {Object} Returns the new object.
             */
            function createObject(prototype) {
                return isObject(prototype) ? nativeCreate(prototype) : {};
            }
            // fallback for browsers without `Object.create`
            if (!nativeCreate) {
                var createObject = function (prototype) {
                    if (isObject(prototype)) {
                        noop.prototype = prototype;
                        var result = new noop();
                        noop.prototype = null;
                    }
                    return result || {};
                };
            }
            /**
             * Used by `escape` to convert characters to HTML entities.
             *
             * @private
             * @param {String} match The matched character to escape.
             * @returns {String} Returns the escaped character.
             */
            function escapeHtmlChar(match) {
                return htmlEscapes[match];
            }
            /**
             * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
             * customized, this method returns the custom method, otherwise it returns
             * the `basicIndexOf` function.
             *
             * @private
             * @returns {Function} Returns the "indexOf" function.
             */
            function getIndexOf(array, value, fromIndex) {
                var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
                return result;
            }
            /**
             * Creates a function that juggles arguments, allowing argument overloading
             * for `_.flatten` and `_.uniq`, before passing them to the given `func`.
             *
             * @private
             * @param {Function} func The function to wrap.
             * @returns {Function} Returns the new function.
             */
            function overloadWrapper(func) {
                return function (array, flag, callback, thisArg) {
                    // juggle arguments
                    if (typeof flag != 'boolean' && flag != null) {
                        thisArg = callback;
                        callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
                        flag = false;
                    }
                    if (callback != null) {
                        callback = lodash.createCallback(callback, thisArg);
                    }
                    return func(array, flag, callback, thisArg);
                };
            }
            /**
             * A fallback implementation of `isPlainObject` which checks if a given `value`
             * is an object created by the `Object` constructor, assuming objects created
             * by the `Object` constructor have no inherited enumerable properties and that
             * there are no `Object.prototype` extensions.
             *
             * @private
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
             */
            function shimIsPlainObject(value) {
                var ctor, result;
                // avoid non Object objects, `arguments` objects, and DOM elements
                if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
                    return false;
                }
                // IE < 9 iterates inherited properties before own properties. If the first
                // iterated property is an object's own property then there are no inherited
                // enumerable properties.
                if (support.ownLast) {
                    forIn(value, function (value, key, object) {
                        result = hasOwnProperty.call(object, key);
                        return false;
                    });
                    return result !== false;
                }
                // In most environments an object's own properties are iterated before
                // its inherited properties. If the last iterated property is an object's
                // own property then there are no inherited enumerable properties.
                forIn(value, function (value, key) {
                    result = key;
                });
                return result === undefined || hasOwnProperty.call(value, result);
            }
            /**
             * Used by `unescape` to convert HTML entities to characters.
             *
             * @private
             * @param {String} match The matched character to unescape.
             * @returns {String} Returns the unescaped character.
             */
            function unescapeHtmlChar(match) {
                return htmlUnescapes[match];
            }
            /*--------------------------------------------------------------------------*/
            /**
             * Checks if `value` is an `arguments` object.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is an `arguments` object, else `false`.
             * @example
             *
             * (function() { return _.isArguments(arguments); })(1, 2, 3);
             * // => true
             *
             * _.isArguments([1, 2, 3]);
             * // => false
             */
            function isArguments(value) {
                return toString.call(value) == argsClass;
            }
            // fallback for browsers that can't detect `arguments` objects by [[Class]]
            if (!support.argsClass) {
                isArguments = function (value) {
                    return value ? hasOwnProperty.call(value, 'callee') : false;
                };
            }
            /**
             * Checks if `value` is an array.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is an array, else `false`.
             * @example
             *
             * (function() { return _.isArray(arguments); })();
             * // => false
             *
             * _.isArray([1, 2, 3]);
             * // => true
             */
            var isArray = nativeIsArray || function (value) {
                    return value ? typeof value == 'object' && toString.call(value) == arrayClass : false;
                };
            /**
             * A fallback implementation of `Object.keys` which produces an array of the
             * given object's own enumerable property names.
             *
             * @private
             * @type Function
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns a new array of property names.
             */
            var shimKeys = createIterator({
                    'args': 'object',
                    'init': '[]',
                    'top': 'if (!(objectTypes[typeof object])) return result',
                    'loop': 'result.push(index)'
                });
            /**
             * Creates an array composed of the own enumerable property names of `object`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns a new array of property names.
             * @example
             *
             * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
             * // => ['one', 'two', 'three'] (order is not guaranteed)
             */
            var keys = !nativeKeys ? shimKeys : function (object) {
                    if (!isObject(object)) {
                        return [];
                    }
                    if (support.enumPrototypes && typeof object == 'function' || support.nonEnumArgs && object.length && isArguments(object)) {
                        return shimKeys(object);
                    }
                    return nativeKeys(object);
                };
            /**
             * A function compiled to iterate `arguments` objects, arrays, objects, and
             * strings consistenly across environments, executing the `callback` for each
             * element in the `collection`. The `callback` is bound to `thisArg` and invoked
             * with three arguments; (value, index|key, collection). Callbacks may exit
             * iteration early by explicitly returning `false`.
             *
             * @private
             * @type Function
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array|Object|String} Returns `collection`.
             */
            var basicEach = createIterator(eachIteratorOptions);
            /**
             * Used to convert characters to HTML entities:
             *
             * Though the `>` character is escaped for symmetry, characters like `>` and `/`
             * don't require escaping in HTML and have no special meaning unless they're part
             * of a tag or an unquoted attribute value.
             * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
             */
            var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    '\'': '&#39;'
                };
            /** Used to convert HTML entities to characters */
            var htmlUnescapes = invert(htmlEscapes);
            /*--------------------------------------------------------------------------*/
            /**
             * Assigns own enumerable properties of source object(s) to the destination
             * object. Subsequent sources will overwrite property assignments of previous
             * sources. If a `callback` function is passed, it will be executed to produce
             * the assigned values. The `callback` is bound to `thisArg` and invoked with
             * two arguments; (objectValue, sourceValue).
             *
             * @static
             * @memberOf _
             * @type Function
             * @alias extend
             * @category Objects
             * @param {Object} object The destination object.
             * @param {Object} [source1, source2, ...] The source objects.
             * @param {Function} [callback] The function to customize assigning values.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns the destination object.
             * @example
             *
             * _.assign({ 'name': 'moe' }, { 'age': 40 });
             * // => { 'name': 'moe', 'age': 40 }
             *
             * var defaults = _.partialRight(_.assign, function(a, b) {
             *   return typeof a == 'undefined' ? b : a;
             * });
             *
             * var food = { 'name': 'apple' };
             * defaults(food, { 'name': 'banana', 'type': 'fruit' });
             * // => { 'name': 'apple', 'type': 'fruit' }
             */
            var assign = createIterator(defaultsIteratorOptions, {
                    'top': defaultsIteratorOptions.top.replace(';', ';\n' + 'if (argsLength > 3 && typeof args[argsLength - 2] == \'function\') {\n' + '  var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + '} else if (argsLength > 2 && typeof args[argsLength - 1] == \'function\') {\n' + '  callback = args[--argsLength];\n' + '}'),
                    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
                });
            /**
             * Creates a clone of `value`. If `deep` is `true`, nested objects will also
             * be cloned, otherwise they will be assigned by reference. If a `callback`
             * function is passed, it will be executed to produce the cloned values. If
             * `callback` returns `undefined`, cloning will be handled by the method instead.
             * The `callback` is bound to `thisArg` and invoked with one argument; (value).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to clone.
             * @param {Boolean} [deep=false] A flag to indicate a deep clone.
             * @param {Function} [callback] The function to customize cloning values.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @param- {Array} [stackA=[]] Tracks traversed source objects.
             * @param- {Array} [stackB=[]] Associates clones with source counterparts.
             * @returns {Mixed} Returns the cloned `value`.
             * @example
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * var shallow = _.clone(stooges);
             * shallow[0] === stooges[0];
             * // => true
             *
             * var deep = _.clone(stooges, true);
             * deep[0] === stooges[0];
             * // => false
             *
             * _.mixin({
             *   'clone': _.partialRight(_.clone, function(value) {
             *     return _.isElement(value) ? value.cloneNode(false) : undefined;
             *   })
             * });
             *
             * var clone = _.clone(document.body);
             * clone.childNodes.length;
             * // => 0
             */
            function clone(value, deep, callback, thisArg, stackA, stackB) {
                var result = value;
                // allows working with "Collections" methods without using their `callback`
                // argument, `index|key`, for this method's `callback`
                if (typeof deep != 'boolean' && deep != null) {
                    thisArg = callback;
                    callback = deep;
                    deep = false;
                }
                if (typeof callback == 'function') {
                    callback = typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg, 1);
                    result = callback(result);
                    if (typeof result != 'undefined') {
                        return result;
                    }
                    result = value;
                }
                // inspect [[Class]]
                var isObj = isObject(result);
                if (isObj) {
                    var className = toString.call(result);
                    if (!cloneableClasses[className] || !support.nodeClass && isNode(result)) {
                        return result;
                    }
                    var isArr = isArray(result);
                }
                // shallow clone
                if (!isObj || !deep) {
                    return isObj ? isArr ? slice(result) : assign({}, result) : result;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                case boolClass:
                case dateClass:
                    return new ctor(+result);
                case numberClass:
                case stringClass:
                    return new ctor(result);
                case regexpClass:
                    return ctor(result.source, reFlags.exec(result));
                }
                // check for circular references and return corresponding clone
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                // init cloned object
                result = isArr ? ctor(result.length) : {};
                // add array properties assigned by `RegExp#exec`
                if (isArr) {
                    if (hasOwnProperty.call(value, 'index')) {
                        result.index = value.index;
                    }
                    if (hasOwnProperty.call(value, 'input')) {
                        result.input = value.input;
                    }
                }
                // add the source value to the stack of traversed objects
                // and associate it with its clone
                stackA.push(value);
                stackB.push(result);
                // recursively populate clone (susceptible to call stack limits)
                (isArr ? basicEach : forOwn)(value, function (objValue, key) {
                    result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
                });
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return result;
            }
            /**
             * Creates a deep clone of `value`. If a `callback` function is passed,
             * it will be executed to produce the cloned values. If `callback` returns
             * `undefined`, cloning will be handled by the method instead. The `callback`
             * is bound to `thisArg` and invoked with one argument; (value).
             *
             * Note: This method is loosely based on the structured clone algorithm. Functions
             * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
             * objects created by constructors other than `Object` are cloned to plain `Object` objects.
             * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to deep clone.
             * @param {Function} [callback] The function to customize cloning values.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the deep cloned `value`.
             * @example
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * var deep = _.cloneDeep(stooges);
             * deep[0] === stooges[0];
             * // => false
             *
             * var view = {
             *   'label': 'docs',
             *   'node': element
             * };
             *
             * var clone = _.cloneDeep(view, function(value) {
             *   return _.isElement(value) ? value.cloneNode(true) : undefined;
             * });
             *
             * clone.node == view.node;
             * // => false
             */
            function cloneDeep(value, callback, thisArg) {
                return clone(value, true, callback, thisArg);
            }
            /**
             * Assigns own enumerable properties of source object(s) to the destination
             * object for all destination properties that resolve to `undefined`. Once a
             * property is set, additional defaults of the same property will be ignored.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Objects
             * @param {Object} object The destination object.
             * @param {Object} [source1, source2, ...] The source objects.
             * @param- {Object} [guard] Allows working with `_.reduce` without using its
             *  callback's `key` and `object` arguments as sources.
             * @returns {Object} Returns the destination object.
             * @example
             *
             * var food = { 'name': 'apple' };
             * _.defaults(food, { 'name': 'banana', 'type': 'fruit' });
             * // => { 'name': 'apple', 'type': 'fruit' }
             */
            var defaults = createIterator(defaultsIteratorOptions);
            /**
             * This method is similar to `_.find`, except that it returns the key of the
             * element that passes the callback check, instead of the element itself.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to search.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the key of the found element, else `undefined`.
             * @example
             *
             * _.findKey({ 'a': 1, 'b': 2, 'c': 3, 'd': 4 }, function(num) {
             *   return num % 2 == 0;
             * });
             * // => 'b'
             */
            function findKey(object, callback, thisArg) {
                var result;
                callback = lodash.createCallback(callback, thisArg);
                forOwn(object, function (value, key, object) {
                    if (callback(value, key, object)) {
                        result = key;
                        return false;
                    }
                });
                return result;
            }
            /**
             * Iterates over `object`'s own and inherited enumerable properties, executing
             * the `callback` for each property. The `callback` is bound to `thisArg` and
             * invoked with three arguments; (value, key, object). Callbacks may exit iteration
             * early by explicitly returning `false`.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Objects
             * @param {Object} object The object to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns `object`.
             * @example
             *
             * function Dog(name) {
             *   this.name = name;
             * }
             *
             * Dog.prototype.bark = function() {
             *   alert('Woof, woof!');
             * };
             *
             * _.forIn(new Dog('Dagny'), function(value, key) {
             *   alert(key);
             * });
             * // => alerts 'name' and 'bark' (order is not guaranteed)
             */
            var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, { 'useHas': false });
            /**
             * Iterates over an object's own enumerable properties, executing the `callback`
             * for each property. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
             * returning `false`.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Objects
             * @param {Object} object The object to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns `object`.
             * @example
             *
             * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
             *   alert(key);
             * });
             * // => alerts '0', '1', and 'length' (order is not guaranteed)
             */
            var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
            /**
             * Creates a sorted array of all enumerable properties, own and inherited,
             * of `object` that have function values.
             *
             * @static
             * @memberOf _
             * @alias methods
             * @category Objects
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns a new array of property names that have function values.
             * @example
             *
             * _.functions(_);
             * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
             */
            function functions(object) {
                var result = [];
                forIn(object, function (value, key) {
                    if (isFunction(value)) {
                        result.push(key);
                    }
                });
                return result.sort();
            }
            /**
             * Checks if the specified object `property` exists and is a direct property,
             * instead of an inherited property.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to check.
             * @param {String} property The property to check for.
             * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
             * @example
             *
             * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
             * // => true
             */
            function has(object, property) {
                return object ? hasOwnProperty.call(object, property) : false;
            }
            /**
             * Creates an object composed of the inverted keys and values of the given `object`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to invert.
             * @returns {Object} Returns the created inverted object.
             * @example
             *
             *  _.invert({ 'first': 'moe', 'second': 'larry' });
             * // => { 'moe': 'first', 'larry': 'second' }
             */
            function invert(object) {
                var index = -1, props = keys(object), length = props.length, result = {};
                while (++index < length) {
                    var key = props[index];
                    result[object[key]] = key;
                }
                return result;
            }
            /**
             * Checks if `value` is a boolean value.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a boolean value, else `false`.
             * @example
             *
             * _.isBoolean(null);
             * // => false
             */
            function isBoolean(value) {
                return value === true || value === false || toString.call(value) == boolClass;
            }
            /**
             * Checks if `value` is a date.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a date, else `false`.
             * @example
             *
             * _.isDate(new Date);
             * // => true
             */
            function isDate(value) {
                return value ? typeof value == 'object' && toString.call(value) == dateClass : false;
            }
            /**
             * Checks if `value` is a DOM element.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a DOM element, else `false`.
             * @example
             *
             * _.isElement(document.body);
             * // => true
             */
            function isElement(value) {
                return value ? value.nodeType === 1 : false;
            }
            /**
             * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
             * length of `0` and objects with no own enumerable properties are considered
             * "empty".
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Array|Object|String} value The value to inspect.
             * @returns {Boolean} Returns `true`, if the `value` is empty, else `false`.
             * @example
             *
             * _.isEmpty([1, 2, 3]);
             * // => false
             *
             * _.isEmpty({});
             * // => true
             *
             * _.isEmpty('');
             * // => true
             */
            function isEmpty(value) {
                var result = true;
                if (!value) {
                    return result;
                }
                var className = toString.call(value), length = value.length;
                if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
                    return !length;
                }
                forOwn(value, function () {
                    return result = false;
                });
                return result;
            }
            /**
             * Performs a deep comparison between two values to determine if they are
             * equivalent to each other. If `callback` is passed, it will be executed to
             * compare values. If `callback` returns `undefined`, comparisons will be handled
             * by the method instead. The `callback` is bound to `thisArg` and invoked with
             * two arguments; (a, b).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} a The value to compare.
             * @param {Mixed} b The other value to compare.
             * @param {Function} [callback] The function to customize comparing values.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @param- {Array} [stackA=[]] Tracks traversed `a` objects.
             * @param- {Array} [stackB=[]] Tracks traversed `b` objects.
             * @returns {Boolean} Returns `true`, if the values are equivalent, else `false`.
             * @example
             *
             * var moe = { 'name': 'moe', 'age': 40 };
             * var copy = { 'name': 'moe', 'age': 40 };
             *
             * moe == copy;
             * // => false
             *
             * _.isEqual(moe, copy);
             * // => true
             *
             * var words = ['hello', 'goodbye'];
             * var otherWords = ['hi', 'goodbye'];
             *
             * _.isEqual(words, otherWords, function(a, b) {
             *   var reGreet = /^(?:hello|hi)$/i,
             *       aGreet = _.isString(a) && reGreet.test(a),
             *       bGreet = _.isString(b) && reGreet.test(b);
             *
             *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
             * });
             * // => true
             */
            function isEqual(a, b, callback, thisArg, stackA, stackB) {
                // used to indicate that when comparing objects, `a` has at least the properties of `b`
                var whereIndicator = callback === indicatorObject;
                if (typeof callback == 'function' && !whereIndicator) {
                    callback = lodash.createCallback(callback, thisArg, 2);
                    var result = callback(a, b);
                    if (typeof result != 'undefined') {
                        return !!result;
                    }
                }
                // exit early for identical values
                if (a === b) {
                    // treat `+0` vs. `-0` as not equal
                    return a !== 0 || 1 / a == 1 / b;
                }
                var type = typeof a, otherType = typeof b;
                // exit early for unlike primitive values
                if (a === a && (!a || type != 'function' && type != 'object') && (!b || otherType != 'function' && otherType != 'object')) {
                    return false;
                }
                // exit early for `null` and `undefined`, avoiding ES3's Function#call behavior
                // http://es5.github.com/#x15.3.4.4
                if (a == null || b == null) {
                    return a === b;
                }
                // compare [[Class]] names
                var className = toString.call(a), otherClass = toString.call(b);
                if (className == argsClass) {
                    className = objectClass;
                }
                if (otherClass == argsClass) {
                    otherClass = objectClass;
                }
                if (className != otherClass) {
                    return false;
                }
                switch (className) {
                case boolClass:
                case dateClass:
                    // coerce dates and booleans to numbers, dates to milliseconds and booleans
                    // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
                    return +a == +b;
                case numberClass:
                    // treat `NaN` vs. `NaN` as equal
                    return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
                case regexpClass:
                case stringClass:
                    // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
                    // treat string primitives and their corresponding object instances as equal
                    return a == String(b);
                }
                var isArr = className == arrayClass;
                if (!isArr) {
                    // unwrap any `lodash` wrapped values
                    if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
                        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
                    }
                    // exit for functions and DOM nodes
                    if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
                        return false;
                    }
                    // in older versions of Opera, `arguments` objects have `Array` constructors
                    var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
                    // non `Object` object instances with different constructors are not equal
                    if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) {
                        return false;
                    }
                }
                // assume cyclic structures are equal
                // the algorithm for detecting cyclic structures is adapted from ES 5.1
                // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == a) {
                        return stackB[length] == b;
                    }
                }
                var size = 0;
                result = true;
                // add `a` and `b` to the stack of traversed objects
                stackA.push(a);
                stackB.push(b);
                // recursively compare objects and arrays (susceptible to call stack limits)
                if (isArr) {
                    length = a.length;
                    size = b.length;
                    // compare lengths to determine if a deep comparison is necessary
                    result = size == a.length;
                    if (!result && !whereIndicator) {
                        return result;
                    }
                    // deep compare the contents, ignoring non-numeric properties
                    while (size--) {
                        var index = length, value = b[size];
                        if (whereIndicator) {
                            while (index--) {
                                if (result = isEqual(a[index], value, callback, thisArg, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
                            break;
                        }
                    }
                    return result;
                }
                // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
                // which, in this case, is more costly
                forIn(b, function (value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        // count the number of properties.
                        size++;
                        // deep compare each property value.
                        return result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB);
                    }
                });
                if (result && !whereIndicator) {
                    // ensure both objects have the same number of properties
                    forIn(a, function (value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            // `size` will be `-1` if `a` has more properties than `b`
                            return result = --size > -1;
                        }
                    });
                }
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return result;
            }
            /**
             * Checks if `value` is, or can be coerced to, a finite number.
             *
             * Note: This is not the same as native `isFinite`, which will return true for
             * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is finite, else `false`.
             * @example
             *
             * _.isFinite(-101);
             * // => true
             *
             * _.isFinite('10');
             * // => true
             *
             * _.isFinite(true);
             * // => false
             *
             * _.isFinite('');
             * // => false
             *
             * _.isFinite(Infinity);
             * // => false
             */
            function isFinite(value) {
                return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
            }
            /**
             * Checks if `value` is a function.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a function, else `false`.
             * @example
             *
             * _.isFunction(_);
             * // => true
             */
            function isFunction(value) {
                return typeof value == 'function';
            }
            // fallback for older versions of Chrome and Safari
            if (isFunction(/x/)) {
                isFunction = function (value) {
                    return typeof value == 'function' && toString.call(value) == funcClass;
                };
            }
            /**
             * Checks if `value` is the language type of Object.
             * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(1);
             * // => false
             */
            function isObject(value) {
                // check if the value is the ECMAScript language type of Object
                // http://es5.github.com/#x8
                // and avoid a V8 bug
                // http://code.google.com/p/v8/issues/detail?id=2291
                return !!(value && objectTypes[typeof value]);
            }
            /**
             * Checks if `value` is `NaN`.
             *
             * Note: This is not the same as native `isNaN`, which will return `true` for
             * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is `NaN`, else `false`.
             * @example
             *
             * _.isNaN(NaN);
             * // => true
             *
             * _.isNaN(new Number(NaN));
             * // => true
             *
             * isNaN(undefined);
             * // => true
             *
             * _.isNaN(undefined);
             * // => false
             */
            function isNaN(value) {
                // `NaN` as a primitive is the only value that is not equal to itself
                // (perform the [[Class]] check first to avoid errors with some host objects in IE)
                return isNumber(value) && value != +value;
            }
            /**
             * Checks if `value` is `null`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is `null`, else `false`.
             * @example
             *
             * _.isNull(null);
             * // => true
             *
             * _.isNull(undefined);
             * // => false
             */
            function isNull(value) {
                return value === null;
            }
            /**
             * Checks if `value` is a number.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a number, else `false`.
             * @example
             *
             * _.isNumber(8.4 * 5);
             * // => true
             */
            function isNumber(value) {
                return typeof value == 'number' || toString.call(value) == numberClass;
            }
            /**
             * Checks if a given `value` is an object created by the `Object` constructor.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
             * @example
             *
             * function Stooge(name, age) {
             *   this.name = name;
             *   this.age = age;
             * }
             *
             * _.isPlainObject(new Stooge('moe', 40));
             * // => false
             *
             * _.isPlainObject([1, 2, 3]);
             * // => false
             *
             * _.isPlainObject({ 'name': 'moe', 'age': 40 });
             * // => true
             */
            var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
                    if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
                        return false;
                    }
                    var valueOf = value.valueOf, objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                    return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                };
            /**
             * Checks if `value` is a regular expression.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a regular expression, else `false`.
             * @example
             *
             * _.isRegExp(/moe/);
             * // => true
             */
            function isRegExp(value) {
                return !!(value && objectTypes[typeof value]) && toString.call(value) == regexpClass;
            }
            /**
             * Checks if `value` is a string.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is a string, else `false`.
             * @example
             *
             * _.isString('moe');
             * // => true
             */
            function isString(value) {
                return typeof value == 'string' || toString.call(value) == stringClass;
            }
            /**
             * Checks if `value` is `undefined`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Mixed} value The value to check.
             * @returns {Boolean} Returns `true`, if the `value` is `undefined`, else `false`.
             * @example
             *
             * _.isUndefined(void 0);
             * // => true
             */
            function isUndefined(value) {
                return typeof value == 'undefined';
            }
            /**
             * Recursively merges own enumerable properties of the source object(s), that
             * don't resolve to `undefined`, into the destination object. Subsequent sources
             * will overwrite property assignments of previous sources. If a `callback` function
             * is passed, it will be executed to produce the merged values of the destination
             * and source properties. If `callback` returns `undefined`, merging will be
             * handled by the method instead. The `callback` is bound to `thisArg` and
             * invoked with two arguments; (objectValue, sourceValue).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The destination object.
             * @param {Object} [source1, source2, ...] The source objects.
             * @param {Function} [callback] The function to customize merging properties.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @param- {Object} [deepIndicator] Indicates that `stackA` and `stackB` are
             *  arrays of traversed objects, instead of source objects.
             * @param- {Array} [stackA=[]] Tracks traversed source objects.
             * @param- {Array} [stackB=[]] Associates values with source counterparts.
             * @returns {Object} Returns the destination object.
             * @example
             *
             * var names = {
             *   'stooges': [
             *     { 'name': 'moe' },
             *     { 'name': 'larry' }
             *   ]
             * };
             *
             * var ages = {
             *   'stooges': [
             *     { 'age': 40 },
             *     { 'age': 50 }
             *   ]
             * };
             *
             * _.merge(names, ages);
             * // => { 'stooges': [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }] }
             *
             * var food = {
             *   'fruits': ['apple'],
             *   'vegetables': ['beet']
             * };
             *
             * var otherFood = {
             *   'fruits': ['banana'],
             *   'vegetables': ['carrot']
             * };
             *
             * _.merge(food, otherFood, function(a, b) {
             *   return _.isArray(a) ? a.concat(b) : undefined;
             * });
             * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
             */
            function merge(object, source, deepIndicator) {
                var args = arguments, index = 0, length = 2;
                if (!isObject(object)) {
                    return object;
                }
                if (deepIndicator === indicatorObject) {
                    var callback = args[3], stackA = args[4], stackB = args[5];
                } else {
                    var initedStack = true;
                    stackA = getArray();
                    stackB = getArray();
                    // allows working with `_.reduce` and `_.reduceRight` without
                    // using their `callback` arguments, `index|key` and `collection`
                    if (typeof deepIndicator != 'number') {
                        length = args.length;
                    }
                    if (length > 3 && typeof args[length - 2] == 'function') {
                        callback = lodash.createCallback(args[--length - 1], args[length--], 2);
                    } else if (length > 2 && typeof args[length - 1] == 'function') {
                        callback = args[--length];
                    }
                }
                while (++index < length) {
                    (isArray(args[index]) ? forEach : forOwn)(args[index], function (source, key) {
                        var found, isArr, result = source, value = object[key];
                        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                            // avoid merging previously merged cyclic sources
                            var stackLength = stackA.length;
                            while (stackLength--) {
                                if (found = stackA[stackLength] == source) {
                                    value = stackB[stackLength];
                                    break;
                                }
                            }
                            if (!found) {
                                var isShallow;
                                if (callback) {
                                    result = callback(value, source);
                                    if (isShallow = typeof result != 'undefined') {
                                        value = result;
                                    }
                                }
                                if (!isShallow) {
                                    value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                }
                                // add `source` and associated `value` to the stack of traversed objects
                                stackA.push(source);
                                stackB.push(value);
                                // recursively merge objects and arrays (susceptible to call stack limits)
                                if (!isShallow) {
                                    value = merge(value, source, indicatorObject, callback, stackA, stackB);
                                }
                            }
                        } else {
                            if (callback) {
                                result = callback(value, source);
                                if (typeof result == 'undefined') {
                                    result = source;
                                }
                            }
                            if (typeof result != 'undefined') {
                                value = result;
                            }
                        }
                        object[key] = value;
                    });
                }
                if (initedStack) {
                    releaseArray(stackA);
                    releaseArray(stackB);
                }
                return object;
            }
            /**
             * Creates a shallow clone of `object` excluding the specified properties.
             * Property names may be specified as individual arguments or as arrays of
             * property names. If a `callback` function is passed, it will be executed
             * for each property in the `object`, omitting the properties `callback`
             * returns truthy for. The `callback` is bound to `thisArg` and invoked
             * with three arguments; (value, key, object).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The source object.
             * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
             *  or the function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns an object without the omitted properties.
             * @example
             *
             * _.omit({ 'name': 'moe', 'age': 40 }, 'age');
             * // => { 'name': 'moe' }
             *
             * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {
             *   return typeof value == 'number';
             * });
             * // => { 'name': 'moe' }
             */
            function omit(object, callback, thisArg) {
                var indexOf = getIndexOf(), isFunc = typeof callback == 'function', result = {};
                if (isFunc) {
                    callback = lodash.createCallback(callback, thisArg);
                } else {
                    var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
                }
                forIn(object, function (value, key, object) {
                    if (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) {
                        result[key] = value;
                    }
                });
                return result;
            }
            /**
             * Creates a two dimensional array of the given object's key-value pairs,
             * i.e. `[[key1, value1], [key2, value2]]`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns new array of key-value pairs.
             * @example
             *
             * _.pairs({ 'moe': 30, 'larry': 40 });
             * // => [['moe', 30], ['larry', 40]] (order is not guaranteed)
             */
            function pairs(object) {
                var index = -1, props = keys(object), length = props.length, result = Array(length);
                while (++index < length) {
                    var key = props[index];
                    result[index] = [
                        key,
                        object[key]
                    ];
                }
                return result;
            }
            /**
             * Creates a shallow clone of `object` composed of the specified properties.
             * Property names may be specified as individual arguments or as arrays of property
             * names. If `callback` is passed, it will be executed for each property in the
             * `object`, picking the properties `callback` returns truthy for. The `callback`
             * is bound to `thisArg` and invoked with three arguments; (value, key, object).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The source object.
             * @param {Array|Function|String} callback|[prop1, prop2, ...] The function called
             *  per iteration or properties to pick, either as individual arguments or arrays.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns an object composed of the picked properties.
             * @example
             *
             * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');
             * // => { 'name': 'moe' }
             *
             * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {
             *   return key.charAt(0) != '_';
             * });
             * // => { 'name': 'moe' }
             */
            function pick(object, callback, thisArg) {
                var result = {};
                if (typeof callback != 'function') {
                    var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = isObject(object) ? props.length : 0;
                    while (++index < length) {
                        var key = props[index];
                        if (key in object) {
                            result[key] = object[key];
                        }
                    }
                } else {
                    callback = lodash.createCallback(callback, thisArg);
                    forIn(object, function (value, key, object) {
                        if (callback(value, key, object)) {
                            result[key] = value;
                        }
                    });
                }
                return result;
            }
            /**
             * An alternative to `_.reduce`, this method transforms an `object` to a new
             * `accumulator` object which is the result of running each of its elements
             * through the `callback`, with each `callback` execution potentially mutating
             * the `accumulator` object. The `callback` is bound to `thisArg` and invoked
             * with four arguments; (accumulator, value, key, object). Callbacks may exit
             * iteration early by explicitly returning `false`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Array|Object} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [accumulator] The custom accumulator value.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the accumulated value.
             * @example
             *
             * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
             *   num *= num;
             *   if (num % 2) {
             *     return result.push(num) < 3;
             *   }
             * });
             * // => [1, 9, 25]
             *
             * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
             *   result[key] = num * 3;
             * });
             * // => { 'a': 3, 'b': 6, 'c': 9 }
             */
            function transform(object, callback, accumulator, thisArg) {
                var isArr = isArray(object);
                callback = lodash.createCallback(callback, thisArg, 4);
                if (accumulator == null) {
                    if (isArr) {
                        accumulator = [];
                    } else {
                        var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                        accumulator = createObject(proto);
                    }
                }
                (isArr ? basicEach : forOwn)(object, function (value, index, object) {
                    return callback(accumulator, value, index, object);
                });
                return accumulator;
            }
            /**
             * Creates an array composed of the own enumerable property values of `object`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns a new array of property values.
             * @example
             *
             * _.values({ 'one': 1, 'two': 2, 'three': 3 });
             * // => [1, 2, 3] (order is not guaranteed)
             */
            function values(object) {
                var index = -1, props = keys(object), length = props.length, result = Array(length);
                while (++index < length) {
                    result[index] = object[props[index]];
                }
                return result;
            }
            /*--------------------------------------------------------------------------*/
            /**
             * Creates an array of elements from the specified indexes, or keys, of the
             * `collection`. Indexes may be specified as individual arguments or as arrays
             * of indexes.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Array|Number|String} [index1, index2, ...] The indexes of
             *  `collection` to retrieve, either as individual arguments or arrays.
             * @returns {Array} Returns a new array of elements corresponding to the
             *  provided indexes.
             * @example
             *
             * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
             * // => ['a', 'c', 'e']
             *
             * _.at(['moe', 'larry', 'curly'], 0, 2);
             * // => ['moe', 'curly']
             */
            function at(collection) {
                var index = -1, props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), length = props.length, result = Array(length);
                if (support.unindexedChars && isString(collection)) {
                    collection = collection.split('');
                }
                while (++index < length) {
                    result[index] = collection[props[index]];
                }
                return result;
            }
            /**
             * Checks if a given `target` element is present in a `collection` using strict
             * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
             * as the offset from the end of the collection.
             *
             * @static
             * @memberOf _
             * @alias include
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Mixed} target The value to check for.
             * @param {Number} [fromIndex=0] The index to search from.
             * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
             * @example
             *
             * _.contains([1, 2, 3], 1);
             * // => true
             *
             * _.contains([1, 2, 3], 1, 2);
             * // => false
             *
             * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
             * // => true
             *
             * _.contains('curly', 'ur');
             * // => true
             */
            function contains(collection, target, fromIndex) {
                var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                if (length && typeof length == 'number') {
                    result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                } else {
                    basicEach(collection, function (value) {
                        if (++index >= fromIndex) {
                            return !(result = value === target);
                        }
                    });
                }
                return result;
            }
            /**
             * Creates an object composed of keys returned from running each element of the
             * `collection` through the given `callback`. The corresponding value of each key
             * is the number of times the key was returned by the `callback`. The `callback`
             * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns the composed aggregate object.
             * @example
             *
             * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
             * // => { '4': 1, '6': 2 }
             *
             * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
             * // => { '4': 1, '6': 2 }
             *
             * _.countBy(['one', 'two', 'three'], 'length');
             * // => { '3': 2, '5': 1 }
             */
            function countBy(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    key = String(callback(value, key, collection));
                    hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                });
                return result;
            }
            /**
             * Checks if the `callback` returns a truthy value for **all** elements of a
             * `collection`. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias all
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Boolean} Returns `true` if all elements pass the callback check,
             *  else `false`.
             * @example
             *
             * _.every([true, 1, null, 'yes'], Boolean);
             * // => false
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.every(stooges, 'age');
             * // => true
             *
             * // using "_.where" callback shorthand
             * _.every(stooges, { 'age': 50 });
             * // => false
             */
            function every(collection, callback, thisArg) {
                var result = true;
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (!(result = !!callback(collection[index], index, collection))) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        return result = !!callback(value, index, collection);
                    });
                }
                return result;
            }
            /**
             * Examines each element in a `collection`, returning an array of all elements
             * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
             * invoked with three arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias select
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new array of elements that passed the callback check.
             * @example
             *
             * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
             * // => [2, 4, 6]
             *
             * var food = [
             *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
             *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.filter(food, 'organic');
             * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
             *
             * // using "_.where" callback shorthand
             * _.filter(food, { 'type': 'fruit' });
             * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
             */
            function filter(collection, callback, thisArg) {
                var result = [];
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (callback(value, index, collection)) {
                            result.push(value);
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        if (callback(value, index, collection)) {
                            result.push(value);
                        }
                    });
                }
                return result;
            }
            /**
             * Examines each element in a `collection`, returning the first that the `callback`
             * returns truthy for. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias detect, findWhere
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the found element, else `undefined`.
             * @example
             *
             * _.find([1, 2, 3, 4], function(num) {
             *   return num % 2 == 0;
             * });
             * // => 2
             *
             * var food = [
             *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
             *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
             *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
             * ];
             *
             * // using "_.where" callback shorthand
             * _.find(food, { 'type': 'vegetable' });
             * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
             *
             * // using "_.pluck" callback shorthand
             * _.find(food, 'organic');
             * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }
             */
            function find(collection, callback, thisArg) {
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (callback(value, index, collection)) {
                            return value;
                        }
                    }
                } else {
                    var result;
                    basicEach(collection, function (value, index, collection) {
                        if (callback(value, index, collection)) {
                            result = value;
                            return false;
                        }
                    });
                    return result;
                }
            }
            /**
             * Iterates over a `collection`, executing the `callback` for each element in
             * the `collection`. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index|key, collection). Callbacks may exit iteration early
             * by explicitly returning `false`.
             *
             * @static
             * @memberOf _
             * @alias each
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array|Object|String} Returns `collection`.
             * @example
             *
             * _([1, 2, 3]).forEach(alert).join(',');
             * // => alerts each number and returns '1,2,3'
             *
             * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
             * // => alerts each number value (order is not guaranteed)
             */
            function forEach(collection, callback, thisArg) {
                if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (callback(collection[index], index, collection) === false) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, callback, thisArg);
                }
                return collection;
            }
            /**
             * Creates an object composed of keys returned from running each element of the
             * `collection` through the `callback`. The corresponding value of each key is
             * an array of elements passed to `callback` that returned the key. The `callback`
             * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns the composed aggregate object.
             * @example
             *
             * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
             * // => { '4': [4.2], '6': [6.1, 6.4] }
             *
             * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
             * // => { '4': [4.2], '6': [6.1, 6.4] }
             *
             * // using "_.pluck" callback shorthand
             * _.groupBy(['one', 'two', 'three'], 'length');
             * // => { '3': ['one', 'two'], '5': ['three'] }
             */
            function groupBy(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    key = String(callback(value, key, collection));
                    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                });
                return result;
            }
            /**
             * Invokes the method named by `methodName` on each element in the `collection`,
             * returning an array of the results of each invoked method. Additional arguments
             * will be passed to each invoked method. If `methodName` is a function, it will
             * be invoked for, and `this` bound to, each element in the `collection`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|String} methodName The name of the method to invoke or
             *  the function invoked per iteration.
             * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
             * @returns {Array} Returns a new array of the results of each invoked method.
             * @example
             *
             * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
             * // => [[1, 5, 7], [1, 2, 3]]
             *
             * _.invoke([123, 456], String.prototype.split, '');
             * // => [['1', '2', '3'], ['4', '5', '6']]
             */
            function invoke(collection, methodName) {
                var args = nativeSlice.call(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                forEach(collection, function (value) {
                    result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                });
                return result;
            }
            /**
             * Creates an array of values by running each element in the `collection`
             * through the `callback`. The `callback` is bound to `thisArg` and invoked with
             * three arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias collect
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new array of the results of each `callback` execution.
             * @example
             *
             * _.map([1, 2, 3], function(num) { return num * 3; });
             * // => [3, 6, 9]
             *
             * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
             * // => [3, 6, 9] (order is not guaranteed)
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.map(stooges, 'name');
             * // => ['moe', 'larry']
             */
            function map(collection, callback, thisArg) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    while (++index < length) {
                        result[index] = callback(collection[index], index, collection);
                    }
                } else {
                    basicEach(collection, function (value, key, collection) {
                        result[++index] = callback(value, key, collection);
                    });
                }
                return result;
            }
            /**
             * Retrieves the maximum value of an `array`. If `callback` is passed,
             * it will be executed for each value in the `array` to generate the
             * criterion by which the value is ranked. The `callback` is bound to
             * `thisArg` and invoked with three arguments; (value, index, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the maximum value.
             * @example
             *
             * _.max([4, 2, 8, 6]);
             * // => 8
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * _.max(stooges, function(stooge) { return stooge.age; });
             * // => { 'name': 'larry', 'age': 50 };
             *
             * // using "_.pluck" callback shorthand
             * _.max(stooges, 'age');
             * // => { 'name': 'larry', 'age': 50 };
             */
            function max(collection, callback, thisArg) {
                var computed = -Infinity, result = computed;
                if (!callback && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (value > result) {
                            result = value;
                        }
                    }
                } else {
                    callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
                    basicEach(collection, function (value, index, collection) {
                        var current = callback(value, index, collection);
                        if (current > computed) {
                            computed = current;
                            result = value;
                        }
                    });
                }
                return result;
            }
            /**
             * Retrieves the minimum value of an `array`. If `callback` is passed,
             * it will be executed for each value in the `array` to generate the
             * criterion by which the value is ranked. The `callback` is bound to `thisArg`
             * and invoked with three arguments; (value, index, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the minimum value.
             * @example
             *
             * _.min([4, 2, 8, 6]);
             * // => 2
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * _.min(stooges, function(stooge) { return stooge.age; });
             * // => { 'name': 'moe', 'age': 40 };
             *
             * // using "_.pluck" callback shorthand
             * _.min(stooges, 'age');
             * // => { 'name': 'moe', 'age': 40 };
             */
            function min(collection, callback, thisArg) {
                var computed = Infinity, result = computed;
                if (!callback && isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        if (value < result) {
                            result = value;
                        }
                    }
                } else {
                    callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg);
                    basicEach(collection, function (value, index, collection) {
                        var current = callback(value, index, collection);
                        if (current < computed) {
                            computed = current;
                            result = value;
                        }
                    });
                }
                return result;
            }
            /**
             * Retrieves the value of a specified property from all elements in the `collection`.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {String} property The property to pluck.
             * @returns {Array} Returns a new array of property values.
             * @example
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * _.pluck(stooges, 'name');
             * // => ['moe', 'larry']
             */
            var pluck = map;
            /**
             * Reduces a `collection` to a value which is the accumulated result of running
             * each element in the `collection` through the `callback`, where each successive
             * `callback` execution consumes the return value of the previous execution.
             * If `accumulator` is not passed, the first element of the `collection` will be
             * used as the initial `accumulator` value. The `callback` is bound to `thisArg`
             * and invoked with four arguments; (accumulator, value, index|key, collection).
             *
             * @static
             * @memberOf _
             * @alias foldl, inject
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [accumulator] Initial value of the accumulator.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the accumulated value.
             * @example
             *
             * var sum = _.reduce([1, 2, 3], function(sum, num) {
             *   return sum + num;
             * });
             * // => 6
             *
             * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
             *   result[key] = num * 3;
             *   return result;
             * }, {});
             * // => { 'a': 3, 'b': 6, 'c': 9 }
             */
            function reduce(collection, callback, accumulator, thisArg) {
                var noaccum = arguments.length < 3;
                callback = lodash.createCallback(callback, thisArg, 4);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    if (noaccum) {
                        accumulator = collection[++index];
                    }
                    while (++index < length) {
                        accumulator = callback(accumulator, collection[index], index, collection);
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                    });
                }
                return accumulator;
            }
            /**
             * This method is similar to `_.reduce`, except that it iterates over a
             * `collection` from right to left.
             *
             * @static
             * @memberOf _
             * @alias foldr
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {Mixed} [accumulator] Initial value of the accumulator.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the accumulated value.
             * @example
             *
             * var list = [[0, 1], [2, 3], [4, 5]];
             * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
             * // => [4, 5, 2, 3, 0, 1]
             */
            function reduceRight(collection, callback, accumulator, thisArg) {
                var iterable = collection, length = collection ? collection.length : 0, noaccum = arguments.length < 3;
                if (typeof length != 'number') {
                    var props = keys(collection);
                    length = props.length;
                } else if (support.unindexedChars && isString(collection)) {
                    iterable = collection.split('');
                }
                callback = lodash.createCallback(callback, thisArg, 4);
                forEach(collection, function (value, index, collection) {
                    index = props ? props[--length] : --length;
                    accumulator = noaccum ? (noaccum = false, iterable[index]) : callback(accumulator, iterable[index], index, collection);
                });
                return accumulator;
            }
            /**
             * The opposite of `_.filter`, this method returns the elements of a
             * `collection` that `callback` does **not** return truthy for.
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new array of elements that did **not** pass the
             *  callback check.
             * @example
             *
             * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
             * // => [1, 3, 5]
             *
             * var food = [
             *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
             *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.reject(food, 'organic');
             * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
             *
             * // using "_.where" callback shorthand
             * _.reject(food, { 'type': 'fruit' });
             * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
             */
            function reject(collection, callback, thisArg) {
                callback = lodash.createCallback(callback, thisArg);
                return filter(collection, function (value, index, collection) {
                    return !callback(value, index, collection);
                });
            }
            /**
             * Creates an array of shuffled `array` values, using a version of the
             * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to shuffle.
             * @returns {Array} Returns a new shuffled collection.
             * @example
             *
             * _.shuffle([1, 2, 3, 4, 5, 6]);
             * // => [4, 1, 6, 3, 5, 2]
             */
            function shuffle(collection) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                forEach(collection, function (value) {
                    var rand = floor(nativeRandom() * (++index + 1));
                    result[index] = result[rand];
                    result[rand] = value;
                });
                return result;
            }
            /**
             * Gets the size of the `collection` by returning `collection.length` for arrays
             * and array-like objects or the number of own enumerable properties for objects.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to inspect.
             * @returns {Number} Returns `collection.length` or number of own enumerable properties.
             * @example
             *
             * _.size([1, 2]);
             * // => 2
             *
             * _.size({ 'one': 1, 'two': 2, 'three': 3 });
             * // => 3
             *
             * _.size('curly');
             * // => 5
             */
            function size(collection) {
                var length = collection ? collection.length : 0;
                return typeof length == 'number' ? length : keys(collection).length;
            }
            /**
             * Checks if the `callback` returns a truthy value for **any** element of a
             * `collection`. The function returns as soon as it finds passing value, and
             * does not iterate over the entire `collection`. The `callback` is bound to
             * `thisArg` and invoked with three arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias any
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Boolean} Returns `true` if any element passes the callback check,
             *  else `false`.
             * @example
             *
             * _.some([null, 0, 'yes', false], Boolean);
             * // => true
             *
             * var food = [
             *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
             *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.some(food, 'organic');
             * // => true
             *
             * // using "_.where" callback shorthand
             * _.some(food, { 'type': 'meat' });
             * // => false
             */
            function some(collection, callback, thisArg) {
                var result;
                callback = lodash.createCallback(callback, thisArg);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        if (result = callback(collection[index], index, collection)) {
                            break;
                        }
                    }
                } else {
                    basicEach(collection, function (value, index, collection) {
                        return !(result = callback(value, index, collection));
                    });
                }
                return !!result;
            }
            /**
             * Creates an array of elements, sorted in ascending order by the results of
             * running each element in the `collection` through the `callback`. This method
             * performs a stable sort, that is, it will preserve the original sort order of
             * equal elements. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index|key, collection).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new array of sorted elements.
             * @example
             *
             * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
             * // => [3, 1, 2]
             *
             * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
             * // => [3, 1, 2]
             *
             * // using "_.pluck" callback shorthand
             * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
             * // => ['apple', 'banana', 'strawberry']
             */
            function sortBy(collection, callback, thisArg) {
                var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
                callback = lodash.createCallback(callback, thisArg);
                forEach(collection, function (value, key, collection) {
                    var object = result[++index] = getObject();
                    object.criteria = callback(value, key, collection);
                    object.index = index;
                    object.value = value;
                });
                length = result.length;
                result.sort(compareAscending);
                while (length--) {
                    var object = result[length];
                    result[length] = object.value;
                    releaseObject(object);
                }
                return result;
            }
            /**
             * Converts the `collection` to an array.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|String} collection The collection to convert.
             * @returns {Array} Returns the new converted array.
             * @example
             *
             * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
             * // => [2, 3, 4]
             */
            function toArray(collection) {
                if (collection && typeof collection.length == 'number') {
                    return support.unindexedChars && isString(collection) ? collection.split('') : slice(collection);
                }
                return values(collection);
            }
            /**
             * Examines each element in a `collection`, returning an array of all elements
             * that have the given `properties`. When checking `properties`, this method
             * performs a deep comparison between values to determine if they are equivalent
             * to each other.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Collections
             * @param {Array|Object|String} collection The collection to iterate over.
             * @param {Object} properties The object of property values to filter by.
             * @returns {Array} Returns a new array of elements that have the given `properties`.
             * @example
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * _.where(stooges, { 'age': 40 });
             * // => [{ 'name': 'moe', 'age': 40 }]
             */
            var where = filter;
            /*--------------------------------------------------------------------------*/
            /**
             * Creates an array with all falsey values of `array` removed. The values
             * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to compact.
             * @returns {Array} Returns a new filtered array.
             * @example
             *
             * _.compact([0, 1, false, 2, '', 3]);
             * // => [1, 2, 3]
             */
            function compact(array) {
                var index = -1, length = array ? array.length : 0, result = [];
                while (++index < length) {
                    var value = array[index];
                    if (value) {
                        result.push(value);
                    }
                }
                return result;
            }
            /**
             * Creates an array of `array` elements not present in the other arrays
             * using strict equality for comparisons, i.e. `===`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to process.
             * @param {Array} [array1, array2, ...] Arrays to check.
             * @returns {Array} Returns a new array of `array` elements not present in the
             *  other arrays.
             * @example
             *
             * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
             * // => [1, 3, 4]
             */
            function difference(array) {
                var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)), result = [];
                var isLarge = length >= largeArraySize && indexOf === basicIndexOf;
                if (isLarge) {
                    var cache = createCache(seen);
                    if (cache) {
                        indexOf = cacheIndexOf;
                        seen = cache;
                    } else {
                        isLarge = false;
                    }
                }
                while (++index < length) {
                    var value = array[index];
                    if (indexOf(seen, value) < 0) {
                        result.push(value);
                    }
                }
                if (isLarge) {
                    releaseObject(seen);
                }
                return result;
            }
            /**
             * This method is similar to `_.find`, except that it returns the index of
             * the element that passes the callback check, instead of the element itself.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to search.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the index of the found element, else `-1`.
             * @example
             *
             * _.findIndex(['apple', 'banana', 'beet'], function(food) {
             *   return /^b/.test(food);
             * });
             * // => 1
             */
            function findIndex(array, callback, thisArg) {
                var index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg);
                while (++index < length) {
                    if (callback(array[index], index, array)) {
                        return index;
                    }
                }
                return -1;
            }
            /**
             * Gets the first element of the `array`. If a number `n` is passed, the first
             * `n` elements of the `array` are returned. If a `callback` function is passed,
             * elements at the beginning of the array are returned as long as the `callback`
             * returns truthy. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index, array).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias head, take
             * @category Arrays
             * @param {Array} array The array to query.
             * @param {Function|Object|Number|String} [callback|n] The function called
             *  per element or the number of elements to return. If a property name or
             *  object is passed, it will be used to create a "_.pluck" or "_.where"
             *  style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the first element(s) of `array`.
             * @example
             *
             * _.first([1, 2, 3]);
             * // => 1
             *
             * _.first([1, 2, 3], 2);
             * // => [1, 2]
             *
             * _.first([1, 2, 3], function(num) {
             *   return num < 3;
             * });
             * // => [1, 2]
             *
             * var food = [
             *   { 'name': 'banana', 'organic': true },
             *   { 'name': 'beet',   'organic': false },
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.first(food, 'organic');
             * // => [{ 'name': 'banana', 'organic': true }]
             *
             * var food = [
             *   { 'name': 'apple',  'type': 'fruit' },
             *   { 'name': 'banana', 'type': 'fruit' },
             *   { 'name': 'beet',   'type': 'vegetable' }
             * ];
             *
             * // using "_.where" callback shorthand
             * _.first(food, { 'type': 'fruit' });
             * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]
             */
            function first(array, callback, thisArg) {
                if (array) {
                    var n = 0, length = array.length;
                    if (typeof callback != 'number' && callback != null) {
                        var index = -1;
                        callback = lodash.createCallback(callback, thisArg);
                        while (++index < length && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array[0];
                        }
                    }
                    return slice(array, 0, nativeMin(nativeMax(0, n), length));
                }
            }
            /**
             * Flattens a nested array (the nesting can be to any depth). If `isShallow`
             * is truthy, `array` will only be flattened a single level. If `callback`
             * is passed, each element of `array` is passed through a `callback` before
             * flattening. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index, array).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to flatten.
             * @param {Boolean} [isShallow=false] A flag to indicate only flattening a single level.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new flattened array.
             * @example
             *
             * _.flatten([1, [2], [3, [[4]]]]);
             * // => [1, 2, 3, 4];
             *
             * _.flatten([1, [2], [3, [[4]]]], true);
             * // => [1, 2, 3, [[4]]];
             *
             * var stooges = [
             *   { 'name': 'curly', 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },
             *   { 'name': 'moe', 'quotes': ['Spread out!', 'You knucklehead!'] }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.flatten(stooges, 'quotes');
             * // => ['Oh, a wise guy, eh?', 'Poifect!', 'Spread out!', 'You knucklehead!']
             */
            var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
                    var index = -1, length = array ? array.length : 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (callback) {
                            value = callback(value, index, array);
                        }
                        // recursively flatten arrays (susceptible to call stack limits)
                        if (isArray(value)) {
                            push.apply(result, isShallow ? value : flatten(value));
                        } else {
                            result.push(value);
                        }
                    }
                    return result;
                });
            /**
             * Gets the index at which the first occurrence of `value` is found using
             * strict equality for comparisons, i.e. `===`. If the `array` is already
             * sorted, passing `true` for `fromIndex` will run a faster binary search.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to search.
             * @param {Mixed} value The value to search for.
             * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
             *  perform a binary search on a sorted `array`.
             * @returns {Number} Returns the index of the matched value or `-1`.
             * @example
             *
             * _.indexOf([1, 2, 3, 1, 2, 3], 2);
             * // => 1
             *
             * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
             * // => 4
             *
             * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
             * // => 2
             */
            function indexOf(array, value, fromIndex) {
                if (typeof fromIndex == 'number') {
                    var length = array ? array.length : 0;
                    fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                } else if (fromIndex) {
                    var index = sortedIndex(array, value);
                    return array[index] === value ? index : -1;
                }
                return array ? basicIndexOf(array, value, fromIndex) : -1;
            }
            /**
             * Gets all but the last element of `array`. If a number `n` is passed, the
             * last `n` elements are excluded from the result. If a `callback` function
             * is passed, elements at the end of the array are excluded from the result
             * as long as the `callback` returns truthy. The `callback` is bound to
             * `thisArg` and invoked with three arguments; (value, index, array).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to query.
             * @param {Function|Object|Number|String} [callback|n=1] The function called
             *  per element or the number of elements to exclude. If a property name or
             *  object is passed, it will be used to create a "_.pluck" or "_.where"
             *  style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a slice of `array`.
             * @example
             *
             * _.initial([1, 2, 3]);
             * // => [1, 2]
             *
             * _.initial([1, 2, 3], 2);
             * // => [1]
             *
             * _.initial([1, 2, 3], function(num) {
             *   return num > 1;
             * });
             * // => [1]
             *
             * var food = [
             *   { 'name': 'beet',   'organic': false },
             *   { 'name': 'carrot', 'organic': true }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.initial(food, 'organic');
             * // => [{ 'name': 'beet',   'organic': false }]
             *
             * var food = [
             *   { 'name': 'banana', 'type': 'fruit' },
             *   { 'name': 'beet',   'type': 'vegetable' },
             *   { 'name': 'carrot', 'type': 'vegetable' }
             * ];
             *
             * // using "_.where" callback shorthand
             * _.initial(food, { 'type': 'vegetable' });
             * // => [{ 'name': 'banana', 'type': 'fruit' }]
             */
            function initial(array, callback, thisArg) {
                if (!array) {
                    return [];
                }
                var n = 0, length = array.length;
                if (typeof callback != 'number' && callback != null) {
                    var index = length;
                    callback = lodash.createCallback(callback, thisArg);
                    while (index-- && callback(array[index], index, array)) {
                        n++;
                    }
                } else {
                    n = callback == null || thisArg ? 1 : callback || n;
                }
                return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
            }
            /**
             * Computes the intersection of all the passed-in arrays using strict equality
             * for comparisons, i.e. `===`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} [array1, array2, ...] Arrays to process.
             * @returns {Array} Returns a new array of unique elements that are present
             *  in **all** of the arrays.
             * @example
             *
             * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
             * // => [1, 2]
             */
            function intersection(array) {
                var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray();
                while (++argsIndex < argsLength) {
                    var value = args[argsIndex];
                    caches[argsIndex] = indexOf === basicIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
                }
                outer:
                    while (++index < length) {
                        var cache = caches[0];
                        value = array[index];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                            argsIndex = argsLength;
                            (cache || seen).push(value);
                            while (--argsIndex) {
                                cache = caches[argsIndex];
                                if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                    continue outer;
                                }
                            }
                            result.push(value);
                        }
                    }
                while (argsLength--) {
                    cache = caches[argsLength];
                    if (cache) {
                        releaseObject(cache);
                    }
                }
                releaseArray(caches);
                releaseArray(seen);
                return result;
            }
            /**
             * Gets the last element of the `array`. If a number `n` is passed, the
             * last `n` elements of the `array` are returned. If a `callback` function
             * is passed, elements at the end of the array are returned as long as the
             * `callback` returns truthy. The `callback` is bound to `thisArg` and
             * invoked with three arguments;(value, index, array).
             *
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to query.
             * @param {Function|Object|Number|String} [callback|n] The function called
             *  per element or the number of elements to return. If a property name or
             *  object is passed, it will be used to create a "_.pluck" or "_.where"
             *  style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Mixed} Returns the last element(s) of `array`.
             * @example
             *
             * _.last([1, 2, 3]);
             * // => 3
             *
             * _.last([1, 2, 3], 2);
             * // => [2, 3]
             *
             * _.last([1, 2, 3], function(num) {
             *   return num > 1;
             * });
             * // => [2, 3]
             *
             * var food = [
             *   { 'name': 'beet',   'organic': false },
             *   { 'name': 'carrot', 'organic': true }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.last(food, 'organic');
             * // => [{ 'name': 'carrot', 'organic': true }]
             *
             * var food = [
             *   { 'name': 'banana', 'type': 'fruit' },
             *   { 'name': 'beet',   'type': 'vegetable' },
             *   { 'name': 'carrot', 'type': 'vegetable' }
             * ];
             *
             * // using "_.where" callback shorthand
             * _.last(food, { 'type': 'vegetable' });
             * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]
             */
            function last(array, callback, thisArg) {
                if (array) {
                    var n = 0, length = array.length;
                    if (typeof callback != 'number' && callback != null) {
                        var index = length;
                        callback = lodash.createCallback(callback, thisArg);
                        while (index-- && callback(array[index], index, array)) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if (n == null || thisArg) {
                            return array[length - 1];
                        }
                    }
                    return slice(array, nativeMax(0, length - n));
                }
            }
            /**
             * Gets the index at which the last occurrence of `value` is found using strict
             * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
             * as the offset from the end of the collection.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to search.
             * @param {Mixed} value The value to search for.
             * @param {Number} [fromIndex=array.length-1] The index to search from.
             * @returns {Number} Returns the index of the matched value or `-1`.
             * @example
             *
             * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
             * // => 4
             *
             * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
             * // => 1
             */
            function lastIndexOf(array, value, fromIndex) {
                var index = array ? array.length : 0;
                if (typeof fromIndex == 'number') {
                    index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                }
                while (index--) {
                    if (array[index] === value) {
                        return index;
                    }
                }
                return -1;
            }
            /**
             * Creates an array of numbers (positive and/or negative) progressing from
             * `start` up to but not including `end`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Number} [start=0] The start of the range.
             * @param {Number} end The end of the range.
             * @param {Number} [step=1] The value to increment or decrement by.
             * @returns {Array} Returns a new range array.
             * @example
             *
             * _.range(10);
             * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
             *
             * _.range(1, 11);
             * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
             *
             * _.range(0, 30, 5);
             * // => [0, 5, 10, 15, 20, 25]
             *
             * _.range(0, -10, -1);
             * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
             *
             * _.range(0);
             * // => []
             */
            function range(start, end, step) {
                start = +start || 0;
                step = +step || 1;
                if (end == null) {
                    end = start;
                    start = 0;
                }
                // use `Array(length)` so V8 will avoid the slower "dictionary" mode
                // http://youtu.be/XAqIpGU8ZZk#t=17m25s
                var index = -1, length = nativeMax(0, ceil((end - start) / step)), result = Array(length);
                while (++index < length) {
                    result[index] = start;
                    start += step;
                }
                return result;
            }
            /**
             * The opposite of `_.initial`, this method gets all but the first value of
             * `array`. If a number `n` is passed, the first `n` values are excluded from
             * the result. If a `callback` function is passed, elements at the beginning
             * of the array are excluded from the result as long as the `callback` returns
             * truthy. The `callback` is bound to `thisArg` and invoked with three
             * arguments; (value, index, array).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias drop, tail
             * @category Arrays
             * @param {Array} array The array to query.
             * @param {Function|Object|Number|String} [callback|n=1] The function called
             *  per element or the number of elements to exclude. If a property name or
             *  object is passed, it will be used to create a "_.pluck" or "_.where"
             *  style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a slice of `array`.
             * @example
             *
             * _.rest([1, 2, 3]);
             * // => [2, 3]
             *
             * _.rest([1, 2, 3], 2);
             * // => [3]
             *
             * _.rest([1, 2, 3], function(num) {
             *   return num < 3;
             * });
             * // => [3]
             *
             * var food = [
             *   { 'name': 'banana', 'organic': true },
             *   { 'name': 'beet',   'organic': false },
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.rest(food, 'organic');
             * // => [{ 'name': 'beet', 'organic': false }]
             *
             * var food = [
             *   { 'name': 'apple',  'type': 'fruit' },
             *   { 'name': 'banana', 'type': 'fruit' },
             *   { 'name': 'beet',   'type': 'vegetable' }
             * ];
             *
             * // using "_.where" callback shorthand
             * _.rest(food, { 'type': 'fruit' });
             * // => [{ 'name': 'beet', 'type': 'vegetable' }]
             */
            function rest(array, callback, thisArg) {
                if (typeof callback != 'number' && callback != null) {
                    var n = 0, index = -1, length = array ? array.length : 0;
                    callback = lodash.createCallback(callback, thisArg);
                    while (++index < length && callback(array[index], index, array)) {
                        n++;
                    }
                } else {
                    n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                }
                return slice(array, n);
            }
            /**
             * Uses a binary search to determine the smallest index at which the `value`
             * should be inserted into `array` in order to maintain the sort order of the
             * sorted `array`. If `callback` is passed, it will be executed for `value` and
             * each element in `array` to compute their sort ranking. The `callback` is
             * bound to `thisArg` and invoked with one argument; (value).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to inspect.
             * @param {Mixed} value The value to evaluate.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Number} Returns the index at which the value should be inserted
             *  into `array`.
             * @example
             *
             * _.sortedIndex([20, 30, 50], 40);
             * // => 2
             *
             * // using "_.pluck" callback shorthand
             * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
             * // => 2
             *
             * var dict = {
             *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
             * };
             *
             * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
             *   return dict.wordToNumber[word];
             * });
             * // => 2
             *
             * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
             *   return this.wordToNumber[word];
             * }, dict);
             * // => 2
             */
            function sortedIndex(array, value, callback, thisArg) {
                var low = 0, high = array ? array.length : low;
                // explicitly reference `identity` for better inlining in Firefox
                callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                value = callback(value);
                while (low < high) {
                    var mid = low + high >>> 1;
                    callback(array[mid]) < value ? low = mid + 1 : high = mid;
                }
                return low;
            }
            /**
             * Computes the union of the passed-in arrays using strict equality for
             * comparisons, i.e. `===`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} [array1, array2, ...] Arrays to process.
             * @returns {Array} Returns a new array of unique values, in order, that are
             *  present in one or more of the arrays.
             * @example
             *
             * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
             * // => [1, 2, 3, 101, 10]
             */
            function union(array) {
                if (!isArray(array)) {
                    arguments[0] = array ? nativeSlice.call(array) : arrayRef;
                }
                return uniq(concat.apply(arrayRef, arguments));
            }
            /**
             * Creates a duplicate-value-free version of the `array` using strict equality
             * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
             * for `isSorted` will run a faster algorithm. If `callback` is passed, each
             * element of `array` is passed through the `callback` before uniqueness is computed.
             * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
             *
             * If a property name is passed for `callback`, the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is passed for `callback`, the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias unique
             * @category Arrays
             * @param {Array} array The array to process.
             * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
             * @param {Function|Object|String} [callback=identity] The function called per
             *  iteration. If a property name or object is passed, it will be used to create
             *  a "_.pluck" or "_.where" style callback, respectively.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a duplicate-value-free array.
             * @example
             *
             * _.uniq([1, 2, 1, 3, 1]);
             * // => [1, 2, 3]
             *
             * _.uniq([1, 1, 2, 2, 3], true);
             * // => [1, 2, 3]
             *
             * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
             * // => ['A', 'b', 'C']
             *
             * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
             * // => [1, 2.5, 3]
             *
             * // using "_.pluck" callback shorthand
             * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
             * // => [{ 'x': 1 }, { 'x': 2 }]
             */
            var uniq = overloadWrapper(function (array, isSorted, callback) {
                    var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                    var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf, seen = callback || isLarge ? getArray() : result;
                    if (isLarge) {
                        var cache = createCache(seen);
                        if (cache) {
                            indexOf = cacheIndexOf;
                            seen = cache;
                        } else {
                            isLarge = false;
                            seen = callback ? seen : (releaseArray(seen), result);
                        }
                    }
                    while (++index < length) {
                        var value = array[index], computed = callback ? callback(value, index, array) : value;
                        if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                            if (callback || isLarge) {
                                seen.push(computed);
                            }
                            result.push(value);
                        }
                    }
                    if (isLarge) {
                        releaseArray(seen.array);
                        releaseObject(seen);
                    } else if (callback) {
                        releaseArray(seen);
                    }
                    return result;
                });
            /**
             * The inverse of `_.zip`, this method splits groups of elements into arrays
             * composed of elements from each group at their corresponding indexes.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to process.
             * @returns {Array} Returns a new array of the composed arrays.
             * @example
             *
             * _.unzip([['moe', 30, true], ['larry', 40, false]]);
             * // => [['moe', 'larry'], [30, 40], [true, false]];
             */
            function unzip(array) {
                var index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
                while (++index < length) {
                    result[index] = pluck(array, index);
                }
                return result;
            }
            /**
             * Creates an array with all occurrences of the passed values removed using
             * strict equality for comparisons, i.e. `===`.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to filter.
             * @param {Mixed} [value1, value2, ...] Values to remove.
             * @returns {Array} Returns a new filtered array.
             * @example
             *
             * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
             * // => [2, 3, 4]
             */
            function without(array) {
                return difference(array, nativeSlice.call(arguments, 1));
            }
            /**
             * Groups the elements of each array at their corresponding indexes. Useful for
             * separate data sources that are coordinated through matching array indexes.
             * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
             * in a similar fashion.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} [array1, array2, ...] Arrays to process.
             * @returns {Array} Returns a new array of grouped elements.
             * @example
             *
             * _.zip(['moe', 'larry'], [30, 40], [true, false]);
             * // => [['moe', 30, true], ['larry', 40, false]]
             */
            function zip(array) {
                return array ? unzip(arguments) : [];
            }
            /**
             * Creates an object composed from arrays of `keys` and `values`. Pass either
             * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
             * two arrays, one of `keys` and one of corresponding `values`.
             *
             * @static
             * @memberOf _
             * @alias object
             * @category Arrays
             * @param {Array} keys The array of keys.
             * @param {Array} [values=[]] The array of values.
             * @returns {Object} Returns an object composed of the given keys and
             *  corresponding values.
             * @example
             *
             * _.zipObject(['moe', 'larry'], [30, 40]);
             * // => { 'moe': 30, 'larry': 40 }
             */
            function zipObject(keys, values) {
                var index = -1, length = keys ? keys.length : 0, result = {};
                while (++index < length) {
                    var key = keys[index];
                    if (values) {
                        result[key] = values[index];
                    } else {
                        result[key[0]] = key[1];
                    }
                }
                return result;
            }
            /*--------------------------------------------------------------------------*/
            /**
             * If `n` is greater than `0`, a function is created that is restricted to
             * executing `func`, with the `this` binding and arguments of the created
             * function, only after it is called `n` times. If `n` is less than `1`,
             * `func` is executed immediately, without a `this` binding or additional
             * arguments, and its result is returned.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Number} n The number of times the function must be called before
             * it is executed.
             * @param {Function} func The function to restrict.
             * @returns {Function} Returns the new restricted function.
             * @example
             *
             * var renderNotes = _.after(notes.length, render);
             * _.forEach(notes, function(note) {
             *   note.asyncSave({ 'success': renderNotes });
             * });
             * // `renderNotes` is run once, after all notes have saved
             */
            function after(n, func) {
                if (n < 1) {
                    return func();
                }
                return function () {
                    if (--n < 1) {
                        return func.apply(this, arguments);
                    }
                };
            }
            /**
             * Creates a function that, when called, invokes `func` with the `this`
             * binding of `thisArg` and prepends any additional `bind` arguments to those
             * passed to the bound function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to bind.
             * @param {Mixed} [thisArg] The `this` binding of `func`.
             * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
             * @returns {Function} Returns the new bound function.
             * @example
             *
             * var func = function(greeting) {
             *   return greeting + ' ' + this.name;
             * };
             *
             * func = _.bind(func, { 'name': 'moe' }, 'hi');
             * func();
             * // => 'hi moe'
             */
            function bind(func, thisArg) {
                // use `Function#bind` if it exists and is fast
                // (in V8 `Function#bind` is slower except when partially applied)
                return support.fastBind || nativeBind && arguments.length > 2 ? nativeBind.call.apply(nativeBind, arguments) : createBound(func, thisArg, nativeSlice.call(arguments, 2));
            }
            /**
             * Binds methods on `object` to `object`, overwriting the existing method.
             * Method names may be specified as individual arguments or as arrays of method
             * names. If no method names are provided, all the function properties of `object`
             * will be bound.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Object} object The object to bind and assign the bound methods to.
             * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
             * @returns {Object} Returns `object`.
             * @example
             *
             * var view = {
             *  'label': 'docs',
             *  'onClick': function() { alert('clicked ' + this.label); }
             * };
             *
             * _.bindAll(view);
             * jQuery('#docs').on('click', view.onClick);
             * // => alerts 'clicked docs', when the button is clicked
             */
            function bindAll(object) {
                var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object), index = -1, length = funcs.length;
                while (++index < length) {
                    var key = funcs[index];
                    object[key] = bind(object[key], object);
                }
                return object;
            }
            /**
             * Creates a function that, when called, invokes the method at `object[key]`
             * and prepends any additional `bindKey` arguments to those passed to the bound
             * function. This method differs from `_.bind` by allowing bound functions to
             * reference methods that will be redefined or don't yet exist.
             * See http://michaux.ca/articles/lazy-function-definition-pattern.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Object} object The object the method belongs to.
             * @param {String} key The key of the method.
             * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
             * @returns {Function} Returns the new bound function.
             * @example
             *
             * var object = {
             *   'name': 'moe',
             *   'greet': function(greeting) {
             *     return greeting + ' ' + this.name;
             *   }
             * };
             *
             * var func = _.bindKey(object, 'greet', 'hi');
             * func();
             * // => 'hi moe'
             *
             * object.greet = function(greeting) {
             *   return greeting + ', ' + this.name + '!';
             * };
             *
             * func();
             * // => 'hi, moe!'
             */
            function bindKey(object, key) {
                return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
            }
            /**
             * Creates a function that is the composition of the passed functions,
             * where each function consumes the return value of the function that follows.
             * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
             * Each function is executed with the `this` binding of the composed function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} [func1, func2, ...] Functions to compose.
             * @returns {Function} Returns the new composed function.
             * @example
             *
             * var greet = function(name) { return 'hi ' + name; };
             * var exclaim = function(statement) { return statement + '!'; };
             * var welcome = _.compose(exclaim, greet);
             * welcome('moe');
             * // => 'hi moe!'
             */
            function compose() {
                var funcs = arguments;
                return function () {
                    var args = arguments, length = funcs.length;
                    while (length--) {
                        args = [funcs[length].apply(this, args)];
                    }
                    return args[0];
                };
            }
            /**
             * Produces a callback bound to an optional `thisArg`. If `func` is a property
             * name, the created callback will return the property value for a given element.
             * If `func` is an object, the created callback will return `true` for elements
             * that contain the equivalent object properties, otherwise it will return `false`.
             *
             * Note: All Lo-Dash methods, that accept a `callback` argument, use `_.createCallback`.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Mixed} [func=identity] The value to convert to a callback.
             * @param {Mixed} [thisArg] The `this` binding of the created callback.
             * @param {Number} [argCount=3] The number of arguments the callback accepts.
             * @returns {Function} Returns a callback function.
             * @example
             *
             * var stooges = [
             *   { 'name': 'moe', 'age': 40 },
             *   { 'name': 'larry', 'age': 50 }
             * ];
             *
             * // wrap to create custom callback shorthands
             * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
             *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
             *   return !match ? func(callback, thisArg) : function(object) {
             *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
             *   };
             * });
             *
             * _.filter(stooges, 'age__gt45');
             * // => [{ 'name': 'larry', 'age': 50 }]
             *
             * // create mixins with support for "_.pluck" and "_.where" callback shorthands
             * _.mixin({
             *   'toLookup': function(collection, callback, thisArg) {
             *     callback = _.createCallback(callback, thisArg);
             *     return _.reduce(collection, function(result, value, index, collection) {
             *       return (result[callback(value, index, collection)] = value, result);
             *     }, {});
             *   }
             * });
             *
             * _.toLookup(stooges, 'name');
             * // => { 'moe': { 'name': 'moe', 'age': 40 }, 'larry': { 'name': 'larry', 'age': 50 } }
             */
            function createCallback(func, thisArg, argCount) {
                if (func == null) {
                    return identity;
                }
                var type = typeof func;
                if (type != 'function') {
                    if (type != 'object') {
                        return function (object) {
                            return object[func];
                        };
                    }
                    var props = keys(func);
                    return function (object) {
                        var length = props.length, result = false;
                        while (length--) {
                            if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
                                break;
                            }
                        }
                        return result;
                    };
                }
                if (typeof thisArg == 'undefined' || reThis && !reThis.test(fnToString.call(func))) {
                    return func;
                }
                if (argCount === 1) {
                    return function (value) {
                        return func.call(thisArg, value);
                    };
                }
                if (argCount === 2) {
                    return function (a, b) {
                        return func.call(thisArg, a, b);
                    };
                }
                if (argCount === 4) {
                    return function (accumulator, value, index, collection) {
                        return func.call(thisArg, accumulator, value, index, collection);
                    };
                }
                return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
            }
            /**
             * Creates a function that will delay the execution of `func` until after
             * `wait` milliseconds have elapsed since the last time it was invoked. Pass
             * an `options` object to indicate that `func` should be invoked on the leading
             * and/or trailing edge of the `wait` timeout. Subsequent calls to the debounced
             * function will return the result of the last `func` call.
             *
             * Note: If `leading` and `trailing` options are `true`, `func` will be called
             * on the trailing edge of the timeout only if the the debounced function is
             * invoked more than once during the `wait` timeout.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to debounce.
             * @param {Number} wait The number of milliseconds to delay.
             * @param {Object} options The options object.
             *  [leading=false] A boolean to specify execution on the leading edge of the timeout.
             *  [maxWait] The maximum time `func` is allowed to be delayed before it's called.
             *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
             * @returns {Function} Returns the new debounced function.
             * @example
             *
             * var lazyLayout = _.debounce(calculateLayout, 300);
             * jQuery(window).on('resize', lazyLayout);
             *
             * jQuery('#postbox').on('click', _.debounce(sendMail, 200, {
             *   'leading': true,
             *   'trailing': false
             * });
             */
            function debounce(func, wait, options) {
                var args, result, thisArg, callCount = 0, lastCalled = 0, maxWait = false, maxTimeoutId = null, timeoutId = null, trailing = true;
                function clear() {
                    clearTimeout(maxTimeoutId);
                    clearTimeout(timeoutId);
                    callCount = 0;
                    maxTimeoutId = timeoutId = null;
                }
                function delayed() {
                    var isCalled = trailing && (!leading || callCount > 1);
                    clear();
                    if (isCalled) {
                        if (maxWait !== false) {
                            lastCalled = new Date();
                        }
                        result = func.apply(thisArg, args);
                    }
                }
                function maxDelayed() {
                    clear();
                    if (trailing || maxWait !== wait) {
                        lastCalled = new Date();
                        result = func.apply(thisArg, args);
                    }
                }
                wait = nativeMax(0, wait || 0);
                if (options === true) {
                    var leading = true;
                    trailing = false;
                } else if (isObject(options)) {
                    leading = options.leading;
                    maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
                    trailing = 'trailing' in options ? options.trailing : trailing;
                }
                return function () {
                    args = arguments;
                    thisArg = this;
                    callCount++;
                    // avoid issues with Titanium and `undefined` timeout ids
                    // https://github.com/appcelerator/titanium_mobile/blob/3_1_0_GA/android/titanium/src/java/ti/modules/titanium/TitaniumModule.java#L185-L192
                    clearTimeout(timeoutId);
                    if (maxWait === false) {
                        if (leading && callCount < 2) {
                            result = func.apply(thisArg, args);
                        }
                    } else {
                        var now = new Date();
                        if (!maxTimeoutId && !leading) {
                            lastCalled = now;
                        }
                        var remaining = maxWait - (now - lastCalled);
                        if (remaining <= 0) {
                            clearTimeout(maxTimeoutId);
                            maxTimeoutId = null;
                            lastCalled = now;
                            result = func.apply(thisArg, args);
                        } else if (!maxTimeoutId) {
                            maxTimeoutId = setTimeout(maxDelayed, remaining);
                        }
                    }
                    if (wait !== maxWait) {
                        timeoutId = setTimeout(delayed, wait);
                    }
                    return result;
                };
            }
            /**
             * Defers executing the `func` function until the current call stack has cleared.
             * Additional arguments will be passed to `func` when it is invoked.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to defer.
             * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
             * @returns {Number} Returns the timer id.
             * @example
             *
             * _.defer(function() { alert('deferred'); });
             * // returns from the function before `alert` is called
             */
            function defer(func) {
                var args = nativeSlice.call(arguments, 1);
                return setTimeout(function () {
                    func.apply(undefined, args);
                }, 1);
            }
            // use `setImmediate` if it's available in Node.js
            if (isV8 && freeModule && typeof setImmediate == 'function') {
                defer = bind(setImmediate, context);
            }
            /**
             * Executes the `func` function after `wait` milliseconds. Additional arguments
             * will be passed to `func` when it is invoked.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to delay.
             * @param {Number} wait The number of milliseconds to delay execution.
             * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
             * @returns {Number} Returns the timer id.
             * @example
             *
             * var log = _.bind(console.log, console);
             * _.delay(log, 1000, 'logged later');
             * // => 'logged later' (Appears after one second.)
             */
            function delay(func, wait) {
                var args = nativeSlice.call(arguments, 2);
                return setTimeout(function () {
                    func.apply(undefined, args);
                }, wait);
            }
            /**
             * Creates a function that memoizes the result of `func`. If `resolver` is
             * passed, it will be used to determine the cache key for storing the result
             * based on the arguments passed to the memoized function. By default, the first
             * argument passed to the memoized function is used as the cache key. The `func`
             * is executed with the `this` binding of the memoized function. The result
             * cache is exposed as the `cache` property on the memoized function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to have its output memoized.
             * @param {Function} [resolver] A function used to resolve the cache key.
             * @returns {Function} Returns the new memoizing function.
             * @example
             *
             * var fibonacci = _.memoize(function(n) {
             *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
             * });
             */
            function memoize(func, resolver) {
                function memoized() {
                    var cache = memoized.cache, key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);
                    return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                }
                memoized.cache = {};
                return memoized;
            }
            /**
             * Creates a function that is restricted to execute `func` once. Repeat calls to
             * the function will return the value of the first call. The `func` is executed
             * with the `this` binding of the created function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to restrict.
             * @returns {Function} Returns the new restricted function.
             * @example
             *
             * var initialize = _.once(createApplication);
             * initialize();
             * initialize();
             * // `initialize` executes `createApplication` once
             */
            function once(func) {
                var ran, result;
                return function () {
                    if (ran) {
                        return result;
                    }
                    ran = true;
                    result = func.apply(this, arguments);
                    // clear the `func` variable so the function may be garbage collected
                    func = null;
                    return result;
                };
            }
            /**
             * Creates a function that, when called, invokes `func` with any additional
             * `partial` arguments prepended to those passed to the new function. This
             * method is similar to `_.bind`, except it does **not** alter the `this` binding.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to partially apply arguments to.
             * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
             * @returns {Function} Returns the new partially applied function.
             * @example
             *
             * var greet = function(greeting, name) { return greeting + ' ' + name; };
             * var hi = _.partial(greet, 'hi');
             * hi('moe');
             * // => 'hi moe'
             */
            function partial(func) {
                return createBound(func, nativeSlice.call(arguments, 1));
            }
            /**
             * This method is similar to `_.partial`, except that `partial` arguments are
             * appended to those passed to the new function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to partially apply arguments to.
             * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
             * @returns {Function} Returns the new partially applied function.
             * @example
             *
             * var defaultsDeep = _.partialRight(_.merge, _.defaults);
             *
             * var options = {
             *   'variable': 'data',
             *   'imports': { 'jq': $ }
             * };
             *
             * defaultsDeep(options, _.templateSettings);
             *
             * options.variable
             * // => 'data'
             *
             * options.imports
             * // => { '_': _, 'jq': $ }
             */
            function partialRight(func) {
                return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
            }
            /**
             * Creates a function that, when executed, will only call the `func` function
             * at most once per every `wait` milliseconds. Pass an `options` object to
             * indicate that `func` should be invoked on the leading and/or trailing edge
             * of the `wait` timeout. Subsequent calls to the throttled function will
             * return the result of the last `func` call.
             *
             * Note: If `leading` and `trailing` options are `true`, `func` will be called
             * on the trailing edge of the timeout only if the the throttled function is
             * invoked more than once during the `wait` timeout.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Function} func The function to throttle.
             * @param {Number} wait The number of milliseconds to throttle executions to.
             * @param {Object} options The options object.
             *  [leading=true] A boolean to specify execution on the leading edge of the timeout.
             *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
             * @returns {Function} Returns the new throttled function.
             * @example
             *
             * var throttled = _.throttle(updatePosition, 100);
             * jQuery(window).on('scroll', throttled);
             *
             * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
             *   'trailing': false
             * }));
             */
            function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if (options === false) {
                    leading = false;
                } else if (isObject(options)) {
                    leading = 'leading' in options ? options.leading : leading;
                    trailing = 'trailing' in options ? options.trailing : trailing;
                }
                options = getObject();
                options.leading = leading;
                options.maxWait = wait;
                options.trailing = trailing;
                var result = debounce(func, wait, options);
                releaseObject(options);
                return result;
            }
            /**
             * Creates a function that passes `value` to the `wrapper` function as its
             * first argument. Additional arguments passed to the function are appended
             * to those passed to the `wrapper` function. The `wrapper` is executed with
             * the `this` binding of the created function.
             *
             * @static
             * @memberOf _
             * @category Functions
             * @param {Mixed} value The value to wrap.
             * @param {Function} wrapper The wrapper function.
             * @returns {Function} Returns the new function.
             * @example
             *
             * var hello = function(name) { return 'hello ' + name; };
             * hello = _.wrap(hello, function(func) {
             *   return 'before, ' + func('moe') + ', after';
             * });
             * hello();
             * // => 'before, hello moe, after'
             */
            function wrap(value, wrapper) {
                return function () {
                    var args = [value];
                    push.apply(args, arguments);
                    return wrapper.apply(this, args);
                };
            }
            /*--------------------------------------------------------------------------*/
            /**
             * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
             * corresponding HTML entities.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {String} string The string to escape.
             * @returns {String} Returns the escaped string.
             * @example
             *
             * _.escape('Moe, Larry & Curly');
             * // => 'Moe, Larry &amp; Curly'
             */
            function escape(string) {
                return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
            }
            /**
             * This method returns the first argument passed to it.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {Mixed} value Any value.
             * @returns {Mixed} Returns `value`.
             * @example
             *
             * var moe = { 'name': 'moe' };
             * moe === _.identity(moe);
             * // => true
             */
            function identity(value) {
                return value;
            }
            /**
             * Adds functions properties of `object` to the `lodash` function and chainable
             * wrapper.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {Object} object The object of function properties to add to `lodash`.
             * @example
             *
             * _.mixin({
             *   'capitalize': function(string) {
             *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
             *   }
             * });
             *
             * _.capitalize('moe');
             * // => 'Moe'
             *
             * _('moe').capitalize();
             * // => 'Moe'
             */
            function mixin(object) {
                forEach(functions(object), function (methodName) {
                    var func = lodash[methodName] = object[methodName];
                    lodash.prototype[methodName] = function () {
                        var value = this.__wrapped__, args = [value];
                        push.apply(args, arguments);
                        var result = func.apply(lodash, args);
                        return value && typeof value == 'object' && value === result ? this : new lodashWrapper(result);
                    };
                });
            }
            /**
             * Reverts the '_' variable to its previous value and returns a reference to
             * the `lodash` function.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @returns {Function} Returns the `lodash` function.
             * @example
             *
             * var lodash = _.noConflict();
             */
            function noConflict() {
                context._ = oldDash;
                return this;
            }
            /**
             * Converts the given `value` into an integer of the specified `radix`.
             * If `radix` is `undefined` or `0`, a `radix` of `10` is used unless the
             * `value` is a hexadecimal, in which case a `radix` of `16` is used.
             *
             * Note: This method avoids differences in native ES3 and ES5 `parseInt`
             * implementations. See http://es5.github.com/#E.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {String} value The value to parse.
             * @param {Number} [radix] The radix used to interpret the value to parse.
             * @returns {Number} Returns the new integer value.
             * @example
             *
             * _.parseInt('08');
             * // => 8
             */
            var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
                    // Firefox and Opera still follow the ES3 specified implementation of `parseInt`
                    return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
                };
            /**
             * Produces a random number between `min` and `max` (inclusive). If only one
             * argument is passed, a number between `0` and the given number will be returned.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {Number} [min=0] The minimum possible value.
             * @param {Number} [max=1] The maximum possible value.
             * @returns {Number} Returns a random number.
             * @example
             *
             * _.random(0, 5);
             * // => a number between 0 and 5
             *
             * _.random(5);
             * // => also a number between 0 and 5
             */
            function random(min, max) {
                if (min == null && max == null) {
                    max = 1;
                }
                min = +min || 0;
                if (max == null) {
                    max = min;
                    min = 0;
                } else {
                    max = +max || 0;
                }
                var rand = nativeRandom();
                return min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max) : min + floor(rand * (max - min + 1));
            }
            /**
             * Resolves the value of `property` on `object`. If `property` is a function,
             * it will be invoked with the `this` binding of `object` and its result returned,
             * else the property value is returned. If `object` is falsey, then `undefined`
             * is returned.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {Object} object The object to inspect.
             * @param {String} property The property to get the value of.
             * @returns {Mixed} Returns the resolved value.
             * @example
             *
             * var object = {
             *   'cheese': 'crumpets',
             *   'stuff': function() {
             *     return 'nonsense';
             *   }
             * };
             *
             * _.result(object, 'cheese');
             * // => 'crumpets'
             *
             * _.result(object, 'stuff');
             * // => 'nonsense'
             */
            function result(object, property) {
                var value = object ? object[property] : undefined;
                return isFunction(value) ? object[property]() : value;
            }
            /**
             * A micro-templating method that handles arbitrary delimiters, preserves
             * whitespace, and correctly escapes quotes within interpolated code.
             *
             * Note: In the development build, `_.template` utilizes sourceURLs for easier
             * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
             *
             * For more information on precompiling templates see:
             * http://lodash.com/#custom-builds
             *
             * For more information on Chrome extension sandboxes see:
             * http://developer.chrome.com/stable/extensions/sandboxingEval.html
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {String} text The template text.
             * @param {Object} data The data object used to populate the text.
             * @param {Object} options The options object.
             *  escape - The "escape" delimiter regexp.
             *  evaluate - The "evaluate" delimiter regexp.
             *  interpolate - The "interpolate" delimiter regexp.
             *  sourceURL - The sourceURL of the template's compiled source.
             *  variable - The data object variable name.
             * @returns {Function|String} Returns a compiled function when no `data` object
             *  is given, else it returns the interpolated text.
             * @example
             *
             * // using a compiled template
             * var compiled = _.template('hello <%= name %>');
             * compiled({ 'name': 'moe' });
             * // => 'hello moe'
             *
             * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
             * _.template(list, { 'people': ['moe', 'larry'] });
             * // => '<li>moe</li><li>larry</li>'
             *
             * // using the "escape" delimiter to escape HTML in data property values
             * _.template('<b><%- value %></b>', { 'value': '<script>' });
             * // => '<b>&lt;script&gt;</b>'
             *
             * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
             * _.template('hello ${ name }', { 'name': 'curly' });
             * // => 'hello curly'
             *
             * // using the internal `print` function in "evaluate" delimiters
             * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
             * // => 'hello stooge!'
             *
             * // using custom template delimiters
             * _.templateSettings = {
             *   'interpolate': /{{([\s\S]+?)}}/g
             * };
             *
             * _.template('hello {{ name }}!', { 'name': 'mustache' });
             * // => 'hello mustache!'
             *
             * // using the `sourceURL` option to specify a custom sourceURL for the template
             * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
             * compiled(data);
             * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
             *
             * // using the `variable` option to ensure a with-statement isn't used in the compiled template
             * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
             * compiled.source;
             * // => function(data) {
             *   var __t, __p = '', __e = _.escape;
             *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
             *   return __p;
             * }
             *
             * // using the `source` property to inline compiled templates for meaningful
             * // line numbers in error messages and a stack trace
             * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
             *   var JST = {\
             *     "main": ' + _.template(mainText).source + '\
             *   };\
             * ');
             */
            function template(text, data, options) {
                // based on John Resig's `tmpl` implementation
                // http://ejohn.org/blog/javascript-micro-templating/
                // and Laura Doktorova's doT.js
                // https://github.com/olado/doT
                var settings = lodash.templateSettings;
                text || (text = '');
                // avoid missing dependencies when `iteratorTemplate` is not defined
                options = defaults({}, options, settings);
                var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
                // compile the regexp to match each delimiter
                var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    // escape characters that cannot be included in string literals
                    source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                    // replace delimiters with snippets
                    if (escapeValue) {
                        source += '\' +\n__e(' + escapeValue + ') +\n\'';
                    }
                    if (evaluateValue) {
                        isEvaluating = true;
                        source += '\';\n' + evaluateValue + ';\n__p += \'';
                    }
                    if (interpolateValue) {
                        source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                    }
                    index = offset + match.length;
                    // the JS engine embedded in Adobe products requires returning the `match`
                    // string in order to produce the correct `offset` value
                    return match;
                });
                source += '\';\n';
                // if `variable` is not specified, wrap a with-statement around the generated
                // code to add the data object to the top of the scope chain
                var variable = options.variable, hasVariable = variable;
                if (!hasVariable) {
                    variable = 'obj';
                    source = 'with (' + variable + ') {\n' + source + '\n}\n';
                }
                // cleanup code by stripping empty strings
                source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                // frame code as the function body
                source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + 'var __t, __p = \'\', __e = _.escape' + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
                // Use a sourceURL for easier debugging and wrap in a multi-line comment to
                // avoid issues with Narwhal, IE conditional compilation, and the JS engine
                // embedded in Adobe products.
                // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
                try {
                    var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                } catch (e) {
                    e.source = source;
                    throw e;
                }
                if (data) {
                    return result(data);
                }
                // provide the compiled function's source via its `toString` method, in
                // supported environments, or the `source` property as a convenience for
                // inlining compiled templates during the build process
                result.source = source;
                return result;
            }
            /**
             * Executes the `callback` function `n` times, returning an array of the results
             * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
             * with one argument; (index).
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {Number} n The number of times to execute the callback.
             * @param {Function} callback The function called per iteration.
             * @param {Mixed} [thisArg] The `this` binding of `callback`.
             * @returns {Array} Returns a new array of the results of each `callback` execution.
             * @example
             *
             * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
             * // => [3, 6, 4]
             *
             * _.times(3, function(n) { mage.castSpell(n); });
             * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
             *
             * _.times(3, function(n) { this.cast(n); }, mage);
             * // => also calls `mage.castSpell(n)` three times
             */
            function times(n, callback, thisArg) {
                n = (n = +n) > -1 ? n : 0;
                var index = -1, result = Array(n);
                callback = lodash.createCallback(callback, thisArg, 1);
                while (++index < n) {
                    result[index] = callback(index);
                }
                return result;
            }
            /**
             * The inverse of `_.escape`, this method converts the HTML entities
             * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
             * corresponding characters.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {String} string The string to unescape.
             * @returns {String} Returns the unescaped string.
             * @example
             *
             * _.unescape('Moe, Larry &amp; Curly');
             * // => 'Moe, Larry & Curly'
             */
            function unescape(string) {
                return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
            }
            /**
             * Generates a unique ID. If `prefix` is passed, the ID will be appended to it.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {String} [prefix] The value to prefix the ID with.
             * @returns {String} Returns the unique ID.
             * @example
             *
             * _.uniqueId('contact_');
             * // => 'contact_104'
             *
             * _.uniqueId();
             * // => '105'
             */
            function uniqueId(prefix) {
                var id = ++idCounter;
                return String(prefix == null ? '' : prefix) + id;
            }
            /*--------------------------------------------------------------------------*/
            /**
             * Invokes `interceptor` with the `value` as the first argument, and then
             * returns `value`. The purpose of this method is to "tap into" a method chain,
             * in order to perform operations on intermediate results within the chain.
             *
             * @static
             * @memberOf _
             * @category Chaining
             * @param {Mixed} value The value to pass to `interceptor`.
             * @param {Function} interceptor The function to invoke.
             * @returns {Mixed} Returns `value`.
             * @example
             *
             * _([1, 2, 3, 4])
             *  .filter(function(num) { return num % 2 == 0; })
             *  .tap(alert)
             *  .map(function(num) { return num * num; })
             *  .value();
             * // => // [2, 4] (alerted)
             * // => [4, 16]
             */
            function tap(value, interceptor) {
                interceptor(value);
                return value;
            }
            /**
             * Produces the `toString` result of the wrapped value.
             *
             * @name toString
             * @memberOf _
             * @category Chaining
             * @returns {String} Returns the string result.
             * @example
             *
             * _([1, 2, 3]).toString();
             * // => '1,2,3'
             */
            function wrapperToString() {
                return String(this.__wrapped__);
            }
            /**
             * Extracts the wrapped value.
             *
             * @name valueOf
             * @memberOf _
             * @alias value
             * @category Chaining
             * @returns {Mixed} Returns the wrapped value.
             * @example
             *
             * _([1, 2, 3]).valueOf();
             * // => [1, 2, 3]
             */
            function wrapperValueOf() {
                return this.__wrapped__;
            }
            /*--------------------------------------------------------------------------*/
            // add functions that return wrapped values when chaining
            lodash.after = after;
            lodash.assign = assign;
            lodash.at = at;
            lodash.bind = bind;
            lodash.bindAll = bindAll;
            lodash.bindKey = bindKey;
            lodash.compact = compact;
            lodash.compose = compose;
            lodash.countBy = countBy;
            lodash.createCallback = createCallback;
            lodash.debounce = debounce;
            lodash.defaults = defaults;
            lodash.defer = defer;
            lodash.delay = delay;
            lodash.difference = difference;
            lodash.filter = filter;
            lodash.flatten = flatten;
            lodash.forEach = forEach;
            lodash.forIn = forIn;
            lodash.forOwn = forOwn;
            lodash.functions = functions;
            lodash.groupBy = groupBy;
            lodash.initial = initial;
            lodash.intersection = intersection;
            lodash.invert = invert;
            lodash.invoke = invoke;
            lodash.keys = keys;
            lodash.map = map;
            lodash.max = max;
            lodash.memoize = memoize;
            lodash.merge = merge;
            lodash.min = min;
            lodash.omit = omit;
            lodash.once = once;
            lodash.pairs = pairs;
            lodash.partial = partial;
            lodash.partialRight = partialRight;
            lodash.pick = pick;
            lodash.pluck = pluck;
            lodash.range = range;
            lodash.reject = reject;
            lodash.rest = rest;
            lodash.shuffle = shuffle;
            lodash.sortBy = sortBy;
            lodash.tap = tap;
            lodash.throttle = throttle;
            lodash.times = times;
            lodash.toArray = toArray;
            lodash.transform = transform;
            lodash.union = union;
            lodash.uniq = uniq;
            lodash.unzip = unzip;
            lodash.values = values;
            lodash.where = where;
            lodash.without = without;
            lodash.wrap = wrap;
            lodash.zip = zip;
            lodash.zipObject = zipObject;
            // add aliases
            lodash.collect = map;
            lodash.drop = rest;
            lodash.each = forEach;
            lodash.extend = assign;
            lodash.methods = functions;
            lodash.object = zipObject;
            lodash.select = filter;
            lodash.tail = rest;
            lodash.unique = uniq;
            // add functions to `lodash.prototype`
            mixin(lodash);
            // add Underscore compat
            lodash.chain = lodash;
            lodash.prototype.chain = function () {
                return this;
            };
            /*--------------------------------------------------------------------------*/
            // add functions that return unwrapped values when chaining
            lodash.clone = clone;
            lodash.cloneDeep = cloneDeep;
            lodash.contains = contains;
            lodash.escape = escape;
            lodash.every = every;
            lodash.find = find;
            lodash.findIndex = findIndex;
            lodash.findKey = findKey;
            lodash.has = has;
            lodash.identity = identity;
            lodash.indexOf = indexOf;
            lodash.isArguments = isArguments;
            lodash.isArray = isArray;
            lodash.isBoolean = isBoolean;
            lodash.isDate = isDate;
            lodash.isElement = isElement;
            lodash.isEmpty = isEmpty;
            lodash.isEqual = isEqual;
            lodash.isFinite = isFinite;
            lodash.isFunction = isFunction;
            lodash.isNaN = isNaN;
            lodash.isNull = isNull;
            lodash.isNumber = isNumber;
            lodash.isObject = isObject;
            lodash.isPlainObject = isPlainObject;
            lodash.isRegExp = isRegExp;
            lodash.isString = isString;
            lodash.isUndefined = isUndefined;
            lodash.lastIndexOf = lastIndexOf;
            lodash.mixin = mixin;
            lodash.noConflict = noConflict;
            lodash.parseInt = parseInt;
            lodash.random = random;
            lodash.reduce = reduce;
            lodash.reduceRight = reduceRight;
            lodash.result = result;
            lodash.runInContext = runInContext;
            lodash.size = size;
            lodash.some = some;
            lodash.sortedIndex = sortedIndex;
            lodash.template = template;
            lodash.unescape = unescape;
            lodash.uniqueId = uniqueId;
            // add aliases
            lodash.all = every;
            lodash.any = some;
            lodash.detect = find;
            lodash.findWhere = find;
            lodash.foldl = reduce;
            lodash.foldr = reduceRight;
            lodash.include = contains;
            lodash.inject = reduce;
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    lodash.prototype[methodName] = function () {
                        var args = [this.__wrapped__];
                        push.apply(args, arguments);
                        return func.apply(lodash, args);
                    };
                }
            });
            /*--------------------------------------------------------------------------*/
            // add functions capable of returning wrapped and unwrapped values when chaining
            lodash.first = first;
            lodash.last = last;
            // add aliases
            lodash.take = first;
            lodash.head = first;
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    lodash.prototype[methodName] = function (callback, thisArg) {
                        var result = func(this.__wrapped__, callback, thisArg);
                        return callback == null || thisArg && typeof callback != 'function' ? result : new lodashWrapper(result);
                    };
                }
            });
            /*--------------------------------------------------------------------------*/
            /**
             * The semantic version number.
             *
             * @static
             * @memberOf _
             * @type String
             */
            lodash.VERSION = '1.3.1';
            // add "Chaining" functions to the wrapper
            lodash.prototype.toString = wrapperToString;
            lodash.prototype.value = wrapperValueOf;
            lodash.prototype.valueOf = wrapperValueOf;
            // add `Array` functions that return unwrapped values
            basicEach([
                'join',
                'pop',
                'shift'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    return func.apply(this.__wrapped__, arguments);
                };
            });
            // add `Array` functions that return the wrapped value
            basicEach([
                'push',
                'reverse',
                'sort',
                'unshift'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    func.apply(this.__wrapped__, arguments);
                    return this;
                };
            });
            // add `Array` functions that return new wrapped values
            basicEach([
                'concat',
                'slice',
                'splice'
            ], function (methodName) {
                var func = arrayRef[methodName];
                lodash.prototype[methodName] = function () {
                    return new lodashWrapper(func.apply(this.__wrapped__, arguments));
                };
            });
            // avoid array-like object bugs with `Array#shift` and `Array#splice`
            // in Firefox < 10 and IE < 9
            if (!support.spliceObjects) {
                basicEach([
                    'pop',
                    'shift',
                    'splice'
                ], function (methodName) {
                    var func = arrayRef[methodName], isSplice = methodName == 'splice';
                    lodash.prototype[methodName] = function () {
                        var value = this.__wrapped__, result = func.apply(value, arguments);
                        if (value.length === 0) {
                            delete value[0];
                        }
                        return isSplice ? new lodashWrapper(result) : result;
                    };
                });
            }
            return lodash;
        }
        /*--------------------------------------------------------------------------*/
        // expose Lo-Dash
        var _ = runInContext();
        // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
        if (true) {
            // Expose Lo-Dash to the global object even when an AMD loader is present in
            // case Lo-Dash was injected by a third-party script and not intended to be
            // loaded as a module. The global assignment can be reverted in the Lo-Dash
            // module via its `noConflict()` method.
            window._ = _;    // define as an anonymous module so, through path mapping, it can be
                             // referenced as the "underscore" module
            underscore = function () {
                return _;
            }();
        }    // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && !freeExports.nodeType) {
            // in Node.js or RingoJS v0.8.0+
            if (freeModule) {
                (freeModule.exports = _)._ = _;
            }    // in Narwhal or RingoJS v0.7.0-
            else {
                freeExports._ = _;
            }
        } else {
            // in a browser or Rhino
            window._ = _;
        }
    }(this));
    //     Backbone.js 1.1.0
    //     (c) 2010-2011 Jeremy Ashkenas, DocumentCloud Inc.
    //     (c) 2011-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Backbone may be freely distributed under the MIT license.
    //     For all details and documentation:
    //     http://backbonejs.org
    (function () {
        // Initial Setup
        // -------------
        // Save a reference to the global object (`window` in the browser, `exports`
        // on the server).
        var root = this;
        // Save the previous value of the `Backbone` variable, so that it can be
        // restored later on, if `noConflict` is used.
        var previousBackbone = root.Backbone;
        // Create local references to array methods we'll want to use later.
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
        // The top-level namespace. All public Backbone classes and modules will
        // be attached to this. Exported for both the browser and the server.
        var Backbone;
        if (typeof exports !== 'undefined') {
            Backbone = exports;
        } else {
            Backbone = root.Backbone = {};
        }
        // Current version of the library. Keep in sync with `package.json`.
        Backbone.VERSION = '1.1.0';
        // Require Underscore, if we're on the server, and it's not already present.
        var _ = root._;
        if (!_ && typeof require !== 'undefined')
            _ = underscore;
        // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
        // the `$` variable.
        Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;
        // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
        // to its previous owner. Returns a reference to this Backbone object.
        Backbone.noConflict = function () {
            root.Backbone = previousBackbone;
            return this;
        };
        // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
        // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
        // set a `X-Http-Method-Override` header.
        Backbone.emulateHTTP = false;
        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        Backbone.emulateJSON = false;
        // Backbone.Events
        // ---------------
        // A module that can be mixed in to *any object* in order to provide it with
        // custom events. You may bind with `on` or remove with `off` callback
        // functions to an event; `trigger`-ing an event fires all callbacks in
        // succession.
        //
        //     var object = {};
        //     _.extend(object, Backbone.Events);
        //     object.on('expand', function(){ alert('expanded'); });
        //     object.trigger('expand');
        //
        var Events = Backbone.Events = {
                on: function (name, callback, context) {
                    if (!eventsApi(this, 'on', name, [
                            callback,
                            context
                        ]) || !callback)
                        return this;
                    this._events || (this._events = {});
                    var events = this._events[name] || (this._events[name] = []);
                    events.push({
                        callback: callback,
                        context: context,
                        ctx: context || this
                    });
                    return this;
                },
                once: function (name, callback, context) {
                    if (!eventsApi(this, 'once', name, [
                            callback,
                            context
                        ]) || !callback)
                        return this;
                    var self = this;
                    var once = _.once(function () {
                            self.off(name, once);
                            callback.apply(this, arguments);
                        });
                    once._callback = callback;
                    return this.on(name, once, context);
                },
                off: function (name, callback, context) {
                    var retain, ev, events, names, i, l, j, k;
                    if (!this._events || !eventsApi(this, 'off', name, [
                            callback,
                            context
                        ]))
                        return this;
                    if (!name && !callback && !context) {
                        this._events = {};
                        return this;
                    }
                    names = name ? [name] : _.keys(this._events);
                    for (i = 0, l = names.length; i < l; i++) {
                        name = names[i];
                        if (events = this._events[name]) {
                            this._events[name] = retain = [];
                            if (callback || context) {
                                for (j = 0, k = events.length; j < k; j++) {
                                    ev = events[j];
                                    if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                        retain.push(ev);
                                    }
                                }
                            }
                            if (!retain.length)
                                delete this._events[name];
                        }
                    }
                    return this;
                },
                trigger: function (name) {
                    if (!this._events)
                        return this;
                    var args = slice.call(arguments, 1);
                    if (!eventsApi(this, 'trigger', name, args))
                        return this;
                    var events = this._events[name];
                    var allEvents = this._events.all;
                    if (events)
                        triggerEvents(events, args);
                    if (allEvents)
                        triggerEvents(allEvents, arguments);
                    return this;
                },
                stopListening: function (obj, name, callback) {
                    var listeningTo = this._listeningTo;
                    if (!listeningTo)
                        return this;
                    var remove = !name && !callback;
                    if (!callback && typeof name === 'object')
                        callback = this;
                    if (obj)
                        (listeningTo = {})[obj._listenId] = obj;
                    for (var id in listeningTo) {
                        obj = listeningTo[id];
                        obj.off(name, callback, this);
                        if (remove || _.isEmpty(obj._events))
                            delete this._listeningTo[id];
                    }
                    return this;
                }
            };
        // Regular expression used to split event strings.
        var eventSplitter = /\s+/;
        // Implement fancy features of the Events API such as multiple event
        // names `"change blur"` and jQuery-style event maps `{change: action}`
        // in terms of the existing API.
        var eventsApi = function (obj, action, name, rest) {
            if (!name)
                return true;
            // Handle event maps.
            if (typeof name === 'object') {
                for (var key in name) {
                    obj[action].apply(obj, [
                        key,
                        name[key]
                    ].concat(rest));
                }
                return false;
            }
            // Handle space separated event names.
            if (eventSplitter.test(name)) {
                var names = name.split(eventSplitter);
                for (var i = 0, l = names.length; i < l; i++) {
                    obj[action].apply(obj, [names[i]].concat(rest));
                }
                return false;
            }
            return true;
        };
        // A difficult-to-believe, but optimized internal dispatch function for
        // triggering events. Tries to keep the usual cases speedy (most internal
        // Backbone events have 3 arguments).
        var triggerEvents = function (events, args) {
            var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
            switch (args.length) {
            case 0:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx);
                return;
            case 1:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1);
                return;
            case 2:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;
            case 3:
                while (++i < l)
                    (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;
            default:
                while (++i < l)
                    (ev = events[i]).callback.apply(ev.ctx, args);
            }
        };
        var listenMethods = {
                listenTo: 'on',
                listenToOnce: 'once'
            };
        // Inversion-of-control versions of `on` and `once`. Tell *this* object to
        // listen to an event in another object ... keeping track of what it's
        // listening to.
        _.each(listenMethods, function (implementation, method) {
            Events[method] = function (obj, name, callback) {
                var listeningTo = this._listeningTo || (this._listeningTo = {});
                var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
                listeningTo[id] = obj;
                if (!callback && typeof name === 'object')
                    callback = this;
                obj[implementation](name, callback, this);
                return this;
            };
        });
        // Aliases for backwards compatibility.
        Events.bind = Events.on;
        Events.unbind = Events.off;
        // Allow the `Backbone` object to serve as a global event bus, for folks who
        // want global "pubsub" in a convenient place.
        _.extend(Backbone, Events);
        // Backbone.Model
        // --------------
        // Backbone **Models** are the basic data object in the framework --
        // frequently representing a row in a table in a database on your server.
        // A discrete chunk of data and a bunch of useful, related methods for
        // performing computations and transformations on that data.
        // Create a new model with the specified attributes. A client id (`cid`)
        // is automatically generated and assigned for you.
        var Model = Backbone.Model = function (attributes, options) {
                var attrs = attributes || {};
                options || (options = {});
                this.cid = _.uniqueId('c');
                this.attributes = {};
                if (options.collection)
                    this.collection = options.collection;
                if (options.parse)
                    attrs = this.parse(attrs, options) || {};
                attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
                this.set(attrs, options);
                this.changed = {};
                this.initialize.apply(this, arguments);
            };
        // Attach all inheritable methods to the Model prototype.
        _.extend(Model.prototype, Events, {
            changed: null,
            validationError: null,
            idAttribute: 'id',
            initialize: function () {
            },
            toJSON: function (options) {
                return _.clone(this.attributes);
            },
            sync: function () {
                return Backbone.sync.apply(this, arguments);
            },
            get: function (attr) {
                return this.attributes[attr];
            },
            escape: function (attr) {
                return _.escape(this.get(attr));
            },
            has: function (attr) {
                return this.get(attr) != null;
            },
            set: function (key, val, options) {
                var attr, attrs, unset, changes, silent, changing, prev, current;
                if (key == null)
                    return this;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (typeof key === 'object') {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options || (options = {});
                // Run validation.
                if (!this._validate(attrs, options))
                    return false;
                // Extract attributes and options.
                unset = options.unset;
                silent = options.silent;
                changes = [];
                changing = this._changing;
                this._changing = true;
                if (!changing) {
                    this._previousAttributes = _.clone(this.attributes);
                    this.changed = {};
                }
                current = this.attributes, prev = this._previousAttributes;
                // Check for changes of `id`.
                if (this.idAttribute in attrs)
                    this.id = attrs[this.idAttribute];
                // For each `set` attribute, update or delete the current value.
                for (attr in attrs) {
                    val = attrs[attr];
                    if (!_.isEqual(current[attr], val))
                        changes.push(attr);
                    if (!_.isEqual(prev[attr], val)) {
                        this.changed[attr] = val;
                    } else {
                        delete this.changed[attr];
                    }
                    unset ? delete current[attr] : current[attr] = val;
                }
                // Trigger all relevant attribute changes.
                if (!silent) {
                    if (changes.length)
                        this._pending = true;
                    for (var i = 0, l = changes.length; i < l; i++) {
                        this.trigger('change:' + changes[i], this, current[changes[i]], options);
                    }
                }
                // You might be wondering why there's a `while` loop here. Changes can
                // be recursively nested within `"change"` events.
                if (changing)
                    return this;
                if (!silent) {
                    while (this._pending) {
                        this._pending = false;
                        this.trigger('change', this, options);
                    }
                }
                this._pending = false;
                this._changing = false;
                return this;
            },
            unset: function (attr, options) {
                return this.set(attr, void 0, _.extend({}, options, { unset: true }));
            },
            clear: function (options) {
                var attrs = {};
                for (var key in this.attributes)
                    attrs[key] = void 0;
                return this.set(attrs, _.extend({}, options, { unset: true }));
            },
            hasChanged: function (attr) {
                if (attr == null)
                    return !_.isEmpty(this.changed);
                return _.has(this.changed, attr);
            },
            changedAttributes: function (diff) {
                if (!diff)
                    return this.hasChanged() ? _.clone(this.changed) : false;
                var val, changed = false;
                var old = this._changing ? this._previousAttributes : this.attributes;
                for (var attr in diff) {
                    if (_.isEqual(old[attr], val = diff[attr]))
                        continue;
                    (changed || (changed = {}))[attr] = val;
                }
                return changed;
            },
            previous: function (attr) {
                if (attr == null || !this._previousAttributes)
                    return null;
                return this._previousAttributes[attr];
            },
            previousAttributes: function () {
                return _.clone(this._previousAttributes);
            },
            fetch: function (options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0)
                    options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function (resp) {
                    if (!model.set(model.parse(resp, options), options))
                        return false;
                    if (success)
                        success(model, resp, options);
                    model.trigger('sync', model, resp, options);
                };
                wrapError(this, options);
                return this.sync('read', this, options);
            },
            save: function (key, val, options) {
                var attrs, method, xhr, attributes = this.attributes;
                // Handle both `"key", value` and `{key: value}` -style arguments.
                if (key == null || typeof key === 'object') {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options = _.extend({ validate: true }, options);
                // If we're not waiting and attributes exist, save acts as
                // `set(attr).save(null, opts)` with validation. Otherwise, check if
                // the model will be valid when the attributes, if any, are set.
                if (attrs && !options.wait) {
                    if (!this.set(attrs, options))
                        return false;
                } else {
                    if (!this._validate(attrs, options))
                        return false;
                }
                // Set temporary attributes if `{wait: true}`.
                if (attrs && options.wait) {
                    this.attributes = _.extend({}, attributes, attrs);
                }
                // After a successful server-side save, the client is (optionally)
                // updated with the server-side state.
                if (options.parse === void 0)
                    options.parse = true;
                var model = this;
                var success = options.success;
                options.success = function (resp) {
                    // Ensure attributes are restored during synchronous saves.
                    model.attributes = attributes;
                    var serverAttrs = model.parse(resp, options);
                    if (options.wait)
                        serverAttrs = _.extend(attrs || {}, serverAttrs);
                    if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                        return false;
                    }
                    if (success)
                        success(model, resp, options);
                    model.trigger('sync', model, resp, options);
                };
                wrapError(this, options);
                method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
                if (method === 'patch')
                    options.attrs = attrs;
                xhr = this.sync(method, this, options);
                // Restore attributes.
                if (attrs && options.wait)
                    this.attributes = attributes;
                return xhr;
            },
            destroy: function (options) {
                options = options ? _.clone(options) : {};
                var model = this;
                var success = options.success;
                var destroy = function () {
                    model.trigger('destroy', model, model.collection, options);
                };
                options.success = function (resp) {
                    if (options.wait || model.isNew())
                        destroy();
                    if (success)
                        success(model, resp, options);
                    if (!model.isNew())
                        model.trigger('sync', model, resp, options);
                };
                if (this.isNew()) {
                    options.success();
                    return false;
                }
                wrapError(this, options);
                var xhr = this.sync('delete', this, options);
                if (!options.wait)
                    destroy();
                return xhr;
            },
            url: function () {
                var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
                if (this.isNew())
                    return base;
                return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
            },
            parse: function (resp, options) {
                return resp;
            },
            clone: function () {
                return new this.constructor(this.attributes);
            },
            isNew: function () {
                return this.id == null;
            },
            isValid: function (options) {
                return this._validate({}, _.extend(options || {}, { validate: true }));
            },
            _validate: function (attrs, options) {
                if (!options.validate || !this.validate)
                    return true;
                attrs = _.extend({}, this.attributes, attrs);
                var error = this.validationError = this.validate(attrs, options) || null;
                if (!error)
                    return true;
                this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
                return false;
            }
        });
        // Underscore methods that we want to implement on the Model.
        var modelMethods = [
                'keys',
                'values',
                'pairs',
                'invert',
                'pick',
                'omit'
            ];
        // Mix in each Underscore method as a proxy to `Model#attributes`.
        _.each(modelMethods, function (method) {
            Model.prototype[method] = function () {
                var args = slice.call(arguments);
                args.unshift(this.attributes);
                return _[method].apply(_, args);
            };
        });
        // Backbone.Collection
        // -------------------
        // If models tend to represent a single row of data, a Backbone Collection is
        // more analagous to a table full of data ... or a small slice or page of that
        // table, or a collection of rows that belong together for a particular reason
        // -- all of the messages in this particular folder, all of the documents
        // belonging to this particular author, and so on. Collections maintain
        // indexes of their models, both in order, and for lookup by `id`.
        // Create a new **Collection**, perhaps to contain a specific type of `model`.
        // If a `comparator` is specified, the Collection will maintain
        // its models in sort order, as they're added and removed.
        var Collection = Backbone.Collection = function (models, options) {
                options || (options = {});
                if (options.model)
                    this.model = options.model;
                if (options.comparator !== void 0)
                    this.comparator = options.comparator;
                this._reset();
                this.initialize.apply(this, arguments);
                if (models)
                    this.reset(models, _.extend({ silent: true }, options));
            };
        // Default options for `Collection#set`.
        var setOptions = {
                add: true,
                remove: true,
                merge: true
            };
        var addOptions = {
                add: true,
                remove: false
            };
        // Define the Collection's inheritable methods.
        _.extend(Collection.prototype, Events, {
            model: Model,
            initialize: function () {
            },
            toJSON: function (options) {
                return this.map(function (model) {
                    return model.toJSON(options);
                });
            },
            sync: function () {
                return Backbone.sync.apply(this, arguments);
            },
            add: function (models, options) {
                return this.set(models, _.extend({ merge: false }, options, addOptions));
            },
            remove: function (models, options) {
                var singular = !_.isArray(models);
                models = singular ? [models] : _.clone(models);
                options || (options = {});
                var i, l, index, model;
                for (i = 0, l = models.length; i < l; i++) {
                    model = models[i] = this.get(models[i]);
                    if (!model)
                        continue;
                    delete this._byId[model.id];
                    delete this._byId[model.cid];
                    index = this.indexOf(model);
                    this.models.splice(index, 1);
                    this.length--;
                    if (!options.silent) {
                        options.index = index;
                        model.trigger('remove', model, this, options);
                    }
                    this._removeReference(model);
                }
                return singular ? models[0] : models;
            },
            set: function (models, options) {
                options = _.defaults({}, options, setOptions);
                if (options.parse)
                    models = this.parse(models, options);
                var singular = !_.isArray(models);
                models = singular ? models ? [models] : [] : _.clone(models);
                var i, l, id, model, attrs, existing, sort;
                var at = options.at;
                var targetModel = this.model;
                var sortable = this.comparator && at == null && options.sort !== false;
                var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                var toAdd = [], toRemove = [], modelMap = {};
                var add = options.add, merge = options.merge, remove = options.remove;
                var order = !sortable && add && remove ? [] : false;
                // Turn bare objects into model references, and prevent invalid models
                // from being added.
                for (i = 0, l = models.length; i < l; i++) {
                    attrs = models[i];
                    if (attrs instanceof Model) {
                        id = model = attrs;
                    } else {
                        id = attrs[targetModel.prototype.idAttribute];
                    }
                    // If a duplicate is found, prevent it from being added and
                    // optionally merge it into the existing model.
                    if (existing = this.get(id)) {
                        if (remove)
                            modelMap[existing.cid] = true;
                        if (merge) {
                            attrs = attrs === model ? model.attributes : attrs;
                            if (options.parse)
                                attrs = existing.parse(attrs, options);
                            existing.set(attrs, options);
                            if (sortable && !sort && existing.hasChanged(sortAttr))
                                sort = true;
                        }
                        models[i] = existing;    // If this is a new, valid model, push it to the `toAdd` list.
                    } else if (add) {
                        model = models[i] = this._prepareModel(attrs, options);
                        if (!model)
                            continue;
                        toAdd.push(model);
                        // Listen to added models' events, and index models for lookup by
                        // `id` and by `cid`.
                        model.on('all', this._onModelEvent, this);
                        this._byId[model.cid] = model;
                        if (model.id != null)
                            this._byId[model.id] = model;
                    }
                    if (order)
                        order.push(existing || model);
                }
                // Remove nonexistent models if appropriate.
                if (remove) {
                    for (i = 0, l = this.length; i < l; ++i) {
                        if (!modelMap[(model = this.models[i]).cid])
                            toRemove.push(model);
                    }
                    if (toRemove.length)
                        this.remove(toRemove, options);
                }
                // See if sorting is needed, update `length` and splice in new models.
                if (toAdd.length || order && order.length) {
                    if (sortable)
                        sort = true;
                    this.length += toAdd.length;
                    if (at != null) {
                        for (i = 0, l = toAdd.length; i < l; i++) {
                            this.models.splice(at + i, 0, toAdd[i]);
                        }
                    } else {
                        if (order)
                            this.models.length = 0;
                        var orderedModels = order || toAdd;
                        for (i = 0, l = orderedModels.length; i < l; i++) {
                            this.models.push(orderedModels[i]);
                        }
                    }
                }
                // Silently sort the collection if appropriate.
                if (sort)
                    this.sort({ silent: true });
                // Unless silenced, it's time to fire all appropriate add/sort events.
                if (!options.silent) {
                    for (i = 0, l = toAdd.length; i < l; i++) {
                        (model = toAdd[i]).trigger('add', model, this, options);
                    }
                    if (sort || order && order.length)
                        this.trigger('sort', this, options);
                }
                // Return the added (or merged) model (or models).
                return singular ? models[0] : models;
            },
            reset: function (models, options) {
                options || (options = {});
                for (var i = 0, l = this.models.length; i < l; i++) {
                    this._removeReference(this.models[i]);
                }
                options.previousModels = this.models;
                this._reset();
                models = this.add(models, _.extend({ silent: true }, options));
                if (!options.silent)
                    this.trigger('reset', this, options);
                return models;
            },
            push: function (model, options) {
                return this.add(model, _.extend({ at: this.length }, options));
            },
            pop: function (options) {
                var model = this.at(this.length - 1);
                this.remove(model, options);
                return model;
            },
            unshift: function (model, options) {
                return this.add(model, _.extend({ at: 0 }, options));
            },
            shift: function (options) {
                var model = this.at(0);
                this.remove(model, options);
                return model;
            },
            slice: function () {
                return slice.apply(this.models, arguments);
            },
            get: function (obj) {
                if (obj == null)
                    return void 0;
                return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
            },
            at: function (index) {
                return this.models[index];
            },
            where: function (attrs, first) {
                if (_.isEmpty(attrs))
                    return first ? void 0 : [];
                return this[first ? 'find' : 'filter'](function (model) {
                    for (var key in attrs) {
                        if (attrs[key] !== model.get(key))
                            return false;
                    }
                    return true;
                });
            },
            findWhere: function (attrs) {
                return this.where(attrs, true);
            },
            sort: function (options) {
                if (!this.comparator)
                    throw new Error('Cannot sort a set without a comparator');
                options || (options = {});
                // Run sort based on type of `comparator`.
                if (_.isString(this.comparator) || this.comparator.length === 1) {
                    this.models = this.sortBy(this.comparator, this);
                } else {
                    this.models.sort(_.bind(this.comparator, this));
                }
                if (!options.silent)
                    this.trigger('sort', this, options);
                return this;
            },
            pluck: function (attr) {
                return _.invoke(this.models, 'get', attr);
            },
            fetch: function (options) {
                options = options ? _.clone(options) : {};
                if (options.parse === void 0)
                    options.parse = true;
                var success = options.success;
                var collection = this;
                options.success = function (resp) {
                    var method = options.reset ? 'reset' : 'set';
                    collection[method](resp, options);
                    if (success)
                        success(collection, resp, options);
                    collection.trigger('sync', collection, resp, options);
                };
                wrapError(this, options);
                return this.sync('read', this, options);
            },
            create: function (model, options) {
                options = options ? _.clone(options) : {};
                if (!(model = this._prepareModel(model, options)))
                    return false;
                if (!options.wait)
                    this.add(model, options);
                var collection = this;
                var success = options.success;
                options.success = function (model, resp, options) {
                    if (options.wait)
                        collection.add(model, options);
                    if (success)
                        success(model, resp, options);
                };
                model.save(null, options);
                return model;
            },
            parse: function (resp, options) {
                return resp;
            },
            clone: function () {
                return new this.constructor(this.models);
            },
            _reset: function () {
                this.length = 0;
                this.models = [];
                this._byId = {};
            },
            _prepareModel: function (attrs, options) {
                if (attrs instanceof Model) {
                    if (!attrs.collection)
                        attrs.collection = this;
                    return attrs;
                }
                options = options ? _.clone(options) : {};
                options.collection = this;
                var model = new this.model(attrs, options);
                if (!model.validationError)
                    return model;
                this.trigger('invalid', this, model.validationError, options);
                return false;
            },
            _removeReference: function (model) {
                if (this === model.collection)
                    delete model.collection;
                model.off('all', this._onModelEvent, this);
            },
            _onModelEvent: function (event, model, collection, options) {
                if ((event === 'add' || event === 'remove') && collection !== this)
                    return;
                if (event === 'destroy')
                    this.remove(model, options);
                if (model && event === 'change:' + model.idAttribute) {
                    delete this._byId[model.previous(model.idAttribute)];
                    if (model.id != null)
                        this._byId[model.id] = model;
                }
                this.trigger.apply(this, arguments);
            }
        });
        // Underscore methods that we want to implement on the Collection.
        // 90% of the core usefulness of Backbone Collections is actually implemented
        // right here:
        var methods = [
                'forEach',
                'each',
                'map',
                'collect',
                'reduce',
                'foldl',
                'inject',
                'reduceRight',
                'foldr',
                'find',
                'detect',
                'filter',
                'select',
                'reject',
                'every',
                'all',
                'some',
                'any',
                'include',
                'contains',
                'invoke',
                'max',
                'min',
                'toArray',
                'size',
                'first',
                'head',
                'take',
                'initial',
                'rest',
                'tail',
                'drop',
                'last',
                'without',
                'difference',
                'indexOf',
                'shuffle',
                'lastIndexOf',
                'isEmpty',
                'chain'
            ];
        // Mix in each Underscore method as a proxy to `Collection#models`.
        _.each(methods, function (method) {
            Collection.prototype[method] = function () {
                var args = slice.call(arguments);
                args.unshift(this.models);
                return _[method].apply(_, args);
            };
        });
        // Underscore methods that take a property name as an argument.
        var attributeMethods = [
                'groupBy',
                'countBy',
                'sortBy'
            ];
        // Use attributes instead of properties.
        _.each(attributeMethods, function (method) {
            Collection.prototype[method] = function (value, context) {
                var iterator = _.isFunction(value) ? value : function (model) {
                        return model.get(value);
                    };
                return _[method](this.models, iterator, context);
            };
        });
        // Backbone.View
        // -------------
        // Backbone Views are almost more convention than they are actual code. A View
        // is simply a JavaScript object that represents a logical chunk of UI in the
        // DOM. This might be a single item, an entire list, a sidebar or panel, or
        // even the surrounding frame which wraps your whole app. Defining a chunk of
        // UI as a **View** allows you to define your DOM events declaratively, without
        // having to worry about render order ... and makes it easy for the view to
        // react to specific changes in the state of your models.
        // Creating a Backbone.View creates its initial element outside of the DOM,
        // if an existing element is not provided...
        var View = Backbone.View = function (options) {
                this.cid = _.uniqueId('view');
                options || (options = {});
                _.extend(this, _.pick(options, viewOptions));
                this._ensureElement();
                this.initialize.apply(this, arguments);
                this.delegateEvents();
            };
        // Cached regex to split keys for `delegate`.
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
        // List of view options to be merged as properties.
        var viewOptions = [
                'model',
                'collection',
                'el',
                'id',
                'attributes',
                'className',
                'tagName',
                'events'
            ];
        // Set up all inheritable **Backbone.View** properties and methods.
        _.extend(View.prototype, Events, {
            tagName: 'div',
            $: function (selector) {
                return this.$el.find(selector);
            },
            initialize: function () {
            },
            render: function () {
                return this;
            },
            remove: function () {
                this.$el.remove();
                this.stopListening();
                return this;
            },
            setElement: function (element, delegate) {
                if (this.$el)
                    this.undelegateEvents();
                this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                this.el = this.$el[0];
                if (delegate !== false)
                    this.delegateEvents();
                return this;
            },
            delegateEvents: function (events) {
                if (!(events || (events = _.result(this, 'events'))))
                    return this;
                this.undelegateEvents();
                for (var key in events) {
                    var method = events[key];
                    if (!_.isFunction(method))
                        method = this[events[key]];
                    if (!method)
                        continue;
                    var match = key.match(delegateEventSplitter);
                    var eventName = match[1], selector = match[2];
                    method = _.bind(method, this);
                    eventName += '.delegateEvents' + this.cid;
                    if (selector === '') {
                        this.$el.on(eventName, method);
                    } else {
                        this.$el.on(eventName, selector, method);
                    }
                }
                return this;
            },
            undelegateEvents: function () {
                this.$el.off('.delegateEvents' + this.cid);
                return this;
            },
            _ensureElement: function () {
                if (!this.el) {
                    var attrs = _.extend({}, _.result(this, 'attributes'));
                    if (this.id)
                        attrs.id = _.result(this, 'id');
                    if (this.className)
                        attrs['class'] = _.result(this, 'className');
                    var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
                    this.setElement($el, false);
                } else {
                    this.setElement(_.result(this, 'el'), false);
                }
            }
        });
        // Backbone.sync
        // -------------
        // Override this function to change the manner in which Backbone persists
        // models to the server. You will be passed the type of request, and the
        // model in question. By default, makes a RESTful Ajax request
        // to the model's `url()`. Some possible customizations could be:
        //
        // * Use `setTimeout` to batch rapid-fire updates into a single request.
        // * Send up the models as XML instead of JSON.
        // * Persist models via WebSockets instead of Ajax.
        //
        // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
        // as `POST`, with a `_method` parameter containing the true HTTP method,
        // as well as all requests with the body as `application/x-www-form-urlencoded`
        // instead of `application/json` with the model in a param named `model`.
        // Useful when interfacing with server-side languages like **PHP** that make
        // it difficult to read the body of `PUT` requests.
        Backbone.sync = function (method, model, options) {
            var type = methodMap[method];
            // Default options, unless specified.
            _.defaults(options || (options = {}), {
                emulateHTTP: Backbone.emulateHTTP,
                emulateJSON: Backbone.emulateJSON
            });
            // Default JSON-request options.
            var params = {
                    type: type,
                    dataType: 'json'
                };
            // Ensure that we have a URL.
            if (!options.url) {
                params.url = _.result(model, 'url') || urlError();
            }
            // Ensure that we have the appropriate request data.
            if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
                params.contentType = 'application/json';
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            // For older servers, emulate JSON by encoding the request into an HTML-form.
            if (options.emulateJSON) {
                params.contentType = 'application/x-www-form-urlencoded';
                params.data = params.data ? { model: params.data } : {};
            }
            // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
            // And an `X-HTTP-Method-Override` header.
            if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
                params.type = 'POST';
                if (options.emulateJSON)
                    params.data._method = type;
                var beforeSend = options.beforeSend;
                options.beforeSend = function (xhr) {
                    xhr.setRequestHeader('X-HTTP-Method-Override', type);
                    if (beforeSend)
                        return beforeSend.apply(this, arguments);
                };
            }
            // Don't process data on a non-GET request.
            if (params.type !== 'GET' && !options.emulateJSON) {
                params.processData = false;
            }
            // If we're sending a `PATCH` request, and we're in an old Internet Explorer
            // that still has ActiveX enabled by default, override jQuery to use that
            // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
            if (params.type === 'PATCH' && noXhrPatch) {
                params.xhr = function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                };
            }
            // Make the request, allowing the user to override any Ajax options.
            var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
            model.trigger('request', model, xhr, options);
            return xhr;
        };
        var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent);
        // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
        var methodMap = {
                'create': 'POST',
                'update': 'PUT',
                'patch': 'PATCH',
                'delete': 'DELETE',
                'read': 'GET'
            };
        // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
        // Override this if you'd like to use a different library.
        Backbone.ajax = function () {
            return Backbone.$.ajax.apply(Backbone.$, arguments);
        };
        // Backbone.Router
        // ---------------
        // Routers map faux-URLs to actions, and fire events when routes are
        // matched. Creating a new one sets its `routes` hash, if not set statically.
        var Router = Backbone.Router = function (options) {
                options || (options = {});
                if (options.routes)
                    this.routes = options.routes;
                this._bindRoutes();
                this.initialize.apply(this, arguments);
            };
        // Cached regular expressions for matching named param parts and splatted
        // parts of route strings.
        var optionalParam = /\((.*?)\)/g;
        var namedParam = /(\(\?)?:\w+/g;
        var splatParam = /\*\w+/g;
        var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
        // Set up all inheritable **Backbone.Router** properties and methods.
        _.extend(Router.prototype, Events, {
            initialize: function () {
            },
            route: function (route, name, callback) {
                if (!_.isRegExp(route))
                    route = this._routeToRegExp(route);
                if (_.isFunction(name)) {
                    callback = name;
                    name = '';
                }
                if (!callback)
                    callback = this[name];
                var router = this;
                Backbone.history.route(route, function (fragment) {
                    var args = router._extractParameters(route, fragment);
                    callback && callback.apply(router, args);
                    router.trigger.apply(router, ['route:' + name].concat(args));
                    router.trigger('route', name, args);
                    Backbone.history.trigger('route', router, name, args);
                });
                return this;
            },
            navigate: function (fragment, options) {
                Backbone.history.navigate(fragment, options);
                return this;
            },
            _bindRoutes: function () {
                if (!this.routes)
                    return;
                this.routes = _.result(this, 'routes');
                var route, routes = _.keys(this.routes);
                while ((route = routes.pop()) != null) {
                    this.route(route, this.routes[route]);
                }
            },
            _routeToRegExp: function (route) {
                route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
                    return optional ? match : '([^/]+)';
                }).replace(splatParam, '(.*?)');
                return new RegExp('^' + route + '$');
            },
            _extractParameters: function (route, fragment) {
                var params = route.exec(fragment).slice(1);
                return _.map(params, function (param) {
                    return param ? decodeURIComponent(param) : null;
                });
            }
        });
        // Backbone.History
        // ----------------
        // Handles cross-browser history management, based on either
        // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
        // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
        // and URL fragments. If the browser supports neither (old IE, natch),
        // falls back to polling.
        var History = Backbone.History = function () {
                this.handlers = [];
                _.bindAll(this, 'checkUrl');
                // Ensure that `History` can be used outside of the browser.
                if (typeof window !== 'undefined') {
                    this.location = window.location;
                    this.history = window.history;
                }
            };
        // Cached regex for stripping a leading hash/slash and trailing space.
        var routeStripper = /^[#\/]|\s+$/g;
        // Cached regex for stripping leading and trailing slashes.
        var rootStripper = /^\/+|\/+$/g;
        // Cached regex for detecting MSIE.
        var isExplorer = /msie [\w.]+/;
        // Cached regex for removing a trailing slash.
        var trailingSlash = /\/$/;
        // Cached regex for stripping urls of hash and query.
        var pathStripper = /[?#].*$/;
        // Has the history handling already been started?
        History.started = false;
        // Set up all inheritable **Backbone.History** properties and methods.
        _.extend(History.prototype, Events, {
            interval: 50,
            getHash: function (window) {
                var match = (window || this).location.href.match(/#(.*)$/);
                return match ? match[1] : '';
            },
            getFragment: function (fragment, forcePushState) {
                if (fragment == null) {
                    if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                        fragment = this.location.pathname;
                        var root = this.root.replace(trailingSlash, '');
                        if (!fragment.indexOf(root))
                            fragment = fragment.slice(root.length);
                    } else {
                        fragment = this.getHash();
                    }
                }
                return fragment.replace(routeStripper, '');
            },
            start: function (options) {
                if (History.started)
                    throw new Error('Backbone.history has already been started');
                History.started = true;
                // Figure out the initial configuration. Do we need an iframe?
                // Is pushState desired ... is it available?
                this.options = _.extend({ root: '/' }, this.options, options);
                this.root = this.options.root;
                this._wantsHashChange = this.options.hashChange !== false;
                this._wantsPushState = !!this.options.pushState;
                this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
                var fragment = this.getFragment();
                var docMode = document.documentMode;
                var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
                // Normalize root to always include a leading and trailing slash.
                this.root = ('/' + this.root + '/').replace(rootStripper, '/');
                if (oldIE && this._wantsHashChange) {
                    this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
                    this.navigate(fragment);
                }
                // Depending on whether we're using pushState or hashes, and whether
                // 'onhashchange' is supported, determine how we check the URL state.
                if (this._hasPushState) {
                    Backbone.$(window).on('popstate', this.checkUrl);
                } else if (this._wantsHashChange && 'onhashchange' in window && !oldIE) {
                    Backbone.$(window).on('hashchange', this.checkUrl);
                } else if (this._wantsHashChange) {
                    this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                }
                // Determine if we need to change the base url, for a pushState link
                // opened by a non-pushState browser.
                this.fragment = fragment;
                var loc = this.location;
                var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;
                // Transition from hashChange to pushState or vice versa if both are
                // requested.
                if (this._wantsHashChange && this._wantsPushState) {
                    // If we've started off with a route from a `pushState`-enabled
                    // browser, but we're currently in a browser that doesn't support it...
                    if (!this._hasPushState && !atRoot) {
                        this.fragment = this.getFragment(null, true);
                        this.location.replace(this.root + this.location.search + '#' + this.fragment);
                        // Return immediately as browser will do redirect to new url
                        return true;    // Or if we've started out with a hash-based route, but we're currently
                                        // in a browser where it could be `pushState`-based instead...
                    } else if (this._hasPushState && atRoot && loc.hash) {
                        this.fragment = this.getHash().replace(routeStripper, '');
                        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
                    }
                }
                if (!this.options.silent)
                    return this.loadUrl();
            },
            stop: function () {
                Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
                clearInterval(this._checkUrlInterval);
                History.started = false;
            },
            route: function (route, callback) {
                this.handlers.unshift({
                    route: route,
                    callback: callback
                });
            },
            checkUrl: function (e) {
                var current = this.getFragment();
                if (current === this.fragment && this.iframe) {
                    current = this.getFragment(this.getHash(this.iframe));
                }
                if (current === this.fragment)
                    return false;
                if (this.iframe)
                    this.navigate(current);
                this.loadUrl();
            },
            loadUrl: function (fragment) {
                fragment = this.fragment = this.getFragment(fragment);
                return _.any(this.handlers, function (handler) {
                    if (handler.route.test(fragment)) {
                        handler.callback(fragment);
                        return true;
                    }
                });
            },
            navigate: function (fragment, options) {
                if (!History.started)
                    return false;
                if (!options || options === true)
                    options = { trigger: !!options };
                var url = this.root + (fragment = this.getFragment(fragment || ''));
                // Strip the fragment of the query and hash for matching.
                fragment = fragment.replace(pathStripper, '');
                if (this.fragment === fragment)
                    return;
                this.fragment = fragment;
                // Don't include a trailing slash on the root.
                if (fragment === '' && url !== '/')
                    url = url.slice(0, -1);
                // If pushState is available, we use it to set the fragment as a real URL.
                if (this._hasPushState) {
                    this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);    // If hash changes haven't been explicitly disabled, update the hash
                                                                                                              // fragment to store history.
                } else if (this._wantsHashChange) {
                    this._updateHash(this.location, fragment, options.replace);
                    if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                        // Opening and closing the iframe tricks IE7 and earlier to push a
                        // history entry on hash-tag change.  When replace is true, we don't
                        // want this.
                        if (!options.replace)
                            this.iframe.document.open().close();
                        this._updateHash(this.iframe.location, fragment, options.replace);
                    }    // If you've told us that you explicitly don't want fallback hashchange-
                         // based history, then `navigate` becomes a page refresh.
                } else {
                    return this.location.assign(url);
                }
                if (options.trigger)
                    return this.loadUrl(fragment);
            },
            _updateHash: function (location, fragment, replace) {
                if (replace) {
                    var href = location.href.replace(/(javascript:|#).*$/, '');
                    location.replace(href + '#' + fragment);
                } else {
                    // Some browsers require that `hash` contains a leading #.
                    location.hash = '#' + fragment;
                }
            }
        });
        // Create the default Backbone.history.
        Backbone.history = new History();
        // Helpers
        // -------
        // Helper function to correctly set up the prototype chain, for subclasses.
        // Similar to `goog.inherits`, but uses a hash of prototype properties and
        // class properties to be extended.
        var extend = function (protoProps, staticProps) {
            var parent = this;
            var child;
            // The constructor function for the new subclass is either defined by you
            // (the "constructor" property in your `extend` definition), or defaulted
            // by us to simply call the parent's constructor.
            if (protoProps && _.has(protoProps, 'constructor')) {
                child = protoProps.constructor;
            } else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            // Add static properties to the constructor function, if supplied.
            _.extend(child, parent, staticProps);
            // Set the prototype chain to inherit from `parent`, without calling
            // `parent`'s constructor function.
            var Surrogate = function () {
                this.constructor = child;
            };
            Surrogate.prototype = parent.prototype;
            child.prototype = new Surrogate();
            // Add prototype properties (instance properties) to the subclass,
            // if supplied.
            if (protoProps)
                _.extend(child.prototype, protoProps);
            // Set a convenience property in case the parent's prototype is needed
            // later.
            child.__super__ = parent.prototype;
            return child;
        };
        // Set up inheritance for the model, collection, router, view and history.
        Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
        // Throw an error when a URL is needed, and none is supplied.
        var urlError = function () {
            throw new Error('A "url" property or function must be specified');
        };
        // Wrap an optional error callback with a fallback error event.
        var wrapError = function (model, options) {
            var error = options.error;
            options.error = function (resp) {
                if (error)
                    error(model, resp, options);
                model.trigger('error', model, resp, options);
            };
        };
    }.call(this));
    backbone = window.Backbone;
    /*
      Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
      Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
      Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
      Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
      Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
      Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
      Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
      Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    /*jslint bitwise:true plusplus:true */
    /*global esprima:true, define:true, exports:true, window: true,
    createLocationMarker: true,
    throwError: true, generateStatement: true, peek: true,
    parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
    parseFunctionDeclaration: true, parseFunctionExpression: true,
    parseFunctionSourceElements: true, parseVariableIdentifier: true,
    parseLeftHandSideExpression: true,
    parseUnaryExpression: true,
    parseStatement: true, parseSourceElement: true */
    (function (root, factory) {
        'use strict';
        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
        // Rhino, and plain browser loading.
        if (true) {
            esprima = function () {
                return factory();
            }({});
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory(root.esprima = {});
        }
    }(this, function (exports) {
        exports = exports || {};
        'use strict';
        var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;
        Token = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
        };
        TokenName = {};
        TokenName[Token.BooleanLiteral] = 'Boolean';
        TokenName[Token.EOF] = '<end>';
        TokenName[Token.Identifier] = 'Identifier';
        TokenName[Token.Keyword] = 'Keyword';
        TokenName[Token.NullLiteral] = 'Null';
        TokenName[Token.NumericLiteral] = 'Numeric';
        TokenName[Token.Punctuator] = 'Punctuator';
        TokenName[Token.StringLiteral] = 'String';
        TokenName[Token.RegularExpression] = 'RegularExpression';
        // A function following one of those tokens is an expression.
        FnExprTokens = [
            '(',
            '{',
            '[',
            'in',
            'typeof',
            'instanceof',
            'new',
            'return',
            'case',
            'delete',
            'throw',
            'void',
            '=',
            '+=',
            '-=',
            '*=',
            '/=',
            '%=',
            '<<=',
            '>>=',
            '>>>=',
            '&=',
            '|=',
            '^=',
            ',',
            '+',
            '-',
            '*',
            '/',
            '%',
            '++',
            '--',
            '<<',
            '>>',
            '>>>',
            '&',
            '|',
            '^',
            '!',
            '~',
            '&&',
            '||',
            '?',
            ':',
            '===',
            '==',
            '>=',
            '<=',
            '<',
            '>',
            '!=',
            '!=='
        ];
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            ArrayExpression: 'ArrayExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DoWhileStatement: 'DoWhileStatement',
            DebuggerStatement: 'DebuggerStatement',
            EmptyStatement: 'EmptyStatement',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            Program: 'Program',
            Property: 'Property',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement'
        };
        PropertyKind = {
            Data: 1,
            Get: 2,
            Set: 4
        };
        // Error messages should be identical to V8.
        Messages = {
            UnexpectedToken: 'Unexpected token %0',
            UnexpectedNumber: 'Unexpected number',
            UnexpectedString: 'Unexpected string',
            UnexpectedIdentifier: 'Unexpected identifier',
            UnexpectedReserved: 'Unexpected reserved word',
            UnexpectedEOS: 'Unexpected end of input',
            NewlineAfterThrow: 'Illegal newline after throw',
            InvalidRegExp: 'Invalid regular expression',
            UnterminatedRegExp: 'Invalid regular expression: missing /',
            InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
            InvalidLHSInForIn: 'Invalid left-hand side in for-in',
            MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
            NoCatchOrFinally: 'Missing catch or finally after try',
            UnknownLabel: 'Undefined label \'%0\'',
            Redeclaration: '%0 \'%1\' has already been declared',
            IllegalContinue: 'Illegal continue statement',
            IllegalBreak: 'Illegal break statement',
            IllegalReturn: 'Illegal return statement',
            StrictModeWith: 'Strict mode code may not include a with statement',
            StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
            StrictVarName: 'Variable name may not be eval or arguments in strict mode',
            StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
            StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
            StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
            StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
            StrictDelete: 'Delete of an unqualified identifier in strict mode.',
            StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
            AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
            AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
            StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
            StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
            StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
            StrictReservedWord: 'Use of future reserved word in strict mode'
        };
        // See also tools/generate-unicode-regex.py.
        Regex = {
            NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
            NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
        };
        // Ensure the condition is true, otherwise throw an error.
        // This is only to have a better contract semantic, i.e. another safety net
        // to catch a logic error. The condition shall be fulfilled in normal case.
        // Do NOT use this to enforce a certain condition on any user input.
        function assert(condition, message) {
            if (!condition) {
                throw new Error('ASSERT: ' + message);
            }
        }
        function isDecimalDigit(ch) {
            return ch >= 48 && ch <= 57;    // 0..9
        }
        function isHexDigit(ch) {
            return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
        }
        function isOctalDigit(ch) {
            return '01234567'.indexOf(ch) >= 0;
        }
        // 7.2 White Space
        function isWhiteSpace(ch) {
            return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
                5760,
                6158,
                8192,
                8193,
                8194,
                8195,
                8196,
                8197,
                8198,
                8199,
                8200,
                8201,
                8202,
                8239,
                8287,
                12288,
                65279
            ].indexOf(ch) >= 0;
        }
        // 7.3 Line Terminators
        function isLineTerminator(ch) {
            return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
        }
        // 7.6 Identifier Names and Identifiers
        function isIdentifierStart(ch) {
            return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
        }
        function isIdentifierPart(ch) {
            return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
        }
        // 7.6.1.2 Future Reserved Words
        function isFutureReservedWord(id) {
            switch (id) {
            case 'class':
            case 'enum':
            case 'export':
            case 'extends':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
            }
        }
        function isStrictModeReservedWord(id) {
            switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
            }
        }
        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }
        // 7.6.1.1 Keywords
        function isKeyword(id) {
            if (strict && isStrictModeReservedWord(id)) {
                return true;
            }
            // 'const' is specialized as Keyword in V8.
            // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
            // Some others are from future reserved words.
            switch (id.length) {
            case 2:
                return id === 'if' || id === 'in' || id === 'do';
            case 3:
                return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
            case 4:
                return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
            case 5:
                return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
            case 6:
                return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
            case 7:
                return id === 'default' || id === 'finally' || id === 'extends';
            case 8:
                return id === 'function' || id === 'continue' || id === 'debugger';
            case 10:
                return id === 'instanceof';
            default:
                return false;
            }
        }
        // 7.4 Comments
        function addComment(type, value, start, end, loc) {
            var comment, attacher;
            assert(typeof start === 'number', 'Comment must have valid position');
            // Because the way the actual token is scanned, often the comments
            // (if any) are skipped twice during the lexical analysis.
            // Thus, we need to skip adding a comment if the comment array already
            // handled it.
            if (state.lastCommentStart >= start) {
                return;
            }
            state.lastCommentStart = start;
            comment = {
                type: type,
                value: value
            };
            if (extra.range) {
                comment.range = [
                    start,
                    end
                ];
            }
            if (extra.loc) {
                comment.loc = loc;
            }
            extra.comments.push(comment);
            if (extra.attachComment) {
                attacher = {
                    comment: comment,
                    leading: null,
                    trailing: null,
                    range: [
                        start,
                        end
                    ]
                };
                extra.pendingComments.push(attacher);
            }
        }
        function skipSingleLineComment() {
            var start, loc, ch, comment;
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
            while (index < length) {
                ch = source.charCodeAt(index);
                ++index;
                if (isLineTerminator(ch)) {
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 1);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart - 1
                        };
                        addComment('Line', comment, start, index - 1, loc);
                    }
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    return;
                }
            }
            if (extra.comments) {
                comment = source.slice(start + 2, index);
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                addComment('Line', comment, start, index, loc);
            }
        }
        function skipMultiLineComment() {
            var start, loc, ch, comment;
            if (extra.comments) {
                start = index - 2;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart - 2
                    }
                };
            }
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isLineTerminator(ch)) {
                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else if (ch === 42) {
                    // Block comment ends with '*/' (char #42, char #47).
                    if (source.charCodeAt(index + 1) === 47) {
                        ++index;
                        ++index;
                        if (extra.comments) {
                            comment = source.slice(start + 2, index - 2);
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                        }
                        return;
                    }
                    ++index;
                } else {
                    ++index;
                }
            }
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        function skipComment() {
            var ch, start;
            start = index === 0;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isWhiteSpace(ch)) {
                    ++index;
                } else if (isLineTerminator(ch)) {
                    ++index;
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    start = true;
                } else if (ch === 47) {
                    // 47 is '/'
                    ch = source.charCodeAt(index + 1);
                    if (ch === 47) {
                        ++index;
                        ++index;
                        skipSingleLineComment();
                        start = true;
                    } else if (ch === 42) {
                        // 42 is '*'
                        ++index;
                        ++index;
                        skipMultiLineComment();
                    } else {
                        break;
                    }
                } else if (start && ch === 45) {
                    // 45 is '-'
                    // 62 is '>'
                    if (source.charCodeAt(index + 1) === 45 && source.charCodeAt(index + 2) === 62) {
                        // '-->' is a single-line comment
                        index += 3;
                        skipSingleLineComment();
                    } else {
                        break;
                    }
                } else if (ch === 60) {
                    // 60 is '<'
                    if (source.slice(index + 1, index + 4) === '!--') {
                        ++index;
                        // `<`
                        ++index;
                        // `!`
                        ++index;
                        // `-`
                        ++index;
                        // `-`
                        skipSingleLineComment();
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
        function scanHexEscape(prefix) {
            var i, len, ch, code = 0;
            len = prefix === 'u' ? 4 : 2;
            for (i = 0; i < len; ++i) {
                if (index < length && isHexDigit(source[index])) {
                    ch = source[index++];
                    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                } else {
                    return '';
                }
            }
            return String.fromCharCode(code);
        }
        function getEscapedIdentifier() {
            var ch, id;
            ch = source.charCodeAt(index++);
            id = String.fromCharCode(ch);
            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id = ch;
            }
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!isIdentifierPart(ch)) {
                    break;
                }
                ++index;
                id += String.fromCharCode(ch);
                // '\u' (char #92, char #117) denotes an escaped character.
                if (ch === 92) {
                    id = id.substr(0, id.length - 1);
                    if (source.charCodeAt(index) !== 117) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    ++index;
                    ch = scanHexEscape('u');
                    if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    id += ch;
                }
            }
            return id;
        }
        function getIdentifier() {
            var start, ch;
            start = index++;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (ch === 92) {
                    // Blackslash (char #92) marks Unicode escape sequence.
                    index = start;
                    return getEscapedIdentifier();
                }
                if (isIdentifierPart(ch)) {
                    ++index;
                } else {
                    break;
                }
            }
            return source.slice(start, index);
        }
        function scanIdentifier() {
            var start, id, type;
            start = index;
            // Backslash (char #92) starts an escaped character.
            id = source.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
            // There is no keyword or literal with only one character.
            // Thus, it must be an identifier.
            if (id.length === 1) {
                type = Token.Identifier;
            } else if (isKeyword(id)) {
                type = Token.Keyword;
            } else if (id === 'null') {
                type = Token.NullLiteral;
            } else if (id === 'true' || id === 'false') {
                type = Token.BooleanLiteral;
            } else {
                type = Token.Identifier;
            }
            return {
                type: type,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        // 7.7 Punctuators
        function scanPunctuator() {
            var start = index, code = source.charCodeAt(index), code2, ch1 = source[index], ch2, ch3, ch4;
            switch (code) {
            // Check for most common single-character punctuators.
            case 46:
            // . dot
            case 40:
            // ( open bracket
            case 41:
            // ) close bracket
            case 59:
            // ; semicolon
            case 44:
            // , comma
            case 123:
            // { open curly brace
            case 125:
            // } close curly brace
            case 91:
            // [
            case 93:
            // ]
            case 58:
            // :
            case 63:
            // ?
            case 126:
                // ~
                ++index;
                if (extra.tokenize) {
                    if (code === 40) {
                        extra.openParenToken = extra.tokens.length;
                    } else if (code === 123) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            default:
                code2 = source.charCodeAt(index + 1);
                // '=' (char #61) marks an assignment or comparison operator.
                if (code2 === 61) {
                    switch (code) {
                    case 37:
                    // %
                    case 38:
                    // &
                    case 42:
                    // *:
                    case 43:
                    // +
                    case 45:
                    // -
                    case 47:
                    // /
                    case 60:
                    // <
                    case 62:
                    // >
                    case 94:
                    // ^
                    case 124:
                        // |
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: String.fromCharCode(code) + String.fromCharCode(code2),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [
                                start,
                                index
                            ]
                        };
                    case 33:
                    // !
                    case 61:
                        // =
                        index += 2;
                        // !== and ===
                        if (source.charCodeAt(index) === 61) {
                            ++index;
                        }
                        return {
                            type: Token.Punctuator,
                            value: source.slice(start, index),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [
                                start,
                                index
                            ]
                        };
                    default:
                        break;
                    }
                }
                break;
            }
            // Peek more characters.
            ch2 = source[index + 1];
            ch3 = source[index + 2];
            ch4 = source[index + 3];
            // 4-character punctuator: >>>=
            if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
                if (ch4 === '=') {
                    index += 4;
                    return {
                        type: Token.Punctuator,
                        value: '>>>=',
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [
                            start,
                            index
                        ]
                    };
                }
            }
            // 3-character punctuators: === !== >>> <<= >>=
            if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>>',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '<<=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            // Other 2-character punctuators: ++ -- << >> && ||
            if (ch1 === ch2 && '+-<>&|'.indexOf(ch1) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                ++index;
                return {
                    type: Token.Punctuator,
                    value: ch1,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
        // 7.8.3 Numeric Literals
        function scanHexLiteral(start) {
            var number = '';
            while (index < length) {
                if (!isHexDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
            if (number.length === 0) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseInt('0x' + number, 16),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanOctalLiteral(start) {
            var number = '0' + source[index++];
            while (index < length) {
                if (!isOctalDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
            if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 8),
                octal: true,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanNumericLiteral() {
            var number, start, ch;
            ch = source[index];
            assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
            start = index;
            number = '';
            if (ch !== '.') {
                number = source[index++];
                ch = source[index];
                // Hex number starts with '0x'.
                // Octal number starts with '0'.
                if (number === '0') {
                    if (ch === 'x' || ch === 'X') {
                        ++index;
                        return scanHexLiteral(start);
                    }
                    if (isOctalDigit(ch)) {
                        return scanOctalLiteral(start);
                    }
                    // decimal number starts with '0' such as '09' is illegal.
                    if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                }
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
            if (ch === '.') {
                number += source[index++];
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
            if (ch === 'e' || ch === 'E') {
                number += source[index++];
                ch = source[index];
                if (ch === '+' || ch === '-') {
                    number += source[index++];
                }
                if (isDecimalDigit(source.charCodeAt(index))) {
                    while (isDecimalDigit(source.charCodeAt(index))) {
                        number += source[index++];
                    }
                } else {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.NumericLiteral,
                value: parseFloat(number),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        // 7.8.4 String Literals
        function scanStringLiteral() {
            var str = '', quote, start, ch, code, unescaped, restore, octal = false;
            quote = source[index];
            assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
            start = index;
            ++index;
            while (index < length) {
                ch = source[index++];
                if (ch === quote) {
                    quote = '';
                    break;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'u':
                        case 'x':
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);
                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }
                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            } else {
                                str += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    break;
                } else {
                    str += ch;
                }
            }
            if (quote !== '') {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            return {
                type: Token.StringLiteral,
                value: str,
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [
                    start,
                    index
                ]
            };
        }
        function scanRegExp() {
            var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;
            lookahead = null;
            skipComment();
            start = index;
            ch = source[index];
            assert(ch === '/', 'Regular expression literal must start with a slash');
            str = source[index++];
            while (index < length) {
                ch = source[index++];
                str += ch;
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                } else if (classMarker) {
                    if (ch === ']') {
                        classMarker = false;
                    }
                } else {
                    if (ch === '/') {
                        terminated = true;
                        break;
                    } else if (ch === '[') {
                        classMarker = true;
                    }
                }
            }
            if (!terminated) {
                throwError({}, Messages.UnterminatedRegExp);
            }
            // Exclude leading and trailing slash.
            pattern = str.substr(1, str.length - 2);
            flags = '';
            while (index < length) {
                ch = source[index];
                if (!isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                }
                ++index;
                if (ch === '\\' && index < length) {
                    ch = source[index];
                    if (ch === 'u') {
                        ++index;
                        restore = index;
                        ch = scanHexEscape('u');
                        if (ch) {
                            flags += ch;
                            for (str += '\\u'; restore < index; ++restore) {
                                str += source[restore];
                            }
                        } else {
                            index = restore;
                            flags += 'u';
                            str += '\\u';
                        }
                    } else {
                        str += '\\';
                    }
                } else {
                    flags += ch;
                    str += ch;
                }
            }
            try {
                value = new RegExp(pattern, flags);
            } catch (e) {
                throwError({}, Messages.InvalidRegExp);
            }
            peek();
            if (extra.tokenize) {
                return {
                    type: Token.RegularExpression,
                    value: value,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        start,
                        index
                    ]
                };
            }
            return {
                literal: str,
                value: value,
                range: [
                    start,
                    index
                ]
            };
        }
        function collectRegex() {
            var pos, loc, regex, token;
            skipComment();
            pos = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            regex = scanRegExp();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            if (!extra.tokenize) {
                // Pop the previous token, which is likely '/' or '/='
                if (extra.tokens.length > 0) {
                    token = extra.tokens[extra.tokens.length - 1];
                    if (token.range[0] === pos && token.type === 'Punctuator') {
                        if (token.value === '/' || token.value === '/=') {
                            extra.tokens.pop();
                        }
                    }
                }
                extra.tokens.push({
                    type: 'RegularExpression',
                    value: regex.literal,
                    range: [
                        pos,
                        index
                    ],
                    loc: loc
                });
            }
            return regex;
        }
        function isIdentifierName(token) {
            return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
        }
        function advanceSlash() {
            var prevToken, checkToken;
            // Using the following algorithm:
            // https://github.com/mozilla/sweet.js/wiki/design
            prevToken = extra.tokens[extra.tokens.length - 1];
            if (!prevToken) {
                // Nothing before that: it cannot be a division.
                return collectRegex();
            }
            if (prevToken.type === 'Punctuator') {
                if (prevToken.value === ')') {
                    checkToken = extra.tokens[extra.openParenToken - 1];
                    if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {
                        return collectRegex();
                    }
                    return scanPunctuator();
                }
                if (prevToken.value === '}') {
                    // Dividing a function by anything makes little sense,
                    // but we have to check for that.
                    if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                        // Anonymous function.
                        checkToken = extra.tokens[extra.openCurlyToken - 4];
                        if (!checkToken) {
                            return scanPunctuator();
                        }
                    } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                        // Named function.
                        checkToken = extra.tokens[extra.openCurlyToken - 5];
                        if (!checkToken) {
                            return collectRegex();
                        }
                    } else {
                        return scanPunctuator();
                    }
                    // checkToken determines whether the function is
                    // a declaration or an expression.
                    if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                        // It is an expression.
                        return scanPunctuator();
                    }
                    // It is a declaration.
                    return collectRegex();
                }
                return collectRegex();
            }
            if (prevToken.type === 'Keyword') {
                return collectRegex();
            }
            return scanPunctuator();
        }
        function advance() {
            var ch;
            skipComment();
            if (index >= length) {
                return {
                    type: Token.EOF,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [
                        index,
                        index
                    ]
                };
            }
            ch = source.charCodeAt(index);
            // Very common: ( and ) and ;
            if (ch === 40 || ch === 41 || ch === 58) {
                return scanPunctuator();
            }
            // String literal starts with single quote (#39) or double quote (#34).
            if (ch === 39 || ch === 34) {
                return scanStringLiteral();
            }
            if (isIdentifierStart(ch)) {
                return scanIdentifier();
            }
            // Dot (.) char #46 can also start a floating-point number, hence the need
            // to check the next character.
            if (ch === 46) {
                if (isDecimalDigit(source.charCodeAt(index + 1))) {
                    return scanNumericLiteral();
                }
                return scanPunctuator();
            }
            if (isDecimalDigit(ch)) {
                return scanNumericLiteral();
            }
            // Slash (/) char #47 can also start a regex.
            if (extra.tokenize && ch === 47) {
                return advanceSlash();
            }
            return scanPunctuator();
        }
        function collectToken() {
            var start, loc, token, range, value;
            skipComment();
            start = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
            token = advance();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            if (token.type !== Token.EOF) {
                range = [
                    token.range[0],
                    token.range[1]
                ];
                value = source.slice(token.range[0], token.range[1]);
                extra.tokens.push({
                    type: TokenName[token.type],
                    value: value,
                    range: range,
                    loc: loc
                });
            }
            return token;
        }
        function lex() {
            var token;
            token = lookahead;
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
            return token;
        }
        function peek() {
            var pos, line, start;
            pos = index;
            line = lineNumber;
            start = lineStart;
            lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();
            index = pos;
            lineNumber = line;
            lineStart = start;
        }
        SyntaxTreeDelegate = {
            name: 'SyntaxTree',
            markStart: function () {
                if (extra.loc) {
                    state.markerStack.push(index - lineStart);
                    state.markerStack.push(lineNumber);
                }
                if (extra.range) {
                    state.markerStack.push(index);
                }
            },
            processComment: function (node) {
                var i, attacher, pos, len, candidate;
                if (typeof node.type === 'undefined' || node.type === Syntax.Program) {
                    return;
                }
                // Check for possible additional trailing comments.
                peek();
                for (i = 0; i < extra.pendingComments.length; ++i) {
                    attacher = extra.pendingComments[i];
                    if (node.range[0] >= attacher.comment.range[1]) {
                        candidate = attacher.leading;
                        if (candidate) {
                            pos = candidate.range[0];
                            len = candidate.range[1] - pos;
                            if (node.range[0] <= pos && node.range[1] - node.range[0] >= len) {
                                attacher.leading = node;
                            }
                        } else {
                            attacher.leading = node;
                        }
                    }
                    if (node.range[1] <= attacher.comment.range[0]) {
                        candidate = attacher.trailing;
                        if (candidate) {
                            pos = candidate.range[0];
                            len = candidate.range[1] - pos;
                            if (node.range[0] <= pos && node.range[1] - node.range[0] >= len) {
                                attacher.trailing = node;
                            }
                        } else {
                            attacher.trailing = node;
                        }
                    }
                }
            },
            markEnd: function (node) {
                if (extra.range) {
                    node.range = [
                        state.markerStack.pop(),
                        index
                    ];
                }
                if (extra.loc) {
                    node.loc = {
                        start: {
                            line: state.markerStack.pop(),
                            column: state.markerStack.pop()
                        },
                        end: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    this.postProcess(node);
                }
                if (extra.attachComment) {
                    this.processComment(node);
                }
                return node;
            },
            markEndIf: function (node) {
                if (node.range || node.loc) {
                    if (extra.loc) {
                        state.markerStack.pop();
                        state.markerStack.pop();
                    }
                    if (extra.range) {
                        state.markerStack.pop();
                    }
                } else {
                    this.markEnd(node);
                }
                return node;
            },
            postProcess: function (node) {
                if (extra.source) {
                    node.loc.source = extra.source;
                }
                return node;
            },
            createArrayExpression: function (elements) {
                return {
                    type: Syntax.ArrayExpression,
                    elements: elements
                };
            },
            createAssignmentExpression: function (operator, left, right) {
                return {
                    type: Syntax.AssignmentExpression,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
            createBinaryExpression: function (operator, left, right) {
                var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;
                return {
                    type: type,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
            createBlockStatement: function (body) {
                return {
                    type: Syntax.BlockStatement,
                    body: body
                };
            },
            createBreakStatement: function (label) {
                return {
                    type: Syntax.BreakStatement,
                    label: label
                };
            },
            createCallExpression: function (callee, args) {
                return {
                    type: Syntax.CallExpression,
                    callee: callee,
                    'arguments': args
                };
            },
            createCatchClause: function (param, body) {
                return {
                    type: Syntax.CatchClause,
                    param: param,
                    body: body
                };
            },
            createConditionalExpression: function (test, consequent, alternate) {
                return {
                    type: Syntax.ConditionalExpression,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
            createContinueStatement: function (label) {
                return {
                    type: Syntax.ContinueStatement,
                    label: label
                };
            },
            createDebuggerStatement: function () {
                return { type: Syntax.DebuggerStatement };
            },
            createDoWhileStatement: function (body, test) {
                return {
                    type: Syntax.DoWhileStatement,
                    body: body,
                    test: test
                };
            },
            createEmptyStatement: function () {
                return { type: Syntax.EmptyStatement };
            },
            createExpressionStatement: function (expression) {
                return {
                    type: Syntax.ExpressionStatement,
                    expression: expression
                };
            },
            createForStatement: function (init, test, update, body) {
                return {
                    type: Syntax.ForStatement,
                    init: init,
                    test: test,
                    update: update,
                    body: body
                };
            },
            createForInStatement: function (left, right, body) {
                return {
                    type: Syntax.ForInStatement,
                    left: left,
                    right: right,
                    body: body,
                    each: false
                };
            },
            createFunctionDeclaration: function (id, params, defaults, body) {
                return {
                    type: Syntax.FunctionDeclaration,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            },
            createFunctionExpression: function (id, params, defaults, body) {
                return {
                    type: Syntax.FunctionExpression,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            },
            createIdentifier: function (name) {
                return {
                    type: Syntax.Identifier,
                    name: name
                };
            },
            createIfStatement: function (test, consequent, alternate) {
                return {
                    type: Syntax.IfStatement,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
            createLabeledStatement: function (label, body) {
                return {
                    type: Syntax.LabeledStatement,
                    label: label,
                    body: body
                };
            },
            createLiteral: function (token) {
                return {
                    type: Syntax.Literal,
                    value: token.value,
                    raw: source.slice(token.range[0], token.range[1])
                };
            },
            createMemberExpression: function (accessor, object, property) {
                return {
                    type: Syntax.MemberExpression,
                    computed: accessor === '[',
                    object: object,
                    property: property
                };
            },
            createNewExpression: function (callee, args) {
                return {
                    type: Syntax.NewExpression,
                    callee: callee,
                    'arguments': args
                };
            },
            createObjectExpression: function (properties) {
                return {
                    type: Syntax.ObjectExpression,
                    properties: properties
                };
            },
            createPostfixExpression: function (operator, argument) {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: false
                };
            },
            createProgram: function (body) {
                return {
                    type: Syntax.Program,
                    body: body
                };
            },
            createProperty: function (kind, key, value) {
                return {
                    type: Syntax.Property,
                    key: key,
                    value: value,
                    kind: kind
                };
            },
            createReturnStatement: function (argument) {
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            },
            createSequenceExpression: function (expressions) {
                return {
                    type: Syntax.SequenceExpression,
                    expressions: expressions
                };
            },
            createSwitchCase: function (test, consequent) {
                return {
                    type: Syntax.SwitchCase,
                    test: test,
                    consequent: consequent
                };
            },
            createSwitchStatement: function (discriminant, cases) {
                return {
                    type: Syntax.SwitchStatement,
                    discriminant: discriminant,
                    cases: cases
                };
            },
            createThisExpression: function () {
                return { type: Syntax.ThisExpression };
            },
            createThrowStatement: function (argument) {
                return {
                    type: Syntax.ThrowStatement,
                    argument: argument
                };
            },
            createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
                return {
                    type: Syntax.TryStatement,
                    block: block,
                    guardedHandlers: guardedHandlers,
                    handlers: handlers,
                    finalizer: finalizer
                };
            },
            createUnaryExpression: function (operator, argument) {
                if (operator === '++' || operator === '--') {
                    return {
                        type: Syntax.UpdateExpression,
                        operator: operator,
                        argument: argument,
                        prefix: true
                    };
                }
                return {
                    type: Syntax.UnaryExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            },
            createVariableDeclaration: function (declarations, kind) {
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: declarations,
                    kind: kind
                };
            },
            createVariableDeclarator: function (id, init) {
                return {
                    type: Syntax.VariableDeclarator,
                    id: id,
                    init: init
                };
            },
            createWhileStatement: function (test, body) {
                return {
                    type: Syntax.WhileStatement,
                    test: test,
                    body: body
                };
            },
            createWithStatement: function (object, body) {
                return {
                    type: Syntax.WithStatement,
                    object: object,
                    body: body
                };
            }
        };
        // Return true if there is a line terminator before the next token.
        function peekLineTerminator() {
            var pos, line, start, found;
            pos = index;
            line = lineNumber;
            start = lineStart;
            skipComment();
            found = lineNumber !== line;
            index = pos;
            lineNumber = line;
            lineStart = start;
            return found;
        }
        // Throw an exception
        function throwError(token, messageFormat) {
            var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                });
            if (typeof token.lineNumber === 'number') {
                error = new Error('Line ' + token.lineNumber + ': ' + msg);
                error.index = token.range[0];
                error.lineNumber = token.lineNumber;
                error.column = token.range[0] - lineStart + 1;
            } else {
                error = new Error('Line ' + lineNumber + ': ' + msg);
                error.index = index;
                error.lineNumber = lineNumber;
                error.column = index - lineStart + 1;
            }
            error.description = msg;
            throw error;
        }
        function throwErrorTolerant() {
            try {
                throwError.apply(null, arguments);
            } catch (e) {
                if (extra.errors) {
                    extra.errors.push(e);
                } else {
                    throw e;
                }
            }
        }
        // Throw an exception because of the token.
        function throwUnexpected(token) {
            if (token.type === Token.EOF) {
                throwError(token, Messages.UnexpectedEOS);
            }
            if (token.type === Token.NumericLiteral) {
                throwError(token, Messages.UnexpectedNumber);
            }
            if (token.type === Token.StringLiteral) {
                throwError(token, Messages.UnexpectedString);
            }
            if (token.type === Token.Identifier) {
                throwError(token, Messages.UnexpectedIdentifier);
            }
            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    throwError(token, Messages.UnexpectedReserved);
                } else if (strict && isStrictModeReservedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictReservedWord);
                    return;
                }
                throwError(token, Messages.UnexpectedToken, token.value);
            }
            // BooleanLiteral, NullLiteral, or Punctuator.
            throwError(token, Messages.UnexpectedToken, token.value);
        }
        // Expect the next token to match the specified punctuator.
        // If not, an exception will be thrown.
        function expect(value) {
            var token = lex();
            if (token.type !== Token.Punctuator || token.value !== value) {
                throwUnexpected(token);
            }
        }
        // Expect the next token to match the specified keyword.
        // If not, an exception will be thrown.
        function expectKeyword(keyword) {
            var token = lex();
            if (token.type !== Token.Keyword || token.value !== keyword) {
                throwUnexpected(token);
            }
        }
        // Return true if the next token matches the specified punctuator.
        function match(value) {
            return lookahead.type === Token.Punctuator && lookahead.value === value;
        }
        // Return true if the next token matches the specified keyword
        function matchKeyword(keyword) {
            return lookahead.type === Token.Keyword && lookahead.value === keyword;
        }
        // Return true if the next token is an assignment operator
        function matchAssign() {
            var op;
            if (lookahead.type !== Token.Punctuator) {
                return false;
            }
            op = lookahead.value;
            return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
        }
        function consumeSemicolon() {
            var line;
            // Catch the very common case first: immediately a semicolon (char #59).
            if (source.charCodeAt(index) === 59) {
                lex();
                return;
            }
            line = lineNumber;
            skipComment();
            if (lineNumber !== line) {
                return;
            }
            if (match(';')) {
                lex();
                return;
            }
            if (lookahead.type !== Token.EOF && !match('}')) {
                throwUnexpected(lookahead);
            }
        }
        // Return true if provided expression is LeftHandSideExpression
        function isLeftHandSide(expr) {
            return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
        }
        // 11.1.4 Array Initialiser
        function parseArrayInitialiser() {
            var elements = [];
            expect('[');
            while (!match(']')) {
                if (match(',')) {
                    lex();
                    elements.push(null);
                } else {
                    elements.push(parseAssignmentExpression());
                    if (!match(']')) {
                        expect(',');
                    }
                }
            }
            expect(']');
            return delegate.createArrayExpression(elements);
        }
        // 11.1.5 Object Initialiser
        function parsePropertyFunction(param, first) {
            var previousStrict, body;
            previousStrict = strict;
            skipComment();
            delegate.markStart();
            body = parseFunctionSourceElements();
            if (first && strict && isRestrictedWord(param[0].name)) {
                throwErrorTolerant(first, Messages.StrictParamName);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));
        }
        function parseObjectPropertyKey() {
            var token;
            skipComment();
            delegate.markStart();
            token = lex();
            // Note: This function is called only from parseObjectProperty(), where
            // EOF and Punctuator tokens are already filtered out.
            if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
                if (strict && token.octal) {
                    throwErrorTolerant(token, Messages.StrictOctalLiteral);
                }
                return delegate.markEnd(delegate.createLiteral(token));
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseObjectProperty() {
            var token, key, id, value, param;
            token = lookahead;
            skipComment();
            delegate.markStart();
            if (token.type === Token.Identifier) {
                id = parseObjectPropertyKey();
                // Property Assignment: Getter and Setter.
                if (token.value === 'get' && !match(':')) {
                    key = parseObjectPropertyKey();
                    expect('(');
                    expect(')');
                    value = parsePropertyFunction([]);
                    return delegate.markEnd(delegate.createProperty('get', key, value));
                }
                if (token.value === 'set' && !match(':')) {
                    key = parseObjectPropertyKey();
                    expect('(');
                    token = lookahead;
                    if (token.type !== Token.Identifier) {
                        expect(')');
                        throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                        value = parsePropertyFunction([]);
                    } else {
                        param = [parseVariableIdentifier()];
                        expect(')');
                        value = parsePropertyFunction(param, token);
                    }
                    return delegate.markEnd(delegate.createProperty('set', key, value));
                }
                expect(':');
                value = parseAssignmentExpression();
                return delegate.markEnd(delegate.createProperty('init', id, value));
            }
            if (token.type === Token.EOF || token.type === Token.Punctuator) {
                throwUnexpected(token);
            } else {
                key = parseObjectPropertyKey();
                expect(':');
                value = parseAssignmentExpression();
                return delegate.markEnd(delegate.createProperty('init', key, value));
            }
        }
        function parseObjectInitialiser() {
            var properties = [], property, name, key, kind, map = {}, toString = String;
            expect('{');
            while (!match('}')) {
                property = parseObjectProperty();
                if (property.key.type === Syntax.Identifier) {
                    name = property.key.name;
                } else {
                    name = toString(property.key.value);
                }
                kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;
                key = '$' + name;
                if (Object.prototype.hasOwnProperty.call(map, key)) {
                    if (map[key] === PropertyKind.Data) {
                        if (strict && kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                        } else if (kind !== PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        }
                    } else {
                        if (kind === PropertyKind.Data) {
                            throwErrorTolerant({}, Messages.AccessorDataProperty);
                        } else if (map[key] & kind) {
                            throwErrorTolerant({}, Messages.AccessorGetSet);
                        }
                    }
                    map[key] |= kind;
                } else {
                    map[key] = kind;
                }
                properties.push(property);
                if (!match('}')) {
                    expect(',');
                }
            }
            expect('}');
            return delegate.createObjectExpression(properties);
        }
        // 11.1.6 The Grouping Operator
        function parseGroupExpression() {
            var expr;
            expect('(');
            expr = parseExpression();
            expect(')');
            return expr;
        }
        // 11.1 Primary Expressions
        function parsePrimaryExpression() {
            var type, token, expr;
            if (match('(')) {
                return parseGroupExpression();
            }
            type = lookahead.type;
            delegate.markStart();
            if (type === Token.Identifier) {
                expr = delegate.createIdentifier(lex().value);
            } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                if (strict && lookahead.octal) {
                    throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
                }
                expr = delegate.createLiteral(lex());
            } else if (type === Token.Keyword) {
                if (matchKeyword('this')) {
                    lex();
                    expr = delegate.createThisExpression();
                } else if (matchKeyword('function')) {
                    expr = parseFunctionExpression();
                }
            } else if (type === Token.BooleanLiteral) {
                token = lex();
                token.value = token.value === 'true';
                expr = delegate.createLiteral(token);
            } else if (type === Token.NullLiteral) {
                token = lex();
                token.value = null;
                expr = delegate.createLiteral(token);
            } else if (match('[')) {
                expr = parseArrayInitialiser();
            } else if (match('{')) {
                expr = parseObjectInitialiser();
            } else if (match('/') || match('/=')) {
                if (typeof extra.tokens !== 'undefined') {
                    expr = delegate.createLiteral(collectRegex());
                } else {
                    expr = delegate.createLiteral(scanRegExp());
                }
            }
            if (expr) {
                return delegate.markEnd(expr);
            }
            throwUnexpected(lex());
        }
        // 11.2 Left-Hand-Side Expressions
        function parseArguments() {
            var args = [];
            expect('(');
            if (!match(')')) {
                while (index < length) {
                    args.push(parseAssignmentExpression());
                    if (match(')')) {
                        break;
                    }
                    expect(',');
                }
            }
            expect(')');
            return args;
        }
        function parseNonComputedProperty() {
            var token;
            delegate.markStart();
            token = lex();
            if (!isIdentifierName(token)) {
                throwUnexpected(token);
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseNonComputedMember() {
            expect('.');
            return parseNonComputedProperty();
        }
        function parseComputedMember() {
            var expr;
            expect('[');
            expr = parseExpression();
            expect(']');
            return expr;
        }
        function parseNewExpression() {
            var callee, args;
            delegate.markStart();
            expectKeyword('new');
            callee = parseLeftHandSideExpression();
            args = match('(') ? parseArguments() : [];
            return delegate.markEnd(delegate.createNewExpression(callee, args));
        }
        function parseLeftHandSideExpressionAllowCall() {
            var marker, previousAllowIn, expr, args, property;
            marker = createLocationMarker();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
            state.allowIn = previousAllowIn;
            while (match('.') || match('[') || match('(')) {
                if (match('(')) {
                    args = parseArguments();
                    expr = delegate.createCallExpression(expr, args);
                } else if (match('[')) {
                    property = parseComputedMember();
                    expr = delegate.createMemberExpression('[', expr, property);
                } else {
                    property = parseNonComputedMember();
                    expr = delegate.createMemberExpression('.', expr, property);
                }
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        function parseLeftHandSideExpression() {
            var marker, previousAllowIn, expr, property;
            marker = createLocationMarker();
            previousAllowIn = state.allowIn;
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
            state.allowIn = previousAllowIn;
            while (match('.') || match('[')) {
                if (match('[')) {
                    property = parseComputedMember();
                    expr = delegate.createMemberExpression('[', expr, property);
                } else {
                    property = parseNonComputedMember();
                    expr = delegate.createMemberExpression('.', expr, property);
                }
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        // 11.3 Postfix Expressions
        function parsePostfixExpression() {
            var expr, token;
            delegate.markStart();
            expr = parseLeftHandSideExpressionAllowCall();
            if (lookahead.type === Token.Punctuator) {
                if ((match('++') || match('--')) && !peekLineTerminator()) {
                    // 11.3.1, 11.3.2
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        throwErrorTolerant({}, Messages.StrictLHSPostfix);
                    }
                    if (!isLeftHandSide(expr)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                    }
                    token = lex();
                    expr = delegate.createPostfixExpression(token.value, expr);
                }
            }
            return delegate.markEndIf(expr);
        }
        // 11.4 Unary Operators
        function parseUnaryExpression() {
            var token, expr;
            delegate.markStart();
            if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                expr = parsePostfixExpression();
            } else if (match('++') || match('--')) {
                token = lex();
                expr = parseUnaryExpression();
                // 11.4.4, 11.4.5
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPrefix);
                }
                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }
                expr = delegate.createUnaryExpression(token.value, expr);
            } else if (match('+') || match('-') || match('~') || match('!')) {
                token = lex();
                expr = parseUnaryExpression();
                expr = delegate.createUnaryExpression(token.value, expr);
            } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                token = lex();
                expr = parseUnaryExpression();
                expr = delegate.createUnaryExpression(token.value, expr);
                if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                    throwErrorTolerant({}, Messages.StrictDelete);
                }
            } else {
                expr = parsePostfixExpression();
            }
            return delegate.markEndIf(expr);
        }
        function binaryPrecedence(token, allowIn) {
            var prec = 0;
            if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                return 0;
            }
            switch (token.value) {
            case '||':
                prec = 1;
                break;
            case '&&':
                prec = 2;
                break;
            case '|':
                prec = 3;
                break;
            case '^':
                prec = 4;
                break;
            case '&':
                prec = 5;
                break;
            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;
            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;
            case 'in':
                prec = allowIn ? 7 : 0;
                break;
            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;
            case '+':
            case '-':
                prec = 9;
                break;
            case '*':
            case '/':
            case '%':
                prec = 11;
                break;
            default:
                break;
            }
            return prec;
        }
        // 11.5 Multiplicative Operators
        // 11.6 Additive Operators
        // 11.7 Bitwise Shift Operators
        // 11.8 Relational Operators
        // 11.9 Equality Operators
        // 11.10 Binary Bitwise Operators
        // 11.11 Binary Logical Operators
        function parseBinaryExpression() {
            var marker, markers, expr, token, prec, stack, right, operator, left, i;
            marker = createLocationMarker();
            left = parseUnaryExpression();
            token = lookahead;
            prec = binaryPrecedence(token, state.allowIn);
            if (prec === 0) {
                return left;
            }
            token.prec = prec;
            lex();
            markers = [
                marker,
                createLocationMarker()
            ];
            right = parseUnaryExpression();
            stack = [
                left,
                token,
                right
            ];
            while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
                // Reduce: make a binary expression from the three topmost entries.
                while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                    right = stack.pop();
                    operator = stack.pop().value;
                    left = stack.pop();
                    expr = delegate.createBinaryExpression(operator, left, right);
                    markers.pop();
                    marker = markers.pop();
                    if (marker) {
                        marker.end();
                        marker.apply(expr);
                    }
                    stack.push(expr);
                    markers.push(marker);
                }
                // Shift.
                token = lex();
                token.prec = prec;
                stack.push(token);
                markers.push(createLocationMarker());
                expr = parseUnaryExpression();
                stack.push(expr);
            }
            // Final reduce to clean-up the stack.
            i = stack.length - 1;
            expr = stack[i];
            markers.pop();
            while (i > 1) {
                expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                i -= 2;
                marker = markers.pop();
                if (marker) {
                    marker.end();
                    marker.apply(expr);
                }
            }
            return expr;
        }
        // 11.12 Conditional Operator
        function parseConditionalExpression() {
            var expr, previousAllowIn, consequent, alternate;
            delegate.markStart();
            expr = parseBinaryExpression();
            if (match('?')) {
                lex();
                previousAllowIn = state.allowIn;
                state.allowIn = true;
                consequent = parseAssignmentExpression();
                state.allowIn = previousAllowIn;
                expect(':');
                alternate = parseAssignmentExpression();
                expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));
            } else {
                delegate.markEnd({});
            }
            return expr;
        }
        // 11.13 Assignment Operators
        function parseAssignmentExpression() {
            var token, left, right, node;
            token = lookahead;
            delegate.markStart();
            node = left = parseConditionalExpression();
            if (matchAssign()) {
                // LeftHandSideExpression
                if (!isLeftHandSide(left)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }
                // 11.13.1
                if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
                    throwErrorTolerant(token, Messages.StrictLHSAssignment);
                }
                token = lex();
                right = parseAssignmentExpression();
                node = delegate.createAssignmentExpression(token.value, left, right);
            }
            return delegate.markEndIf(node);
        }
        // 11.14 Comma Operator
        function parseExpression() {
            var expr;
            delegate.markStart();
            expr = parseAssignmentExpression();
            if (match(',')) {
                expr = delegate.createSequenceExpression([expr]);
                while (index < length) {
                    if (!match(',')) {
                        break;
                    }
                    lex();
                    expr.expressions.push(parseAssignmentExpression());
                }
            }
            return delegate.markEndIf(expr);
        }
        // 12.1 Block
        function parseStatementList() {
            var list = [], statement;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                statement = parseSourceElement();
                if (typeof statement === 'undefined') {
                    break;
                }
                list.push(statement);
            }
            return list;
        }
        function parseBlock() {
            var block;
            skipComment();
            delegate.markStart();
            expect('{');
            block = parseStatementList();
            expect('}');
            return delegate.markEnd(delegate.createBlockStatement(block));
        }
        // 12.2 Variable Statement
        function parseVariableIdentifier() {
            var token;
            skipComment();
            delegate.markStart();
            token = lex();
            if (token.type !== Token.Identifier) {
                throwUnexpected(token);
            }
            return delegate.markEnd(delegate.createIdentifier(token.value));
        }
        function parseVariableDeclaration(kind) {
            var init = null, id;
            skipComment();
            delegate.markStart();
            id = parseVariableIdentifier();
            // 12.2.1
            if (strict && isRestrictedWord(id.name)) {
                throwErrorTolerant({}, Messages.StrictVarName);
            }
            if (kind === 'const') {
                expect('=');
                init = parseAssignmentExpression();
            } else if (match('=')) {
                lex();
                init = parseAssignmentExpression();
            }
            return delegate.markEnd(delegate.createVariableDeclarator(id, init));
        }
        function parseVariableDeclarationList(kind) {
            var list = [];
            do {
                list.push(parseVariableDeclaration(kind));
                if (!match(',')) {
                    break;
                }
                lex();
            } while (index < length);
            return list;
        }
        function parseVariableStatement() {
            var declarations;
            expectKeyword('var');
            declarations = parseVariableDeclarationList();
            consumeSemicolon();
            return delegate.createVariableDeclaration(declarations, 'var');
        }
        // kind may be `const` or `let`
        // Both are experimental and not in the specification yet.
        // see http://wiki.ecmascript.org/doku.php?id=harmony:const
        // and http://wiki.ecmascript.org/doku.php?id=harmony:let
        function parseConstLetDeclaration(kind) {
            var declarations;
            skipComment();
            delegate.markStart();
            expectKeyword(kind);
            declarations = parseVariableDeclarationList(kind);
            consumeSemicolon();
            return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind));
        }
        // 12.3 Empty Statement
        function parseEmptyStatement() {
            expect(';');
            return delegate.createEmptyStatement();
        }
        // 12.4 Expression Statement
        function parseExpressionStatement() {
            var expr = parseExpression();
            consumeSemicolon();
            return delegate.createExpressionStatement(expr);
        }
        // 12.5 If statement
        function parseIfStatement() {
            var test, consequent, alternate;
            expectKeyword('if');
            expect('(');
            test = parseExpression();
            expect(')');
            consequent = parseStatement();
            if (matchKeyword('else')) {
                lex();
                alternate = parseStatement();
            } else {
                alternate = null;
            }
            return delegate.createIfStatement(test, consequent, alternate);
        }
        // 12.6 Iteration Statements
        function parseDoWhileStatement() {
            var body, test, oldInIteration;
            expectKeyword('do');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            expectKeyword('while');
            expect('(');
            test = parseExpression();
            expect(')');
            if (match(';')) {
                lex();
            }
            return delegate.createDoWhileStatement(body, test);
        }
        function parseWhileStatement() {
            var test, body, oldInIteration;
            expectKeyword('while');
            expect('(');
            test = parseExpression();
            expect(')');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            return delegate.createWhileStatement(test, body);
        }
        function parseForVariableDeclaration() {
            var token, declarations;
            delegate.markStart();
            token = lex();
            declarations = parseVariableDeclarationList();
            return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value));
        }
        function parseForStatement() {
            var init, test, update, left, right, body, oldInIteration;
            init = test = update = null;
            expectKeyword('for');
            expect('(');
            if (match(';')) {
                lex();
            } else {
                if (matchKeyword('var') || matchKeyword('let')) {
                    state.allowIn = false;
                    init = parseForVariableDeclaration();
                    state.allowIn = true;
                    if (init.declarations.length === 1 && matchKeyword('in')) {
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                } else {
                    state.allowIn = false;
                    init = parseExpression();
                    state.allowIn = true;
                    if (matchKeyword('in')) {
                        // LeftHandSideExpression
                        if (!isLeftHandSide(init)) {
                            throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                        }
                        lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                }
                if (typeof left === 'undefined') {
                    expect(';');
                }
            }
            if (typeof left === 'undefined') {
                if (!match(';')) {
                    test = parseExpression();
                }
                expect(';');
                if (!match(')')) {
                    update = parseExpression();
                }
            }
            expect(')');
            oldInIteration = state.inIteration;
            state.inIteration = true;
            body = parseStatement();
            state.inIteration = oldInIteration;
            return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);
        }
        // 12.7 The continue statement
        function parseContinueStatement() {
            var label = null, key;
            expectKeyword('continue');
            // Optimize the most common form: 'continue;'.
            if (source.charCodeAt(index) === 59) {
                lex();
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
                return delegate.createContinueStatement(null);
            }
            if (peekLineTerminator()) {
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
                return delegate.createContinueStatement(null);
            }
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
            consumeSemicolon();
            if (label === null && !state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }
            return delegate.createContinueStatement(label);
        }
        // 12.8 The break statement
        function parseBreakStatement() {
            var label = null, key;
            expectKeyword('break');
            // Catch the very common case first: immediately a semicolon (char #59).
            if (source.charCodeAt(index) === 59) {
                lex();
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
                return delegate.createBreakStatement(null);
            }
            if (peekLineTerminator()) {
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
                return delegate.createBreakStatement(null);
            }
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
                key = '$' + label.name;
                if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
            consumeSemicolon();
            if (label === null && !(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }
            return delegate.createBreakStatement(label);
        }
        // 12.9 The return statement
        function parseReturnStatement() {
            var argument = null;
            expectKeyword('return');
            if (!state.inFunctionBody) {
                throwErrorTolerant({}, Messages.IllegalReturn);
            }
            // 'return' followed by a space and an identifier is very common.
            if (source.charCodeAt(index) === 32) {
                if (isIdentifierStart(source.charCodeAt(index + 1))) {
                    argument = parseExpression();
                    consumeSemicolon();
                    return delegate.createReturnStatement(argument);
                }
            }
            if (peekLineTerminator()) {
                return delegate.createReturnStatement(null);
            }
            if (!match(';')) {
                if (!match('}') && lookahead.type !== Token.EOF) {
                    argument = parseExpression();
                }
            }
            consumeSemicolon();
            return delegate.createReturnStatement(argument);
        }
        // 12.10 The with statement
        function parseWithStatement() {
            var object, body;
            if (strict) {
                throwErrorTolerant({}, Messages.StrictModeWith);
            }
            expectKeyword('with');
            expect('(');
            object = parseExpression();
            expect(')');
            body = parseStatement();
            return delegate.createWithStatement(object, body);
        }
        // 12.10 The swith statement
        function parseSwitchCase() {
            var test, consequent = [], statement;
            skipComment();
            delegate.markStart();
            if (matchKeyword('default')) {
                lex();
                test = null;
            } else {
                expectKeyword('case');
                test = parseExpression();
            }
            expect(':');
            while (index < length) {
                if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                    break;
                }
                statement = parseStatement();
                consequent.push(statement);
            }
            return delegate.markEnd(delegate.createSwitchCase(test, consequent));
        }
        function parseSwitchStatement() {
            var discriminant, cases, clause, oldInSwitch, defaultFound;
            expectKeyword('switch');
            expect('(');
            discriminant = parseExpression();
            expect(')');
            expect('{');
            cases = [];
            if (match('}')) {
                lex();
                return delegate.createSwitchStatement(discriminant, cases);
            }
            oldInSwitch = state.inSwitch;
            state.inSwitch = true;
            defaultFound = false;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                clause = parseSwitchCase();
                if (clause.test === null) {
                    if (defaultFound) {
                        throwError({}, Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                }
                cases.push(clause);
            }
            state.inSwitch = oldInSwitch;
            expect('}');
            return delegate.createSwitchStatement(discriminant, cases);
        }
        // 12.13 The throw statement
        function parseThrowStatement() {
            var argument;
            expectKeyword('throw');
            if (peekLineTerminator()) {
                throwError({}, Messages.NewlineAfterThrow);
            }
            argument = parseExpression();
            consumeSemicolon();
            return delegate.createThrowStatement(argument);
        }
        // 12.14 The try statement
        function parseCatchClause() {
            var param, body;
            skipComment();
            delegate.markStart();
            expectKeyword('catch');
            expect('(');
            if (match(')')) {
                throwUnexpected(lookahead);
            }
            param = parseVariableIdentifier();
            // 12.14.1
            if (strict && isRestrictedWord(param.name)) {
                throwErrorTolerant({}, Messages.StrictCatchVariable);
            }
            expect(')');
            body = parseBlock();
            return delegate.markEnd(delegate.createCatchClause(param, body));
        }
        function parseTryStatement() {
            var block, handlers = [], finalizer = null;
            expectKeyword('try');
            block = parseBlock();
            if (matchKeyword('catch')) {
                handlers.push(parseCatchClause());
            }
            if (matchKeyword('finally')) {
                lex();
                finalizer = parseBlock();
            }
            if (handlers.length === 0 && !finalizer) {
                throwError({}, Messages.NoCatchOrFinally);
            }
            return delegate.createTryStatement(block, [], handlers, finalizer);
        }
        // 12.15 The debugger statement
        function parseDebuggerStatement() {
            expectKeyword('debugger');
            consumeSemicolon();
            return delegate.createDebuggerStatement();
        }
        // 12 Statements
        function parseStatement() {
            var type = lookahead.type, expr, labeledBody, key;
            if (type === Token.EOF) {
                throwUnexpected(lookahead);
            }
            skipComment();
            delegate.markStart();
            if (type === Token.Punctuator) {
                switch (lookahead.value) {
                case ';':
                    return delegate.markEnd(parseEmptyStatement());
                case '{':
                    return delegate.markEnd(parseBlock());
                case '(':
                    return delegate.markEnd(parseExpressionStatement());
                default:
                    break;
                }
            }
            if (type === Token.Keyword) {
                switch (lookahead.value) {
                case 'break':
                    return delegate.markEnd(parseBreakStatement());
                case 'continue':
                    return delegate.markEnd(parseContinueStatement());
                case 'debugger':
                    return delegate.markEnd(parseDebuggerStatement());
                case 'do':
                    return delegate.markEnd(parseDoWhileStatement());
                case 'for':
                    return delegate.markEnd(parseForStatement());
                case 'function':
                    return delegate.markEnd(parseFunctionDeclaration());
                case 'if':
                    return delegate.markEnd(parseIfStatement());
                case 'return':
                    return delegate.markEnd(parseReturnStatement());
                case 'switch':
                    return delegate.markEnd(parseSwitchStatement());
                case 'throw':
                    return delegate.markEnd(parseThrowStatement());
                case 'try':
                    return delegate.markEnd(parseTryStatement());
                case 'var':
                    return delegate.markEnd(parseVariableStatement());
                case 'while':
                    return delegate.markEnd(parseWhileStatement());
                case 'with':
                    return delegate.markEnd(parseWithStatement());
                default:
                    break;
                }
            }
            expr = parseExpression();
            // 12.12 Labelled Statements
            if (expr.type === Syntax.Identifier && match(':')) {
                lex();
                key = '$' + expr.name;
                if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                    throwError({}, Messages.Redeclaration, 'Label', expr.name);
                }
                state.labelSet[key] = true;
                labeledBody = parseStatement();
                delete state.labelSet[key];
                return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody));
            }
            consumeSemicolon();
            return delegate.markEnd(delegate.createExpressionStatement(expr));
        }
        // 13 Function Definition
        function parseFunctionSourceElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;
            skipComment();
            delegate.markStart();
            expect('{');
            while (index < length) {
                if (lookahead.type !== Token.StringLiteral) {
                    break;
                }
                token = lookahead;
                sourceElement = parseSourceElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
            oldLabelSet = state.labelSet;
            oldInIteration = state.inIteration;
            oldInSwitch = state.inSwitch;
            oldInFunctionBody = state.inFunctionBody;
            state.labelSet = {};
            state.inIteration = false;
            state.inSwitch = false;
            state.inFunctionBody = true;
            while (index < length) {
                if (match('}')) {
                    break;
                }
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
            expect('}');
            state.labelSet = oldLabelSet;
            state.inIteration = oldInIteration;
            state.inSwitch = oldInSwitch;
            state.inFunctionBody = oldInFunctionBody;
            return delegate.markEnd(delegate.createBlockStatement(sourceElements));
        }
        function parseParams(firstRestricted) {
            var param, params = [], token, stricted, paramSet, key, message;
            expect('(');
            if (!match(')')) {
                paramSet = {};
                while (index < length) {
                    token = lookahead;
                    param = parseVariableIdentifier();
                    key = '$' + token.value;
                    if (strict) {
                        if (isRestrictedWord(token.value)) {
                            stricted = token;
                            message = Messages.StrictParamName;
                        }
                        if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                            stricted = token;
                            message = Messages.StrictParamDupe;
                        }
                    } else if (!firstRestricted) {
                        if (isRestrictedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictParamName;
                        } else if (isStrictModeReservedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictReservedWord;
                        } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
                            firstRestricted = token;
                            message = Messages.StrictParamDupe;
                        }
                    }
                    params.push(param);
                    paramSet[key] = true;
                    if (match(')')) {
                        break;
                    }
                    expect(',');
                }
            }
            expect(')');
            return {
                params: params,
                stricted: stricted,
                firstRestricted: firstRestricted,
                message: message
            };
        }
        function parseFunctionDeclaration() {
            var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;
            skipComment();
            delegate.markStart();
            expectKeyword('function');
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && stricted) {
                throwErrorTolerant(stricted, message);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body));
        }
        function parseFunctionExpression() {
            var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict;
            delegate.markStart();
            expectKeyword('function');
            if (!match('(')) {
                token = lookahead;
                id = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
            }
            tmp = parseParams(firstRestricted);
            params = tmp.params;
            stricted = tmp.stricted;
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
            previousStrict = strict;
            body = parseFunctionSourceElements();
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && stricted) {
                throwErrorTolerant(stricted, message);
            }
            strict = previousStrict;
            return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body));
        }
        // 14 Program
        function parseSourceElement() {
            if (lookahead.type === Token.Keyword) {
                switch (lookahead.value) {
                case 'const':
                case 'let':
                    return parseConstLetDeclaration(lookahead.value);
                case 'function':
                    return parseFunctionDeclaration();
                default:
                    return parseStatement();
                }
            }
            if (lookahead.type !== Token.EOF) {
                return parseStatement();
            }
        }
        function parseSourceElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted;
            while (index < length) {
                token = lookahead;
                if (token.type !== Token.StringLiteral) {
                    break;
                }
                sourceElement = parseSourceElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
            while (index < length) {
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
            return sourceElements;
        }
        function parseProgram() {
            var body;
            skipComment();
            delegate.markStart();
            strict = false;
            peek();
            body = parseSourceElements();
            return delegate.markEnd(delegate.createProgram(body));
        }
        function attachComments() {
            var i, attacher, comment, leading, trailing;
            for (i = 0; i < extra.pendingComments.length; ++i) {
                attacher = extra.pendingComments[i];
                comment = attacher.comment;
                leading = attacher.leading;
                if (leading) {
                    if (typeof leading.leadingComments === 'undefined') {
                        leading.leadingComments = [];
                    }
                    leading.leadingComments.push(attacher.comment);
                }
                trailing = attacher.trailing;
                if (trailing) {
                    if (typeof trailing.trailingComments === 'undefined') {
                        trailing.trailingComments = [];
                    }
                    trailing.trailingComments.push(attacher.comment);
                }
            }
            extra.pendingComments = [];
        }
        function filterTokenLocation() {
            var i, entry, token, tokens = [];
            for (i = 0; i < extra.tokens.length; ++i) {
                entry = extra.tokens[i];
                token = {
                    type: entry.type,
                    value: entry.value
                };
                if (extra.range) {
                    token.range = entry.range;
                }
                if (extra.loc) {
                    token.loc = entry.loc;
                }
                tokens.push(token);
            }
            extra.tokens = tokens;
        }
        function LocationMarker() {
            this.marker = [
                index,
                lineNumber,
                index - lineStart,
                0,
                0,
                0
            ];
        }
        LocationMarker.prototype = {
            constructor: LocationMarker,
            end: function () {
                this.marker[3] = index;
                this.marker[4] = lineNumber;
                this.marker[5] = index - lineStart;
            },
            apply: function (node) {
                if (extra.range) {
                    node.range = [
                        this.marker[0],
                        this.marker[3]
                    ];
                }
                if (extra.loc) {
                    node.loc = {
                        start: {
                            line: this.marker[1],
                            column: this.marker[2]
                        },
                        end: {
                            line: this.marker[4],
                            column: this.marker[5]
                        }
                    };
                    node = delegate.postProcess(node);
                }
                if (extra.attachComment) {
                    delegate.processComment(node);
                }
            }
        };
        function createLocationMarker() {
            if (!extra.loc && !extra.range) {
                return null;
            }
            skipComment();
            return new LocationMarker();
        }
        function tokenize(code, options) {
            var toString, token, tokens;
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = source.length > 0 ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1
            };
            extra = {};
            // Options matching.
            options = options || {};
            // Of course we collect tokens here.
            options.tokens = true;
            extra.tokens = [];
            extra.tokenize = true;
            // The following two fields are necessary to compute the Regex tokens.
            extra.openParenToken = -1;
            extra.openCurlyToken = -1;
            extra.range = typeof options.range === 'boolean' && options.range;
            extra.loc = typeof options.loc === 'boolean' && options.loc;
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (length > 0) {
                if (typeof source[0] === 'undefined') {
                    // Try first to convert to a string. This is good as fast path
                    // for old IE which understands string indexing for string
                    // literals only and not for string object.
                    if (code instanceof String) {
                        source = code.valueOf();
                    }
                }
            }
            try {
                peek();
                if (lookahead.type === Token.EOF) {
                    return extra.tokens;
                }
                token = lex();
                while (lookahead.type !== Token.EOF) {
                    try {
                        token = lex();
                    } catch (lexError) {
                        token = lookahead;
                        if (extra.errors) {
                            extra.errors.push(lexError);
                            // We have to break on the first error
                            // to avoid infinite loops.
                            break;
                        } else {
                            throw lexError;
                        }
                    }
                }
                filterTokenLocation();
                tokens = extra.tokens;
                if (typeof extra.comments !== 'undefined') {
                    tokens.comments = extra.comments;
                }
                if (typeof extra.errors !== 'undefined') {
                    tokens.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
            return tokens;
        }
        function parse(code, options) {
            var program, toString;
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = source.length > 0 ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowIn: true,
                labelSet: {},
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1,
                markerStack: []
            };
            extra = {};
            if (typeof options !== 'undefined') {
                extra.range = typeof options.range === 'boolean' && options.range;
                extra.loc = typeof options.loc === 'boolean' && options.loc;
                extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
                if (extra.loc && options.source !== null && options.source !== undefined) {
                    extra.source = toString(options.source);
                }
                if (typeof options.tokens === 'boolean' && options.tokens) {
                    extra.tokens = [];
                }
                if (typeof options.comment === 'boolean' && options.comment) {
                    extra.comments = [];
                }
                if (typeof options.tolerant === 'boolean' && options.tolerant) {
                    extra.errors = [];
                }
                if (extra.attachComment) {
                    extra.range = true;
                    extra.pendingComments = [];
                    extra.comments = [];
                }
            }
            if (length > 0) {
                if (typeof source[0] === 'undefined') {
                    // Try first to convert to a string. This is good as fast path
                    // for old IE which understands string indexing for string
                    // literals only and not for string object.
                    if (code instanceof String) {
                        source = code.valueOf();
                    }
                }
            }
            try {
                program = parseProgram();
                if (typeof extra.comments !== 'undefined') {
                    program.comments = extra.comments;
                }
                if (typeof extra.tokens !== 'undefined') {
                    filterTokenLocation();
                    program.tokens = extra.tokens;
                }
                if (typeof extra.errors !== 'undefined') {
                    program.errors = extra.errors;
                }
                if (extra.attachComment) {
                    attachComments();
                }
            } catch (e) {
                throw e;
            } finally {
                extra = {};
            }
            return program;
        }
        // Sync with package.json and component.json.
        exports.version = '1.1.0-dev';
        exports.tokenize = tokenize;
        exports.parse = parse;
        // Deep copy.
        exports.Syntax = function () {
            var name, types = {};
            if (typeof Object.create === 'function') {
                types = Object.create(null);
            }
            for (name in Syntax) {
                if (Syntax.hasOwnProperty(name)) {
                    types[name] = Syntax[name];
                }
            }
            if (typeof Object.freeze === 'function') {
                Object.freeze(types);
            }
            return types;
        }();
        return exports;
    }));    /* vim: set sw=4 ts=4 et tw=80 : */
    /*
      Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    /*jslint vars:false, bitwise:true*/
    /*jshint indent:4*/
    /*global exports:true, define:true*/
    (function (root, factory) {
        'use strict';
        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
        // and plain browser loading,
        if (true) {
            estraverse = function () {
                return factory();
            }({});
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory(root.estraverse = {});
        }
    }(this, function (exports) {
        exports = exports || {};
        'use strict';
        var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
        Syntax = {
            AssignmentExpression: 'AssignmentExpression',
            ArrayExpression: 'ArrayExpression',
            ArrowFunctionExpression: 'ArrowFunctionExpression',
            BlockStatement: 'BlockStatement',
            BinaryExpression: 'BinaryExpression',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DebuggerStatement: 'DebuggerStatement',
            DirectiveStatement: 'DirectiveStatement',
            DoWhileStatement: 'DoWhileStatement',
            EmptyStatement: 'EmptyStatement',
            ExpressionStatement: 'ExpressionStatement',
            ForStatement: 'ForStatement',
            ForInStatement: 'ForInStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            Literal: 'Literal',
            LabeledStatement: 'LabeledStatement',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            NewExpression: 'NewExpression',
            ObjectExpression: 'ObjectExpression',
            Program: 'Program',
            Property: 'Property',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SwitchStatement: 'SwitchStatement',
            SwitchCase: 'SwitchCase',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TryStatement: 'TryStatement',
            UnaryExpression: 'UnaryExpression',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement',
            YieldExpression: 'YieldExpression'
        };
        function ignoreJSHintError() {
        }
        isArray = Array.isArray;
        if (!isArray) {
            isArray = function isArray(array) {
                return Object.prototype.toString.call(array) === '[object Array]';
            };
        }
        function deepCopy(obj) {
            var ret = {}, key, val;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    val = obj[key];
                    if (typeof val === 'object' && val !== null) {
                        ret[key] = deepCopy(val);
                    } else {
                        ret[key] = val;
                    }
                }
            }
            return ret;
        }
        function shallowCopy(obj) {
            var ret = {}, key;
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    ret[key] = obj[key];
                }
            }
            return ret;
        }
        ignoreJSHintError(shallowCopy);
        // based on LLVM libc++ upper_bound / lower_bound
        // MIT License
        function upperBound(array, func) {
            var diff, len, i, current;
            len = array.length;
            i = 0;
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    len = diff;
                } else {
                    i = current + 1;
                    len -= diff + 1;
                }
            }
            return i;
        }
        function lowerBound(array, func) {
            var diff, len, i, current;
            len = array.length;
            i = 0;
            while (len) {
                diff = len >>> 1;
                current = i + diff;
                if (func(array[current])) {
                    i = current + 1;
                    len -= diff + 1;
                } else {
                    len = diff;
                }
            }
            return i;
        }
        ignoreJSHintError(lowerBound);
        VisitorKeys = {
            AssignmentExpression: [
                'left',
                'right'
            ],
            ArrayExpression: ['elements'],
            ArrowFunctionExpression: [
                'params',
                'body'
            ],
            BlockStatement: ['body'],
            BinaryExpression: [
                'left',
                'right'
            ],
            BreakStatement: ['label'],
            CallExpression: [
                'callee',
                'arguments'
            ],
            CatchClause: [
                'param',
                'body'
            ],
            ConditionalExpression: [
                'test',
                'consequent',
                'alternate'
            ],
            ContinueStatement: ['label'],
            DebuggerStatement: [],
            DirectiveStatement: [],
            DoWhileStatement: [
                'body',
                'test'
            ],
            EmptyStatement: [],
            ExpressionStatement: ['expression'],
            ForStatement: [
                'init',
                'test',
                'update',
                'body'
            ],
            ForInStatement: [
                'left',
                'right',
                'body'
            ],
            FunctionDeclaration: [
                'id',
                'params',
                'body'
            ],
            FunctionExpression: [
                'id',
                'params',
                'body'
            ],
            Identifier: [],
            IfStatement: [
                'test',
                'consequent',
                'alternate'
            ],
            Literal: [],
            LabeledStatement: [
                'label',
                'body'
            ],
            LogicalExpression: [
                'left',
                'right'
            ],
            MemberExpression: [
                'object',
                'property'
            ],
            NewExpression: [
                'callee',
                'arguments'
            ],
            ObjectExpression: ['properties'],
            Program: ['body'],
            Property: [
                'key',
                'value'
            ],
            ReturnStatement: ['argument'],
            SequenceExpression: ['expressions'],
            SwitchStatement: [
                'discriminant',
                'cases'
            ],
            SwitchCase: [
                'test',
                'consequent'
            ],
            ThisExpression: [],
            ThrowStatement: ['argument'],
            TryStatement: [
                'block',
                'handlers',
                'handler',
                'guardedHandlers',
                'finalizer'
            ],
            UnaryExpression: ['argument'],
            UpdateExpression: ['argument'],
            VariableDeclaration: ['declarations'],
            VariableDeclarator: [
                'id',
                'init'
            ],
            WhileStatement: [
                'test',
                'body'
            ],
            WithStatement: [
                'object',
                'body'
            ],
            YieldExpression: ['argument']
        };
        // unique id
        BREAK = {};
        SKIP = {};
        VisitorOption = {
            Break: BREAK,
            Skip: SKIP
        };
        function Reference(parent, key) {
            this.parent = parent;
            this.key = key;
        }
        Reference.prototype.replace = function replace(node) {
            this.parent[this.key] = node;
        };
        function Element(node, path, wrap, ref) {
            this.node = node;
            this.path = path;
            this.wrap = wrap;
            this.ref = ref;
        }
        function Controller() {
        }
        // API:
        // return property path array from root to current node
        Controller.prototype.path = function path() {
            var i, iz, j, jz, result, element;
            function addToPath(result, path) {
                if (isArray(path)) {
                    for (j = 0, jz = path.length; j < jz; ++j) {
                        result.push(path[j]);
                    }
                } else {
                    result.push(path);
                }
            }
            // root node
            if (!this.__current.path) {
                return null;
            }
            // first node is sentinel, second node is root element
            result = [];
            for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
                element = this.__leavelist[i];
                addToPath(result, element.path);
            }
            addToPath(result, this.__current.path);
            return result;
        };
        // API:
        // return array of parent elements
        Controller.prototype.parents = function parents() {
            var i, iz, result;
            // first node is sentinel
            result = [];
            for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
                result.push(this.__leavelist[i].node);
            }
            return result;
        };
        // API:
        // return current node
        Controller.prototype.current = function current() {
            return this.__current.node;
        };
        Controller.prototype.__execute = function __execute(callback, element) {
            var previous, result;
            result = undefined;
            previous = this.__current;
            this.__current = element;
            this.__state = null;
            if (callback) {
                result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
            }
            this.__current = previous;
            return result;
        };
        // API:
        // notify control skip / break
        Controller.prototype.notify = function notify(flag) {
            this.__state = flag;
        };
        // API:
        // skip child nodes of current node
        Controller.prototype.skip = function () {
            this.notify(SKIP);
        };
        // API:
        // break traversals
        Controller.prototype['break'] = function () {
            this.notify(BREAK);
        };
        Controller.prototype.__initialize = function (root, visitor) {
            this.visitor = visitor;
            this.root = root;
            this.__worklist = [];
            this.__leavelist = [];
            this.__current = null;
            this.__state = null;
        };
        Controller.prototype.traverse = function traverse(root, visitor) {
            var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
            this.__initialize(root, visitor);
            sentinel = {};
            // reference
            worklist = this.__worklist;
            leavelist = this.__leavelist;
            // initialize
            worklist.push(new Element(root, null, null, null));
            leavelist.push(new Element(null, null, null, null));
            while (worklist.length) {
                element = worklist.pop();
                if (element === sentinel) {
                    element = leavelist.pop();
                    ret = this.__execute(visitor.leave, element);
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
                    continue;
                }
                if (element.node) {
                    ret = this.__execute(visitor.enter, element);
                    if (this.__state === BREAK || ret === BREAK) {
                        return;
                    }
                    worklist.push(sentinel);
                    leavelist.push(element);
                    if (this.__state === SKIP || ret === SKIP) {
                        continue;
                    }
                    node = element.node;
                    nodeType = element.wrap || node.type;
                    candidates = VisitorKeys[nodeType];
                    current = candidates.length;
                    while ((current -= 1) >= 0) {
                        key = candidates[current];
                        candidate = node[key];
                        if (!candidate) {
                            continue;
                        }
                        if (!isArray(candidate)) {
                            worklist.push(new Element(candidate, key, null, null));
                            continue;
                        }
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                                element = new Element(candidate[current2], [
                                    key,
                                    current2
                                ], 'Property', null);
                            } else {
                                element = new Element(candidate[current2], [
                                    key,
                                    current2
                                ], null, null);
                            }
                            worklist.push(element);
                        }
                    }
                }
            }
        };
        Controller.prototype.replace = function replace(root, visitor) {
            var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
            this.__initialize(root, visitor);
            sentinel = {};
            // reference
            worklist = this.__worklist;
            leavelist = this.__leavelist;
            // initialize
            outer = { root: root };
            element = new Element(root, null, null, new Reference(outer, 'root'));
            worklist.push(element);
            leavelist.push(element);
            while (worklist.length) {
                element = worklist.pop();
                if (element === sentinel) {
                    element = leavelist.pop();
                    target = this.__execute(visitor.leave, element);
                    // node may be replaced with null,
                    // so distinguish between undefined and null in this place
                    if (target !== undefined && target !== BREAK && target !== SKIP) {
                        // replace
                        element.ref.replace(target);
                    }
                    if (this.__state === BREAK || target === BREAK) {
                        return outer.root;
                    }
                    continue;
                }
                target = this.__execute(visitor.enter, element);
                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                    element.node = target;
                }
                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                // node may be null
                node = element.node;
                if (!node) {
                    continue;
                }
                worklist.push(sentinel);
                leavelist.push(element);
                if (this.__state === SKIP || target === SKIP) {
                    continue;
                }
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];
                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }
                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                        continue;
                    }
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [
                                key,
                                current2
                            ], 'Property', new Reference(candidate, current2));
                        } else {
                            element = new Element(candidate[current2], [
                                key,
                                current2
                            ], null, new Reference(candidate, current2));
                        }
                        worklist.push(element);
                    }
                }
            }
            return outer.root;
        };
        function traverse(root, visitor) {
            var controller = new Controller();
            return controller.traverse(root, visitor);
        }
        function replace(root, visitor) {
            var controller = new Controller();
            return controller.replace(root, visitor);
        }
        function extendCommentRange(comment, tokens) {
            var target, token;
            target = upperBound(tokens, function search(token) {
                return token.range[0] > comment.range[0];
            });
            comment.extendedRange = [
                comment.range[0],
                comment.range[1]
            ];
            if (target !== tokens.length) {
                comment.extendedRange[1] = tokens[target].range[0];
            }
            target -= 1;
            if (target >= 0) {
                if (target < tokens.length) {
                    comment.extendedRange[0] = tokens[target].range[1];
                } else if (token.length) {
                    comment.extendedRange[1] = tokens[tokens.length - 1].range[0];
                }
            }
            return comment;
        }
        function attachComments(tree, providedComments, tokens) {
            // At first, we should calculate extended comment ranges.
            var comments = [], comment, len, i, cursor;
            if (!tree.range) {
                throw new Error('attachComments needs range information');
            }
            // tokens array is empty, we attach comments to tree as 'leadingComments'
            if (!tokens.length) {
                if (providedComments.length) {
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comment = deepCopy(providedComments[i]);
                        comment.extendedRange = [
                            0,
                            tree.range[0]
                        ];
                        comments.push(comment);
                    }
                    tree.leadingComments = comments;
                }
                return tree;
            }
            for (i = 0, len = providedComments.length; i < len; i += 1) {
                comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
            }
            // This is based on John Freeman's implementation.
            cursor = 0;
            traverse(tree, {
                enter: function (node) {
                    var comment;
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (comment.extendedRange[1] > node.range[0]) {
                            break;
                        }
                        if (comment.extendedRange[1] === node.range[0]) {
                            if (!node.leadingComments) {
                                node.leadingComments = [];
                            }
                            node.leadingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
                    // already out of owned node
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
            cursor = 0;
            traverse(tree, {
                leave: function (node) {
                    var comment;
                    while (cursor < comments.length) {
                        comment = comments[cursor];
                        if (node.range[1] < comment.extendedRange[0]) {
                            break;
                        }
                        if (node.range[1] === comment.extendedRange[0]) {
                            if (!node.trailingComments) {
                                node.trailingComments = [];
                            }
                            node.trailingComments.push(comment);
                            comments.splice(cursor, 1);
                        } else {
                            cursor += 1;
                        }
                    }
                    // already out of owned node
                    if (cursor === comments.length) {
                        return VisitorOption.Break;
                    }
                    if (comments[cursor].extendedRange[0] > node.range[1]) {
                        return VisitorOption.Skip;
                    }
                }
            });
            return tree;
        }
        exports.version = '1.3.2-dev';
        exports.Syntax = Syntax;
        exports.traverse = traverse;
        exports.replace = replace;
        exports.attachComments = attachComments;
        exports.VisitorKeys = VisitorKeys;
        exports.VisitorOption = VisitorOption;
        exports.Controller = Controller;
        return exports;
    }));    /* vim: set sw=4 ts=4 et tw=80 : */
    // Generated by browserify
    (function () {
        var require = function (file, cwd) {
            var resolved = require.resolve(file, cwd || '/');
            var mod = require.modules[resolved];
            if (!mod)
                throw new Error('Failed to resolve module ' + file + ', tried ' + resolved);
            var cached = require.cache[resolved];
            var res = cached ? cached.exports : mod();
            return res;
        };
        require.paths = [];
        require.modules = {};
        require.cache = {};
        require.extensions = [
            '.js',
            '.coffee',
            '.json'
        ];
        require._core = {
            'assert': true,
            'events': true,
            'fs': true,
            'path': true,
            'vm': true
        };
        require.resolve = function () {
            return function (x, cwd) {
                if (!cwd)
                    cwd = '/';
                if (require._core[x])
                    return x;
                var path = require.modules.path();
                cwd = path.resolve('/', cwd);
                var y = cwd || '/';
                if (x.match(/^(?:\.\.?\/|\/)/)) {
                    var m = loadAsFileSync(path.resolve(y, x)) || loadAsDirectorySync(path.resolve(y, x));
                    if (m)
                        return m;
                }
                var n = loadNodeModulesSync(x, y);
                if (n)
                    return n;
                throw new Error('Cannot find module \'' + x + '\'');
                function loadAsFileSync(x) {
                    x = path.normalize(x);
                    if (require.modules[x]) {
                        return x;
                    }
                    for (var i = 0; i < require.extensions.length; i++) {
                        var ext = require.extensions[i];
                        if (require.modules[x + ext])
                            return x + ext;
                    }
                }
                function loadAsDirectorySync(x) {
                    x = x.replace(/\/+$/, '');
                    var pkgfile = path.normalize(x + '/package.json');
                    if (require.modules[pkgfile]) {
                        var pkg = require.modules[pkgfile]();
                        var b = pkg.browserify;
                        if (typeof b === 'object' && b.main) {
                            var m = loadAsFileSync(path.resolve(x, b.main));
                            if (m)
                                return m;
                        } else if (typeof b === 'string') {
                            var m = loadAsFileSync(path.resolve(x, b));
                            if (m)
                                return m;
                        } else if (pkg.main) {
                            var m = loadAsFileSync(path.resolve(x, pkg.main));
                            if (m)
                                return m;
                        }
                    }
                    return loadAsFileSync(x + '/index');
                }
                function loadNodeModulesSync(x, start) {
                    var dirs = nodeModulesPathsSync(start);
                    for (var i = 0; i < dirs.length; i++) {
                        var dir = dirs[i];
                        var m = loadAsFileSync(dir + '/' + x);
                        if (m)
                            return m;
                        var n = loadAsDirectorySync(dir + '/' + x);
                        if (n)
                            return n;
                    }
                    var m = loadAsFileSync(x);
                    if (m)
                        return m;
                }
                function nodeModulesPathsSync(start) {
                    var parts;
                    if (start === '/')
                        parts = [''];
                    else
                        parts = path.normalize(start).split('/');
                    var dirs = [];
                    for (var i = parts.length - 1; i >= 0; i--) {
                        if (parts[i] === 'node_modules')
                            continue;
                        var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                        dirs.push(dir);
                    }
                    return dirs;
                }
            };
        }();
        require.alias = function (from, to) {
            var path = require.modules.path();
            var res = null;
            try {
                res = require.resolve(from + '/package.json', '/');
            } catch (err) {
                res = require.resolve(from, '/');
            }
            var basedir = path.dirname(res);
            var keys = (Object.keys || function (obj) {
                    var res = [];
                    for (var key in obj)
                        res.push(key);
                    return res;
                })(require.modules);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key.slice(0, basedir.length + 1) === basedir + '/') {
                    var f = key.slice(basedir.length);
                    require.modules[to + f] = require.modules[basedir + f];
                } else if (key === basedir) {
                    require.modules[to] = require.modules[basedir];
                }
            }
        };
        (function () {
            var process = {};
            var global = typeof window !== 'undefined' ? window : {};
            var definedProcess = false;
            require.define = function (filename, fn) {
                if (!definedProcess && require.modules.__browserify_process) {
                    process = require.modules.__browserify_process();
                    definedProcess = true;
                }
                var dirname = require._core[filename] ? '' : require.modules.path().dirname(filename);
                var require_ = function (file) {
                    var requiredModule = require(file, dirname);
                    var cached = require.cache[require.resolve(file, dirname)];
                    if (cached && cached.parent === null) {
                        cached.parent = module_;
                    }
                    return requiredModule;
                };
                require_.resolve = function (name) {
                    return require.resolve(name, dirname);
                };
                require_.modules = require.modules;
                require_.define = require.define;
                require_.cache = require.cache;
                var module_ = {
                        id: filename,
                        filename: filename,
                        exports: {},
                        loaded: false,
                        parent: null
                    };
                require.modules[filename] = function () {
                    require.cache[filename] = module_;
                    fn.call(module_.exports, require_, module_, module_.exports, dirname, filename, process, global);
                    module_.loaded = true;
                    return module_.exports;
                };
            };
        }());
        require.define('path', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            function filter(xs, fn) {
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    if (fn(xs[i], i, xs))
                        res.push(xs[i]);
                }
                return res;
            }
            // resolves . and .. elements in a path array with directory names there
            // must be no slashes, empty elements, or device names (c:\) in the array
            // (so also no leading and trailing slashes - it does not distinguish
            // relative and absolute paths)
            function normalizeArray(parts, allowAboveRoot) {
                // if the path tries to go above the root, `up` ends up > 0
                var up = 0;
                for (var i = parts.length; i >= 0; i--) {
                    var last = parts[i];
                    if (last == '.') {
                        parts.splice(i, 1);
                    } else if (last === '..') {
                        parts.splice(i, 1);
                        up++;
                    } else if (up) {
                        parts.splice(i, 1);
                        up--;
                    }
                }
                // if the path is allowed to go above the root, restore leading ..s
                if (allowAboveRoot) {
                    for (; up--; up) {
                        parts.unshift('..');
                    }
                }
                return parts;
            }
            // Regex to split a filename into [*, dir, basename, ext]
            // posix version
            var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
            // path.resolve([from ...], to)
            // posix version
            exports.resolve = function () {
                var resolvedPath = '', resolvedAbsolute = false;
                for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
                    var path = i >= 0 ? arguments[i] : process.cwd();
                    // Skip empty and invalid entries
                    if (typeof path !== 'string' || !path) {
                        continue;
                    }
                    resolvedPath = path + '/' + resolvedPath;
                    resolvedAbsolute = path.charAt(0) === '/';
                }
                // At this point the path should be resolved to a full absolute path, but
                // handle relative paths to be safe (might happen when process.cwd() fails)
                // Normalize the path
                resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
                    return !!p;
                }), !resolvedAbsolute).join('/');
                return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
            };
            // path.normalize(path)
            // posix version
            exports.normalize = function (path) {
                var isAbsolute = path.charAt(0) === '/', trailingSlash = path.slice(-1) === '/';
                // Normalize the path
                path = normalizeArray(filter(path.split('/'), function (p) {
                    return !!p;
                }), !isAbsolute).join('/');
                if (!path && !isAbsolute) {
                    path = '.';
                }
                if (path && trailingSlash) {
                    path += '/';
                }
                return (isAbsolute ? '/' : '') + path;
            };
            // posix version
            exports.join = function () {
                var paths = Array.prototype.slice.call(arguments, 0);
                return exports.normalize(filter(paths, function (p, index) {
                    return p && typeof p === 'string';
                }).join('/'));
            };
            exports.dirname = function (path) {
                var dir = splitPathRe.exec(path)[1] || '';
                var isWindows = false;
                if (!dir) {
                    // No dirname
                    return '.';
                } else if (dir.length === 1 || isWindows && dir.length <= 3 && dir.charAt(1) === ':') {
                    // It is just a slash or a drive letter with a slash
                    return dir;
                } else {
                    // It is a full dirname, strip trailing slash
                    return dir.substring(0, dir.length - 1);
                }
            };
            exports.basename = function (path, ext) {
                var f = splitPathRe.exec(path)[2] || '';
                // TODO: make this comparison case-insensitive on windows?
                if (ext && f.substr(-1 * ext.length) === ext) {
                    f = f.substr(0, f.length - ext.length);
                }
                return f;
            };
            exports.extname = function (path) {
                return splitPathRe.exec(path)[3] || '';
            };
            exports.relative = function (from, to) {
                from = exports.resolve(from).substr(1);
                to = exports.resolve(to).substr(1);
                function trim(arr) {
                    var start = 0;
                    for (; start < arr.length; start++) {
                        if (arr[start] !== '')
                            break;
                    }
                    var end = arr.length - 1;
                    for (; end >= 0; end--) {
                        if (arr[end] !== '')
                            break;
                    }
                    if (start > end)
                        return [];
                    return arr.slice(start, end - start + 1);
                }
                var fromParts = trim(from.split('/'));
                var toParts = trim(to.split('/'));
                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                    if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                }
                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                    outputParts.push('..');
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join('/');
            };
            return exports;
        });
        require.define('__browserify_process', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            var process = module.exports = {};
            process.nextTick = function () {
                var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;
                var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;
                if (canSetImmediate) {
                    return function (f) {
                        return window.setImmediate(f);
                    };
                }
                if (canPost) {
                    var queue = [];
                    window.addEventListener('message', function (ev) {
                        if (ev.source === window && ev.data === 'browserify-tick') {
                            ev.stopPropagation();
                            if (queue.length > 0) {
                                var fn = queue.shift();
                                fn();
                            }
                        }
                    }, true);
                    return function nextTick(fn) {
                        queue.push(fn);
                        window.postMessage('browserify-tick', '*');
                    };
                }
                return function nextTick(fn) {
                    setTimeout(fn, 0);
                };
            }();
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.binding = function (name) {
                if (name === 'evals')
                    return vm;
                else
                    throw new Error('No such module. (Possibly not yet loaded)');
            };
            (function () {
                var cwd = '/';
                var path;
                process.cwd = function () {
                    return cwd;
                };
                process.chdir = function (dir) {
                    if (!path)
                        path = path;
                    cwd = path.resolve(dir, cwd);
                };
            }());
            return exports;
        });
        require.define('/package.json', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            module.exports = { 'main': 'escodegen.js' };
            return exports;
        });
        require.define('/escodegen.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            /*
              Copyright (C) 2012 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
              Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
              Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
              Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
              Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
              Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
              Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
              Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
              Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
            
              Redistribution and use in source and binary forms, with or without
              modification, are permitted provided that the following conditions are met:
            
                * Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.
                * Redistributions in binary form must reproduce the above copyright
                  notice, this list of conditions and the following disclaimer in the
                  documentation and/or other materials provided with the distribution.
            
              THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
              AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
              IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
              ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
              DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
              (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
              LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
              ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
              THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */
            /*jslint bitwise:true */
            /*global escodegen:true, exports:true, generateStatement:true, generateExpression:true, generateFunctionBody:true, process:true, require:true, define:true, global:true*/
            (function () {
                'use strict';
                var Syntax, Precedence, BinaryPrecedence, Regex, VisitorKeys, VisitorOption, SourceNode, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, traverse;
                traverse = estraverse.traverse;
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    ArrayPattern: 'ArrayPattern',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ComprehensionBlock: 'ComprehensionBlock',
                    ComprehensionExpression: 'ComprehensionExpression',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    ObjectPattern: 'ObjectPattern',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement',
                    YieldExpression: 'YieldExpression'
                };
                Precedence = {
                    Sequence: 0,
                    Assignment: 1,
                    Conditional: 2,
                    LogicalOR: 3,
                    LogicalAND: 4,
                    BitwiseOR: 5,
                    BitwiseXOR: 6,
                    BitwiseAND: 7,
                    Equality: 8,
                    Relational: 9,
                    BitwiseSHIFT: 10,
                    Additive: 11,
                    Multiplicative: 12,
                    Unary: 13,
                    Postfix: 14,
                    Call: 15,
                    New: 16,
                    Member: 17,
                    Primary: 18
                };
                BinaryPrecedence = {
                    '||': Precedence.LogicalOR,
                    '&&': Precedence.LogicalAND,
                    '|': Precedence.BitwiseOR,
                    '^': Precedence.BitwiseXOR,
                    '&': Precedence.BitwiseAND,
                    '==': Precedence.Equality,
                    '!=': Precedence.Equality,
                    '===': Precedence.Equality,
                    '!==': Precedence.Equality,
                    'is': Precedence.Equality,
                    'isnt': Precedence.Equality,
                    '<': Precedence.Relational,
                    '>': Precedence.Relational,
                    '<=': Precedence.Relational,
                    '>=': Precedence.Relational,
                    'in': Precedence.Relational,
                    'instanceof': Precedence.Relational,
                    '<<': Precedence.BitwiseSHIFT,
                    '>>': Precedence.BitwiseSHIFT,
                    '>>>': Precedence.BitwiseSHIFT,
                    '+': Precedence.Additive,
                    '-': Precedence.Additive,
                    '*': Precedence.Multiplicative,
                    '%': Precedence.Multiplicative,
                    '/': Precedence.Multiplicative
                };
                Regex = { NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]') };
                function getDefaultOptions() {
                    // default options
                    return {
                        indent: null,
                        base: null,
                        parse: null,
                        comment: false,
                        format: {
                            indent: {
                                style: '    ',
                                base: 0,
                                adjustMultilineComment: false
                            },
                            json: false,
                            renumber: false,
                            hexadecimal: false,
                            quotes: 'single',
                            escapeless: false,
                            compact: false,
                            parentheses: true,
                            semicolons: true,
                            safeConcatenation: false
                        },
                        moz: {
                            starlessGenerator: false,
                            parenthesizedComprehensionBlock: false
                        },
                        sourceMap: null,
                        sourceMapRoot: null,
                        sourceMapWithCode: false,
                        directive: false,
                        verbatim: null
                    };
                }
                function stringToArray(str) {
                    var length = str.length, result = [], i;
                    for (i = 0; i < length; i += 1) {
                        result[i] = str.charAt(i);
                    }
                    return result;
                }
                function stringRepeat(str, num) {
                    var result = '';
                    for (num |= 0; num > 0; num >>>= 1, str += str) {
                        if (num & 1) {
                            result += str;
                        }
                    }
                    return result;
                }
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                // Fallback for the non SourceMap environment
                function SourceNodeMock(line, column, filename, chunk) {
                    var result = [];
                    function flatten(input) {
                        var i, iz;
                        if (isArray(input)) {
                            for (i = 0, iz = input.length; i < iz; ++i) {
                                flatten(input[i]);
                            }
                        } else if (input instanceof SourceNodeMock) {
                            result.push(input);
                        } else if (typeof input === 'string' && input) {
                            result.push(input);
                        }
                    }
                    flatten(chunk);
                    this.children = result;
                }
                SourceNodeMock.prototype.toString = function toString() {
                    var res = '', i, iz, node;
                    for (i = 0, iz = this.children.length; i < iz; ++i) {
                        node = this.children[i];
                        if (node instanceof SourceNodeMock) {
                            res += node.toString();
                        } else {
                            res += node;
                        }
                    }
                    return res;
                };
                SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {
                    var last = this.children[this.children.length - 1];
                    if (last instanceof SourceNodeMock) {
                        last.replaceRight(pattern, replacement);
                    } else if (typeof last === 'string') {
                        this.children[this.children.length - 1] = last.replace(pattern, replacement);
                    } else {
                        this.children.push(''.replace(pattern, replacement));
                    }
                    return this;
                };
                SourceNodeMock.prototype.join = function join(sep) {
                    var i, iz, result;
                    result = [];
                    iz = this.children.length;
                    if (iz > 0) {
                        for (i = 0, iz -= 1; i < iz; ++i) {
                            result.push(this.children[i], sep);
                        }
                        result.push(this.children[iz]);
                        this.children = result;
                    }
                    return this;
                };
                function hasLineTerminator(str) {
                    return /[\r\n]/g.test(str);
                }
                function endsWithLineTerminator(str) {
                    var ch = str.charAt(str.length - 1);
                    return ch === '\r' || ch === '\n';
                }
                function shallowCopy(obj) {
                    var ret = {}, key;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            ret[key] = obj[key];
                        }
                    }
                    return ret;
                }
                function deepCopy(obj) {
                    var ret = {}, key, val;
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            val = obj[key];
                            if (typeof val === 'object' && val !== null) {
                                ret[key] = deepCopy(val);
                            } else {
                                ret[key] = val;
                            }
                        }
                    }
                    return ret;
                }
                function updateDeeply(target, override) {
                    var key, val;
                    function isHashObject(target) {
                        return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
                    }
                    for (key in override) {
                        if (override.hasOwnProperty(key)) {
                            val = override[key];
                            if (isHashObject(val)) {
                                if (isHashObject(target[key])) {
                                    updateDeeply(target[key], val);
                                } else {
                                    target[key] = updateDeeply({}, val);
                                }
                            } else {
                                target[key] = val;
                            }
                        }
                    }
                    return target;
                }
                function generateNumber(value) {
                    var result, point, temp, exponent, pos;
                    if (value !== value) {
                        throw new Error('Numeric literal whose value is NaN');
                    }
                    if (value < 0 || value === 0 && 1 / value < 0) {
                        throw new Error('Numeric literal whose value is negative');
                    }
                    if (value === 1 / 0) {
                        return json ? 'null' : renumber ? '1e400' : '1e+400';
                    }
                    result = '' + value;
                    if (!renumber || result.length < 3) {
                        return result;
                    }
                    point = result.indexOf('.');
                    if (!json && result.charAt(0) === '0' && point === 1) {
                        point = 0;
                        result = result.slice(1);
                    }
                    temp = result;
                    result = result.replace('e+', 'e');
                    exponent = 0;
                    if ((pos = temp.indexOf('e')) > 0) {
                        exponent = +temp.slice(pos + 1);
                        temp = temp.slice(0, pos);
                    }
                    if (point >= 0) {
                        exponent -= temp.length - point - 1;
                        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
                    }
                    pos = 0;
                    while (temp.charAt(temp.length + pos - 1) === '0') {
                        pos -= 1;
                    }
                    if (pos !== 0) {
                        exponent -= pos;
                        temp = temp.slice(0, pos);
                    }
                    if (exponent !== 0) {
                        temp += 'e' + exponent;
                    }
                    if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
                        result = temp;
                    }
                    return result;
                }
                function escapeAllowedCharacter(ch, next) {
                    var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';
                    switch (ch) {
                    case '\b':
                        result += 'b';
                        break;
                    case '\f':
                        result += 'f';
                        break;
                    case '\t':
                        result += 't';
                        break;
                    default:
                        if (json || code > 255) {
                            result += 'u' + '0000'.slice(hex.length) + hex;
                        } else if (ch === '\0' && '0123456789'.indexOf(next) < 0) {
                            result += '0';
                        } else if (ch === '\x0B') {
                            result += 'v';
                        } else {
                            result += 'x' + '00'.slice(hex.length) + hex;
                        }
                        break;
                    }
                    return result;
                }
                function escapeDisallowedCharacter(ch) {
                    var result = '\\';
                    switch (ch) {
                    case '\\':
                        result += '\\';
                        break;
                    case '\n':
                        result += 'n';
                        break;
                    case '\r':
                        result += 'r';
                        break;
                    case '\u2028':
                        result += 'u2028';
                        break;
                    case '\u2029':
                        result += 'u2029';
                        break;
                    default:
                        throw new Error('Incorrectly classified character');
                    }
                    return result;
                }
                function escapeDirective(str) {
                    var i, iz, ch, single, buf, quote;
                    buf = str;
                    if (typeof buf[0] === 'undefined') {
                        buf = stringToArray(buf);
                    }
                    quote = quotes === 'double' ? '"' : '\'';
                    for (i = 0, iz = buf.length; i < iz; i += 1) {
                        ch = buf[i];
                        if (ch === '\'') {
                            quote = '"';
                            break;
                        } else if (ch === '"') {
                            quote = '\'';
                            break;
                        } else if (ch === '\\') {
                            i += 1;
                        }
                    }
                    return quote + str + quote;
                }
                function escapeString(str) {
                    var result = '', i, len, ch, next, singleQuotes = 0, doubleQuotes = 0, single;
                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }
                    for (i = 0, len = str.length; i < len; i += 1) {
                        ch = str[i];
                        if (ch === '\'') {
                            singleQuotes += 1;
                        } else if (ch === '"') {
                            doubleQuotes += 1;
                        } else if (ch === '/' && json) {
                            result += '\\';
                        } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
                            result += escapeDisallowedCharacter(ch);
                            continue;
                        } else if (json && ch < ' ' || !(json || escapeless || ch >= ' ' && ch <= '~')) {
                            result += escapeAllowedCharacter(ch, str[i + 1]);
                            continue;
                        }
                        result += ch;
                    }
                    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
                    str = result;
                    result = single ? '\'' : '"';
                    if (typeof str[0] === 'undefined') {
                        str = stringToArray(str);
                    }
                    for (i = 0, len = str.length; i < len; i += 1) {
                        ch = str[i];
                        if (ch === '\'' && single || ch === '"' && !single) {
                            result += '\\';
                        }
                        result += ch;
                    }
                    return result + (single ? '\'' : '"');
                }
                function isWhiteSpace(ch) {
                    return '\t\x0B\f \xa0'.indexOf(ch) >= 0 || ch.charCodeAt(0) >= 5760 && '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\ufeff'.indexOf(ch) >= 0;
                }
                function isLineTerminator(ch) {
                    return '\n\r\u2028\u2029'.indexOf(ch) >= 0;
                }
                function isIdentifierPart(ch) {
                    return ch === '$' || ch === '_' || ch === '\\' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierPart.test(ch);
                }
                function toSourceNode(generated, node) {
                    if (node == null) {
                        if (generated instanceof SourceNode) {
                            return generated;
                        } else {
                            node = {};
                        }
                    }
                    if (node.loc == null) {
                        return new SourceNode(null, null, sourceMap, generated);
                    }
                    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated);
                }
                function join(left, right) {
                    var leftSource = toSourceNode(left).toString(), rightSource = toSourceNode(right).toString(), leftChar = leftSource.charAt(leftSource.length - 1), rightChar = rightSource.charAt(0);
                    if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {
                        return [
                            left,
                            ' ',
                            right
                        ];
                    } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {
                        return [
                            left,
                            right
                        ];
                    }
                    return [
                        left,
                        space,
                        right
                    ];
                }
                function addIndent(stmt) {
                    return [
                        base,
                        stmt
                    ];
                }
                function withIndent(fn) {
                    var previousBase, result;
                    previousBase = base;
                    base += indent;
                    result = fn.call(this, base);
                    base = previousBase;
                    return result;
                }
                function calculateSpaces(str) {
                    var i;
                    for (i = str.length - 1; i >= 0; i -= 1) {
                        if (isLineTerminator(str.charAt(i))) {
                            break;
                        }
                    }
                    return str.length - 1 - i;
                }
                function adjustMultilineComment(value, specialBase) {
                    var array, i, len, line, j, ch, spaces, previousBase;
                    array = value.split(/\r\n|[\r\n]/);
                    spaces = Number.MAX_VALUE;
                    // first line doesn't have indentation
                    for (i = 1, len = array.length; i < len; i += 1) {
                        line = array[i];
                        j = 0;
                        while (j < line.length && isWhiteSpace(line[j])) {
                            j += 1;
                        }
                        if (spaces > j) {
                            spaces = j;
                        }
                    }
                    if (typeof specialBase !== 'undefined') {
                        // pattern like
                        // {
                        //   var t = 20;  /*
                        //                 * this is comment
                        //                 */
                        // }
                        previousBase = base;
                        if (array[1][spaces] === '*') {
                            specialBase += ' ';
                        }
                        base = specialBase;
                    } else {
                        if (spaces & 1) {
                            // /*
                            //  *
                            //  */
                            // If spaces are odd number, above pattern is considered.
                            // We waste 1 space.
                            spaces -= 1;
                        }
                        previousBase = base;
                    }
                    for (i = 1, len = array.length; i < len; i += 1) {
                        array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');
                    }
                    base = previousBase;
                    return array.join('\n');
                }
                function generateComment(comment, specialBase) {
                    if (comment.type === 'Line') {
                        if (endsWithLineTerminator(comment.value)) {
                            return '//' + comment.value;
                        } else {
                            // Always use LineTerminator
                            return '//' + comment.value + '\n';
                        }
                    }
                    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
                        return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
                    }
                    return '/*' + comment.value + '*/';
                }
                function addCommentsToStatement(stmt, result) {
                    var i, len, comment, save, node, tailingToStatement, specialBase, fragment;
                    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
                        save = result;
                        comment = stmt.leadingComments[0];
                        result = [];
                        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                            result.push('\n');
                        }
                        result.push(generateComment(comment));
                        if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push('\n');
                        }
                        for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {
                            comment = stmt.leadingComments[i];
                            fragment = [generateComment(comment)];
                            if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                fragment.push('\n');
                            }
                            result.push(addIndent(fragment));
                        }
                        result.push(addIndent(save));
                    }
                    if (stmt.trailingComments) {
                        tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());
                        specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([
                            base,
                            result,
                            indent
                        ]).toString()));
                        for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {
                            comment = stmt.trailingComments[i];
                            if (tailingToStatement) {
                                // We assume target like following script
                                //
                                // var t = 20;  /**
                                //               * This is comment of t
                                //               */
                                if (i === 0) {
                                    // first case
                                    result = [
                                        result,
                                        indent
                                    ];
                                } else {
                                    result = [
                                        result,
                                        specialBase
                                    ];
                                }
                                result.push(generateComment(comment, specialBase));
                            } else {
                                result = [
                                    result,
                                    addIndent(generateComment(comment))
                                ];
                            }
                            if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {
                                result = [
                                    result,
                                    '\n'
                                ];
                            }
                        }
                    }
                    return result;
                }
                function parenthesize(text, current, should) {
                    if (current < should) {
                        return [
                            '(',
                            text,
                            ')'
                        ];
                    }
                    return text;
                }
                function maybeBlock(stmt, semicolonOptional, functionBody) {
                    var result, noLeadingComment;
                    noLeadingComment = !extra.comment || !stmt.leadingComments;
                    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
                        return [
                            space,
                            generateStatement(stmt, { functionBody: functionBody })
                        ];
                    }
                    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
                        return ';';
                    }
                    withIndent(function () {
                        result = [
                            newline,
                            addIndent(generateStatement(stmt, {
                                semicolonOptional: semicolonOptional,
                                functionBody: functionBody
                            }))
                        ];
                    });
                    return result;
                }
                function maybeBlockSuffix(stmt, result) {
                    var ends = endsWithLineTerminator(toSourceNode(result).toString());
                    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
                        return [
                            result,
                            space
                        ];
                    }
                    if (ends) {
                        return [
                            result,
                            base
                        ];
                    }
                    return [
                        result,
                        newline,
                        base
                    ];
                }
                function generateVerbatim(expr, option) {
                    var i, result;
                    result = expr[extra.verbatim].split(/\r\n|\n/);
                    for (i = 1; i < result.length; i++) {
                        result[i] = newline + base + result[i];
                    }
                    result = parenthesize(result, Precedence.Sequence, option.precedence);
                    return toSourceNode(result, expr);
                }
                function generateFunctionBody(node) {
                    var result, i, len, expr;
                    result = ['('];
                    for (i = 0, len = node.params.length; i < len; i += 1) {
                        result.push(node.params[i].name);
                        if (i + 1 < len) {
                            result.push(',' + space);
                        }
                    }
                    result.push(')');
                    if (node.expression) {
                        result.push(space);
                        expr = generateExpression(node.body, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        });
                        if (expr.toString().charAt(0) === '{') {
                            expr = [
                                '(',
                                expr,
                                ')'
                            ];
                        }
                        result.push(expr);
                    } else {
                        result.push(maybeBlock(node.body, false, true));
                    }
                    return result;
                }
                function generateExpression(expr, option) {
                    var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftChar, leftSource, rightChar, rightSource, allowIn, allowCall, allowUnparenthesizedNew, property, key, value;
                    precedence = option.precedence;
                    allowIn = option.allowIn;
                    allowCall = option.allowCall;
                    type = expr.type || option.type;
                    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
                        return generateVerbatim(expr, option);
                    }
                    switch (type) {
                    case Syntax.SequenceExpression:
                        result = [];
                        allowIn |= Precedence.Sequence < precedence;
                        for (i = 0, len = expr.expressions.length; i < len; i += 1) {
                            result.push(generateExpression(expr.expressions[i], {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result = parenthesize(result, Precedence.Sequence, precedence);
                        break;
                    case Syntax.AssignmentExpression:
                        allowIn |= Precedence.Assignment < precedence;
                        result = parenthesize([
                            generateExpression(expr.left, {
                                precedence: Precedence.Call,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + expr.operator + space,
                            generateExpression(expr.right, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            })
                        ], Precedence.Assignment, precedence);
                        break;
                    case Syntax.ConditionalExpression:
                        allowIn |= Precedence.Conditional < precedence;
                        result = parenthesize([
                            generateExpression(expr.test, {
                                precedence: Precedence.LogicalOR,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + '?' + space,
                            generateExpression(expr.consequent, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            }),
                            space + ':' + space,
                            generateExpression(expr.alternate, {
                                precedence: Precedence.Assignment,
                                allowIn: allowIn,
                                allowCall: true
                            })
                        ], Precedence.Conditional, precedence);
                        break;
                    case Syntax.LogicalExpression:
                    case Syntax.BinaryExpression:
                        currentPrecedence = BinaryPrecedence[expr.operator];
                        allowIn |= currentPrecedence < precedence;
                        fragment = generateExpression(expr.left, {
                            precedence: currentPrecedence,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        leftSource = fragment.toString();
                        if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {
                            result = [
                                fragment,
                                ' ',
                                expr.operator
                            ];
                        } else {
                            result = join(fragment, expr.operator);
                        }
                        fragment = generateExpression(expr.right, {
                            precedence: currentPrecedence + 1,
                            allowIn: allowIn,
                            allowCall: true
                        });
                        if (expr.operator === '/' && fragment.toString().charAt(0) === '/') {
                            // If '/' concats with '/', it is interpreted as comment start
                            result.push(' ', fragment);
                        } else {
                            result = join(result, fragment);
                        }
                        if (expr.operator === 'in' && !allowIn) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, currentPrecedence, precedence);
                        }
                        break;
                    case Syntax.CallExpression:
                        result = [generateExpression(expr.callee, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true,
                                allowUnparenthesizedNew: false
                            })];
                        result.push('(');
                        for (i = 0, len = expr['arguments'].length; i < len; i += 1) {
                            result.push(generateExpression(expr['arguments'][i], {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                            if (i + 1 < len) {
                                result.push(',' + space);
                            }
                        }
                        result.push(')');
                        if (!allowCall) {
                            result = [
                                '(',
                                result,
                                ')'
                            ];
                        } else {
                            result = parenthesize(result, Precedence.Call, precedence);
                        }
                        break;
                    case Syntax.NewExpression:
                        len = expr['arguments'].length;
                        allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;
                        result = join('new', generateExpression(expr.callee, {
                            precedence: Precedence.New,
                            allowIn: true,
                            allowCall: false,
                            allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                        }));
                        if (!allowUnparenthesizedNew || parentheses || len > 0) {
                            result.push('(');
                            for (i = 0; i < len; i += 1) {
                                result.push(generateExpression(expr['arguments'][i], {
                                    precedence: Precedence.Assignment,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + space);
                                }
                            }
                            result.push(')');
                        }
                        result = parenthesize(result, Precedence.New, precedence);
                        break;
                    case Syntax.MemberExpression:
                        result = [generateExpression(expr.object, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: allowCall,
                                allowUnparenthesizedNew: false
                            })];
                        if (expr.computed) {
                            result.push('[', generateExpression(expr.property, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: allowCall
                            }), ']');
                        } else {
                            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                                if (result.indexOf('.') < 0) {
                                    if (!/[eExX]/.test(result) && !(result.length >= 2 && result[0] === '0')) {
                                        result.push('.');
                                    }
                                }
                            }
                            result.push('.' + expr.property.name);
                        }
                        result = parenthesize(result, Precedence.Member, precedence);
                        break;
                    case Syntax.UnaryExpression:
                        fragment = generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        });
                        if (space === '') {
                            result = join(expr.operator, fragment);
                        } else {
                            result = [expr.operator];
                            if (expr.operator.length > 2) {
                                // delete, void, typeof
                                // get `typeof []`, not `typeof[]`
                                result = join(result, fragment);
                            } else {
                                // Prevent inserting spaces between operator and argument if it is unnecessary
                                // like, `!cond`
                                leftSource = toSourceNode(result).toString();
                                leftChar = leftSource.charAt(leftSource.length - 1);
                                rightChar = fragment.toString().charAt(0);
                                if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar || isIdentifierPart(leftChar) && isIdentifierPart(rightChar)) {
                                    result.push(' ', fragment);
                                } else {
                                    result.push(fragment);
                                }
                            }
                        }
                        result = parenthesize(result, Precedence.Unary, precedence);
                        break;
                    case Syntax.YieldExpression:
                        if (expr.delegate) {
                            result = 'yield*';
                        } else {
                            result = 'yield';
                        }
                        if (expr.argument) {
                            result = join(result, generateExpression(expr.argument, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            }));
                        }
                        break;
                    case Syntax.UpdateExpression:
                        if (expr.prefix) {
                            result = parenthesize([
                                expr.operator,
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Unary,
                                    allowIn: true,
                                    allowCall: true
                                })
                            ], Precedence.Unary, precedence);
                        } else {
                            result = parenthesize([
                                generateExpression(expr.argument, {
                                    precedence: Precedence.Postfix,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                expr.operator
                            ], Precedence.Postfix, precedence);
                        }
                        break;
                    case Syntax.FunctionExpression:
                        result = 'function';
                        if (expr.id) {
                            result += ' ' + expr.id.name;
                        } else {
                            result += space;
                        }
                        result = [
                            result,
                            generateFunctionBody(expr)
                        ];
                        break;
                    case Syntax.ArrayPattern:
                    case Syntax.ArrayExpression:
                        if (!expr.elements.length) {
                            result = '[]';
                            break;
                        }
                        multiline = expr.elements.length > 1;
                        result = [
                            '[',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                                if (!expr.elements[i]) {
                                    if (multiline) {
                                        result.push(indent);
                                    }
                                    if (i + 1 === len) {
                                        result.push(',');
                                    }
                                } else {
                                    result.push(multiline ? indent : '', generateExpression(expr.elements[i], {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    }));
                                }
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '', ']');
                        break;
                    case Syntax.Property:
                        if (expr.kind === 'get' || expr.kind === 'set') {
                            result = [
                                expr.kind + ' ',
                                generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                generateFunctionBody(expr.value)
                            ];
                        } else {
                            if (expr.shorthand) {
                                result = generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                            } else if (expr.method) {
                                result = [];
                                if (expr.value.generator) {
                                    result.push('*');
                                }
                                result.push(generateExpression(expr.key, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), generateFunctionBody(expr.value));
                            } else {
                                result = [
                                    generateExpression(expr.key, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    }),
                                    ':' + space,
                                    generateExpression(expr.value, {
                                        precedence: Precedence.Assignment,
                                        allowIn: true,
                                        allowCall: true
                                    })
                                ];
                            }
                        }
                        break;
                    case Syntax.ObjectExpression:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = expr.properties.length > 1;
                        withIndent(function (indent) {
                            fragment = generateExpression(expr.properties[0], {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true,
                                type: Syntax.Property
                            });
                        });
                        if (!multiline) {
                            // issues 4
                            // Do not transform from
                            //   dejavu.Class.declare({
                            //       method2: function () {}
                            //   });
                            // to
                            //   dejavu.Class.declare({method2: function () {
                            //       }});
                            if (!hasLineTerminator(toSourceNode(fragment).toString())) {
                                result = [
                                    '{',
                                    space,
                                    fragment,
                                    space,
                                    '}'
                                ];
                                break;
                            }
                        }
                        withIndent(function (indent) {
                            result = [
                                '{',
                                newline,
                                indent,
                                fragment
                            ];
                            if (multiline) {
                                result.push(',' + newline);
                                for (i = 1, len = expr.properties.length; i < len; i += 1) {
                                    result.push(indent, generateExpression(expr.properties[i], {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true,
                                        type: Syntax.Property
                                    }));
                                    if (i + 1 < len) {
                                        result.push(',' + newline);
                                    }
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base, '}');
                        break;
                    case Syntax.ObjectPattern:
                        if (!expr.properties.length) {
                            result = '{}';
                            break;
                        }
                        multiline = false;
                        if (expr.properties.length === 1) {
                            property = expr.properties[0];
                            if (property.value.type !== Syntax.Identifier) {
                                multiline = true;
                            }
                        } else {
                            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                                property = expr.properties[i];
                                if (!property.shorthand) {
                                    multiline = true;
                                    break;
                                }
                            }
                        }
                        result = [
                            '{',
                            multiline ? newline : ''
                        ];
                        withIndent(function (indent) {
                            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                                result.push(multiline ? indent : '', generateExpression(expr.properties[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }));
                                if (i + 1 < len) {
                                    result.push(',' + (multiline ? newline : space));
                                }
                            }
                        });
                        if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                            result.push(newline);
                        }
                        result.push(multiline ? base : '', '}');
                        break;
                    case Syntax.ThisExpression:
                        result = 'this';
                        break;
                    case Syntax.Identifier:
                        result = expr.name;
                        break;
                    case Syntax.Literal:
                        if (expr.hasOwnProperty('raw') && parse) {
                            try {
                                raw = parse(expr.raw).body[0].expression;
                                if (raw.type === Syntax.Literal) {
                                    if (raw.value === expr.value) {
                                        result = expr.raw;
                                        break;
                                    }
                                }
                            } catch (e) {
                            }
                        }
                        if (expr.value === null) {
                            result = 'null';
                            break;
                        }
                        if (typeof expr.value === 'string') {
                            result = escapeString(expr.value);
                            break;
                        }
                        if (typeof expr.value === 'number') {
                            result = generateNumber(expr.value);
                            break;
                        }
                        result = expr.value.toString();
                        break;
                    case Syntax.ComprehensionExpression:
                        result = [
                            '[',
                            generateExpression(expr.body, {
                                precedence: Precedence.Assignment,
                                allowIn: true,
                                allowCall: true
                            })
                        ];
                        if (expr.blocks) {
                            for (i = 0, len = expr.blocks.length; i < len; i += 1) {
                                fragment = generateExpression(expr.blocks[i], {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                });
                                result = join(result, fragment);
                            }
                        }
                        if (expr.filter) {
                            result = join(result, 'if' + space);
                            fragment = generateExpression(expr.filter, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            });
                            if (extra.moz.parenthesizedComprehensionBlock) {
                                result = join(result, [
                                    '(',
                                    fragment,
                                    ')'
                                ]);
                            } else {
                                result = join(result, fragment);
                            }
                        }
                        result.push(']');
                        break;
                    case Syntax.ComprehensionBlock:
                        if (expr.left.type === Syntax.VariableDeclaration) {
                            fragment = [
                                expr.left.kind + ' ',
                                generateStatement(expr.left.declarations[0], { allowIn: false })
                            ];
                        } else {
                            fragment = generateExpression(expr.left, {
                                precedence: Precedence.Call,
                                allowIn: true,
                                allowCall: true
                            });
                        }
                        fragment = join(fragment, expr.of ? 'of' : 'in');
                        fragment = join(fragment, generateExpression(expr.right, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }));
                        if (extra.moz.parenthesizedComprehensionBlock) {
                            result = [
                                'for' + space + '(',
                                fragment,
                                ')'
                            ];
                        } else {
                            result = join('for' + space, fragment);
                        }
                        break;
                    default:
                        throw new Error('Unknown expression type: ' + expr.type);
                    }
                    return toSourceNode(result, expr);
                }
                function generateStatement(stmt, option) {
                    var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;
                    allowIn = true;
                    semicolon = ';';
                    functionBody = false;
                    directiveContext = false;
                    if (option) {
                        allowIn = option.allowIn === undefined || option.allowIn;
                        if (!semicolons && option.semicolonOptional === true) {
                            semicolon = '';
                        }
                        functionBody = option.functionBody;
                        directiveContext = option.directiveContext;
                    }
                    switch (stmt.type) {
                    case Syntax.BlockStatement:
                        result = [
                            '{',
                            newline
                        ];
                        withIndent(function () {
                            for (i = 0, len = stmt.body.length; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.body[i], {
                                    semicolonOptional: i === len - 1,
                                    directiveContext: functionBody
                                }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        result.push(addIndent('}'));
                        break;
                    case Syntax.BreakStatement:
                        if (stmt.label) {
                            result = 'break ' + stmt.label.name + semicolon;
                        } else {
                            result = 'break' + semicolon;
                        }
                        break;
                    case Syntax.ContinueStatement:
                        if (stmt.label) {
                            result = 'continue ' + stmt.label.name + semicolon;
                        } else {
                            result = 'continue' + semicolon;
                        }
                        break;
                    case Syntax.DirectiveStatement:
                        if (stmt.raw) {
                            result = stmt.raw + semicolon;
                        } else {
                            result = escapeDirective(stmt.directive) + semicolon;
                        }
                        break;
                    case Syntax.DoWhileStatement:
                        // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
                        result = join('do', maybeBlock(stmt.body));
                        result = maybeBlockSuffix(stmt.body, result);
                        result = join(result, [
                            'while' + space + '(',
                            generateExpression(stmt.test, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            }),
                            ')' + semicolon
                        ]);
                        break;
                    case Syntax.CatchClause:
                        withIndent(function () {
                            result = [
                                'catch' + space + '(',
                                generateExpression(stmt.param, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body));
                        break;
                    case Syntax.DebuggerStatement:
                        result = 'debugger' + semicolon;
                        break;
                    case Syntax.EmptyStatement:
                        result = ';';
                        break;
                    case Syntax.ExpressionStatement:
                        result = [generateExpression(stmt.expression, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })];
                        // 12.4 '{', 'function' is not allowed in this position.
                        // wrap expression with parentheses
                        if (result.toString().charAt(0) === '{' || result.toString().slice(0, 8) === 'function' && ' ('.indexOf(result.toString().charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
                            result = [
                                '(',
                                result,
                                ')' + semicolon
                            ];
                        } else {
                            result.push(semicolon);
                        }
                        break;
                    case Syntax.VariableDeclarator:
                        if (stmt.init) {
                            result = [
                                generateExpression(stmt.id, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                }) + space + '=' + space,
                                generateExpression(stmt.init, {
                                    precedence: Precedence.Assignment,
                                    allowIn: allowIn,
                                    allowCall: true
                                })
                            ];
                        } else {
                            result = stmt.id.name;
                        }
                        break;
                    case Syntax.VariableDeclaration:
                        result = [stmt.kind];
                        // special path for
                        // var x = function () {
                        // };
                        if (stmt.declarations.length === 1 && stmt.declarations[0].init && stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                            result.push(' ', generateStatement(stmt.declarations[0], { allowIn: allowIn }));
                        } else {
                            // VariableDeclarator is typed as Statement,
                            // but joined with comma (not LineTerminator).
                            // So if comment is attached to target node, we should specialize.
                            withIndent(function () {
                                node = stmt.declarations[0];
                                if (extra.comment && node.leadingComments) {
                                    result.push('\n', addIndent(generateStatement(node, { allowIn: allowIn })));
                                } else {
                                    result.push(' ', generateStatement(node, { allowIn: allowIn }));
                                }
                                for (i = 1, len = stmt.declarations.length; i < len; i += 1) {
                                    node = stmt.declarations[i];
                                    if (extra.comment && node.leadingComments) {
                                        result.push(',' + newline, addIndent(generateStatement(node, { allowIn: allowIn })));
                                    } else {
                                        result.push(',' + space, generateStatement(node, { allowIn: allowIn }));
                                    }
                                }
                            });
                        }
                        result.push(semicolon);
                        break;
                    case Syntax.ThrowStatement:
                        result = [
                            join('throw', generateExpression(stmt.argument, {
                                precedence: Precedence.Sequence,
                                allowIn: true,
                                allowCall: true
                            })),
                            semicolon
                        ];
                        break;
                    case Syntax.TryStatement:
                        result = [
                            'try',
                            maybeBlock(stmt.block)
                        ];
                        result = maybeBlockSuffix(stmt.block, result);
                        for (i = 0, len = stmt.handlers.length; i < len; i += 1) {
                            result = join(result, generateStatement(stmt.handlers[i]));
                            if (stmt.finalizer || i + 1 !== len) {
                                result = maybeBlockSuffix(stmt.handlers[i].body, result);
                            }
                        }
                        if (stmt.finalizer) {
                            result = join(result, [
                                'finally',
                                maybeBlock(stmt.finalizer)
                            ]);
                        }
                        break;
                    case Syntax.SwitchStatement:
                        withIndent(function () {
                            result = [
                                'switch' + space + '(',
                                generateExpression(stmt.discriminant, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')' + space + '{' + newline
                            ];
                        });
                        if (stmt.cases) {
                            for (i = 0, len = stmt.cases.length; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.cases[i], { semicolonOptional: i === len - 1 }));
                                result.push(fragment);
                                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        }
                        result.push(addIndent('}'));
                        break;
                    case Syntax.SwitchCase:
                        withIndent(function () {
                            if (stmt.test) {
                                result = [
                                    join('case', generateExpression(stmt.test, {
                                        precedence: Precedence.Sequence,
                                        allowIn: true,
                                        allowCall: true
                                    })),
                                    ':'
                                ];
                            } else {
                                result = ['default:'];
                            }
                            i = 0;
                            len = stmt.consequent.length;
                            if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                                fragment = maybeBlock(stmt.consequent[0]);
                                result.push(fragment);
                                i = 1;
                            }
                            if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {
                                result.push(newline);
                            }
                            for (; i < len; i += 1) {
                                fragment = addIndent(generateStatement(stmt.consequent[i], { semicolonOptional: i === len - 1 && semicolon === '' }));
                                result.push(fragment);
                                if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                    result.push(newline);
                                }
                            }
                        });
                        break;
                    case Syntax.IfStatement:
                        withIndent(function () {
                            result = [
                                'if' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        if (stmt.alternate) {
                            result.push(maybeBlock(stmt.consequent));
                            result = maybeBlockSuffix(stmt.consequent, result);
                            if (stmt.alternate.type === Syntax.IfStatement) {
                                result = join(result, [
                                    'else ',
                                    generateStatement(stmt.alternate, { semicolonOptional: semicolon === '' })
                                ]);
                            } else {
                                result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                            }
                        } else {
                            result.push(maybeBlock(stmt.consequent, semicolon === ''));
                        }
                        break;
                    case Syntax.ForStatement:
                        withIndent(function () {
                            result = ['for' + space + '('];
                            if (stmt.init) {
                                if (stmt.init.type === Syntax.VariableDeclaration) {
                                    result.push(generateStatement(stmt.init, { allowIn: false }));
                                } else {
                                    result.push(generateExpression(stmt.init, {
                                        precedence: Precedence.Sequence,
                                        allowIn: false,
                                        allowCall: true
                                    }), ';');
                                }
                            } else {
                                result.push(';');
                            }
                            if (stmt.test) {
                                result.push(space, generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), ';');
                            } else {
                                result.push(';');
                            }
                            if (stmt.update) {
                                result.push(space, generateExpression(stmt.update, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }), ')');
                            } else {
                                result.push(')');
                            }
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.ForInStatement:
                        result = ['for' + space + '('];
                        withIndent(function () {
                            if (stmt.left.type === Syntax.VariableDeclaration) {
                                withIndent(function () {
                                    result.push(stmt.left.kind + ' ', generateStatement(stmt.left.declarations[0], { allowIn: false }));
                                });
                            } else {
                                result.push(generateExpression(stmt.left, {
                                    precedence: Precedence.Call,
                                    allowIn: true,
                                    allowCall: true
                                }));
                            }
                            result = join(result, 'in');
                            result = [
                                join(result, generateExpression(stmt.right, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.LabeledStatement:
                        result = [
                            stmt.label.name + ':',
                            maybeBlock(stmt.body, semicolon === '')
                        ];
                        break;
                    case Syntax.Program:
                        len = stmt.body.length;
                        result = [safeConcatenation && len > 0 ? '\n' : ''];
                        for (i = 0; i < len; i += 1) {
                            fragment = addIndent(generateStatement(stmt.body[i], {
                                semicolonOptional: !safeConcatenation && i === len - 1,
                                directiveContext: true
                            }));
                            result.push(fragment);
                            if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                                result.push(newline);
                            }
                        }
                        break;
                    case Syntax.FunctionDeclaration:
                        result = [
                            (stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function ') + stmt.id.name,
                            generateFunctionBody(stmt)
                        ];
                        break;
                    case Syntax.ReturnStatement:
                        if (stmt.argument) {
                            result = [
                                join('return', generateExpression(stmt.argument, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                })),
                                semicolon
                            ];
                        } else {
                            result = ['return' + semicolon];
                        }
                        break;
                    case Syntax.WhileStatement:
                        withIndent(function () {
                            result = [
                                'while' + space + '(',
                                generateExpression(stmt.test, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    case Syntax.WithStatement:
                        withIndent(function () {
                            result = [
                                'with' + space + '(',
                                generateExpression(stmt.object, {
                                    precedence: Precedence.Sequence,
                                    allowIn: true,
                                    allowCall: true
                                }),
                                ')'
                            ];
                        });
                        result.push(maybeBlock(stmt.body, semicolon === ''));
                        break;
                    default:
                        throw new Error('Unknown statement type: ' + stmt.type);
                    }
                    // Attach comments
                    if (extra.comment) {
                        result = addCommentsToStatement(stmt, result);
                    }
                    fragment = toSourceNode(result).toString();
                    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
                        result = toSourceNode(result).replaceRight(/\s+$/, '');
                    }
                    return toSourceNode(result, stmt);
                }
                function generate(node, options) {
                    var defaultOptions = getDefaultOptions(), result, pair;
                    if (options != null) {
                        // Obsolete options
                        //
                        //   `options.indent`
                        //   `options.base`
                        //
                        // Instead of them, we can use `option.format.indent`.
                        if (typeof options.indent === 'string') {
                            defaultOptions.format.indent.style = options.indent;
                        }
                        if (typeof options.base === 'number') {
                            defaultOptions.format.indent.base = options.base;
                        }
                        options = updateDeeply(defaultOptions, options);
                        indent = options.format.indent.style;
                        if (typeof options.base === 'string') {
                            base = options.base;
                        } else {
                            base = stringRepeat(indent, options.format.indent.base);
                        }
                    } else {
                        options = defaultOptions;
                        indent = options.format.indent.style;
                        base = stringRepeat(indent, options.format.indent.base);
                    }
                    json = options.format.json;
                    renumber = options.format.renumber;
                    hexadecimal = json ? false : options.format.hexadecimal;
                    quotes = json ? 'double' : options.format.quotes;
                    escapeless = options.format.escapeless;
                    if (options.format.compact) {
                        newline = space = indent = base = '';
                    } else {
                        newline = '\n';
                        space = ' ';
                    }
                    parentheses = options.format.parentheses;
                    semicolons = options.format.semicolons;
                    safeConcatenation = options.format.safeConcatenation;
                    directive = options.directive;
                    parse = json ? null : options.parse;
                    sourceMap = options.sourceMap;
                    extra = options;
                    if (sourceMap) {
                        if (!exports.browser) {
                            // We assume environment is node.js
                            // And prevent from including source-map by browserify
                            SourceNode = source_map.SourceNode;
                        } else {
                            SourceNode = global.sourceMap.SourceNode;
                        }
                    } else {
                        SourceNode = SourceNodeMock;
                    }
                    switch (node.type) {
                    case Syntax.BlockStatement:
                    case Syntax.BreakStatement:
                    case Syntax.CatchClause:
                    case Syntax.ContinueStatement:
                    case Syntax.DirectiveStatement:
                    case Syntax.DoWhileStatement:
                    case Syntax.DebuggerStatement:
                    case Syntax.EmptyStatement:
                    case Syntax.ExpressionStatement:
                    case Syntax.ForStatement:
                    case Syntax.ForInStatement:
                    case Syntax.FunctionDeclaration:
                    case Syntax.IfStatement:
                    case Syntax.LabeledStatement:
                    case Syntax.Program:
                    case Syntax.ReturnStatement:
                    case Syntax.SwitchStatement:
                    case Syntax.SwitchCase:
                    case Syntax.ThrowStatement:
                    case Syntax.TryStatement:
                    case Syntax.VariableDeclaration:
                    case Syntax.VariableDeclarator:
                    case Syntax.WhileStatement:
                    case Syntax.WithStatement:
                        result = generateStatement(node);
                        break;
                    case Syntax.AssignmentExpression:
                    case Syntax.ArrayExpression:
                    case Syntax.ArrayPattern:
                    case Syntax.BinaryExpression:
                    case Syntax.CallExpression:
                    case Syntax.ConditionalExpression:
                    case Syntax.FunctionExpression:
                    case Syntax.Identifier:
                    case Syntax.Literal:
                    case Syntax.LogicalExpression:
                    case Syntax.MemberExpression:
                    case Syntax.NewExpression:
                    case Syntax.ObjectExpression:
                    case Syntax.ObjectPattern:
                    case Syntax.Property:
                    case Syntax.SequenceExpression:
                    case Syntax.ThisExpression:
                    case Syntax.UnaryExpression:
                    case Syntax.UpdateExpression:
                    case Syntax.YieldExpression:
                        result = generateExpression(node, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });
                        break;
                    default:
                        throw new Error('Unknown node type: ' + node.type);
                    }
                    if (!sourceMap) {
                        return result.toString();
                    }
                    pair = result.toStringWithSourceMap({
                        file: options.sourceMap,
                        sourceRoot: options.sourceMapRoot
                    });
                    if (options.sourceMapWithCode) {
                        return pair;
                    }
                    return pair.map.toString();
                }
                // simple visitor implementation
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    ArrayPattern: ['elements'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    DebuggerStatement: [],
                    EmptyStatement: [],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    ObjectPattern: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ],
                    YieldExpression: ['argument']
                };
                VisitorOption = {
                    Break: 1,
                    Skip: 2
                };
                // based on LLVM libc++ upper_bound / lower_bound
                // MIT License
                function upperBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            len = diff;
                        } else {
                            i = current + 1;
                            len -= diff + 1;
                        }
                    }
                    return i;
                }
                function lowerBound(array, func) {
                    var diff, len, i, current;
                    len = array.length;
                    i = 0;
                    while (len) {
                        diff = len >>> 1;
                        current = i + diff;
                        if (func(array[current])) {
                            i = current + 1;
                            len -= diff + 1;
                        } else {
                            len = diff;
                        }
                    }
                    return i;
                }
                function extendCommentRange(comment, tokens) {
                    var target, token;
                    target = upperBound(tokens, function search(token) {
                        return token.range[0] > comment.range[0];
                    });
                    comment.extendedRange = [
                        comment.range[0],
                        comment.range[1]
                    ];
                    if (target !== tokens.length) {
                        comment.extendedRange[1] = tokens[target].range[0];
                    }
                    target -= 1;
                    if (target >= 0) {
                        if (target < tokens.length) {
                            comment.extendedRange[0] = tokens[target].range[1];
                        } else if (token.length) {
                            comment.extendedRange[1] = tokens[tokens.length - 1].range[0];
                        }
                    }
                    return comment;
                }
                function attachComments(tree, providedComments, tokens) {
                    // At first, we should calculate extended comment ranges.
                    var comments = [], comment, len, i;
                    if (!tree.range) {
                        throw new Error('attachComments needs range information');
                    }
                    // tokens array is empty, we attach comments to tree as 'leadingComments'
                    if (!tokens.length) {
                        if (providedComments.length) {
                            for (i = 0, len = providedComments.length; i < len; i += 1) {
                                comment = deepCopy(providedComments[i]);
                                comment.extendedRange = [
                                    0,
                                    tree.range[0]
                                ];
                                comments.push(comment);
                            }
                            tree.leadingComments = comments;
                        }
                        return tree;
                    }
                    for (i = 0, len = providedComments.length; i < len; i += 1) {
                        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
                    }
                    // This is based on John Freeman's implementation.
                    traverse(tree, {
                        cursor: 0,
                        enter: function (node) {
                            var comment;
                            while (this.cursor < comments.length) {
                                comment = comments[this.cursor];
                                if (comment.extendedRange[1] > node.range[0]) {
                                    break;
                                }
                                if (comment.extendedRange[1] === node.range[0]) {
                                    if (!node.leadingComments) {
                                        node.leadingComments = [];
                                    }
                                    node.leadingComments.push(comment);
                                    comments.splice(this.cursor, 1);
                                } else {
                                    this.cursor += 1;
                                }
                            }
                            // already out of owned node
                            if (this.cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[this.cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    traverse(tree, {
                        cursor: 0,
                        leave: function (node) {
                            var comment;
                            while (this.cursor < comments.length) {
                                comment = comments[this.cursor];
                                if (node.range[1] < comment.extendedRange[0]) {
                                    break;
                                }
                                if (node.range[1] === comment.extendedRange[0]) {
                                    if (!node.trailingComments) {
                                        node.trailingComments = [];
                                    }
                                    node.trailingComments.push(comment);
                                    comments.splice(this.cursor, 1);
                                } else {
                                    this.cursor += 1;
                                }
                            }
                            // already out of owned node
                            if (this.cursor === comments.length) {
                                return VisitorOption.Break;
                            }
                            if (comments[this.cursor].extendedRange[0] > node.range[1]) {
                                return VisitorOption.Skip;
                            }
                        }
                    });
                    return tree;
                }
                // Sync with package.json.
                exports.version = '0.0.17';
                exports.generate = generate;
                exports.attachComments = attachComments;
                exports.browser = false;
            }());    /* vim: set sw=4 ts=4 et tw=80 : */
            return exports;
        });
        require.define('/node_modules/estraverse/package.json', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            module.exports = { 'main': 'estraverse.js' };
            return exports;
        });
        require.define('/node_modules/estraverse/estraverse.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            /*
              Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
              Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
            
              Redistribution and use in source and binary forms, with or without
              modification, are permitted provided that the following conditions are met:
            
                * Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.
                * Redistributions in binary form must reproduce the above copyright
                  notice, this list of conditions and the following disclaimer in the
                  documentation and/or other materials provided with the distribution.
            
              THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
              AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
              IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
              ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
              DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
              (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
              LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
              ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
              THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */
            /*jslint bitwise:true */
            /*global exports:true, define:true, window:true */
            (function (factory) {
                'use strict';
                // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
                // and plain browser loading,
                if (true) {
                    escodegen = function () {
                        return factory();
                    }({});
                } else if (typeof exports !== 'undefined') {
                    factory(exports);
                } else {
                    factory(window.estraverse = {});
                }
            }(function (exports) {
                exports = exports || {};
                'use strict';
                var Syntax, isArray, VisitorOption, VisitorKeys, wrappers;
                Syntax = {
                    AssignmentExpression: 'AssignmentExpression',
                    ArrayExpression: 'ArrayExpression',
                    BlockStatement: 'BlockStatement',
                    BinaryExpression: 'BinaryExpression',
                    BreakStatement: 'BreakStatement',
                    CallExpression: 'CallExpression',
                    CatchClause: 'CatchClause',
                    ConditionalExpression: 'ConditionalExpression',
                    ContinueStatement: 'ContinueStatement',
                    DebuggerStatement: 'DebuggerStatement',
                    DirectiveStatement: 'DirectiveStatement',
                    DoWhileStatement: 'DoWhileStatement',
                    EmptyStatement: 'EmptyStatement',
                    ExpressionStatement: 'ExpressionStatement',
                    ForStatement: 'ForStatement',
                    ForInStatement: 'ForInStatement',
                    FunctionDeclaration: 'FunctionDeclaration',
                    FunctionExpression: 'FunctionExpression',
                    Identifier: 'Identifier',
                    IfStatement: 'IfStatement',
                    Literal: 'Literal',
                    LabeledStatement: 'LabeledStatement',
                    LogicalExpression: 'LogicalExpression',
                    MemberExpression: 'MemberExpression',
                    NewExpression: 'NewExpression',
                    ObjectExpression: 'ObjectExpression',
                    Program: 'Program',
                    Property: 'Property',
                    ReturnStatement: 'ReturnStatement',
                    SequenceExpression: 'SequenceExpression',
                    SwitchStatement: 'SwitchStatement',
                    SwitchCase: 'SwitchCase',
                    ThisExpression: 'ThisExpression',
                    ThrowStatement: 'ThrowStatement',
                    TryStatement: 'TryStatement',
                    UnaryExpression: 'UnaryExpression',
                    UpdateExpression: 'UpdateExpression',
                    VariableDeclaration: 'VariableDeclaration',
                    VariableDeclarator: 'VariableDeclarator',
                    WhileStatement: 'WhileStatement',
                    WithStatement: 'WithStatement'
                };
                isArray = Array.isArray;
                if (!isArray) {
                    isArray = function isArray(array) {
                        return Object.prototype.toString.call(array) === '[object Array]';
                    };
                }
                VisitorKeys = {
                    AssignmentExpression: [
                        'left',
                        'right'
                    ],
                    ArrayExpression: ['elements'],
                    BlockStatement: ['body'],
                    BinaryExpression: [
                        'left',
                        'right'
                    ],
                    BreakStatement: ['label'],
                    CallExpression: [
                        'callee',
                        'arguments'
                    ],
                    CatchClause: [
                        'param',
                        'body'
                    ],
                    ConditionalExpression: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    ContinueStatement: ['label'],
                    DebuggerStatement: [],
                    DirectiveStatement: [],
                    DoWhileStatement: [
                        'body',
                        'test'
                    ],
                    EmptyStatement: [],
                    ExpressionStatement: ['expression'],
                    ForStatement: [
                        'init',
                        'test',
                        'update',
                        'body'
                    ],
                    ForInStatement: [
                        'left',
                        'right',
                        'body'
                    ],
                    FunctionDeclaration: [
                        'id',
                        'params',
                        'body'
                    ],
                    FunctionExpression: [
                        'id',
                        'params',
                        'body'
                    ],
                    Identifier: [],
                    IfStatement: [
                        'test',
                        'consequent',
                        'alternate'
                    ],
                    Literal: [],
                    LabeledStatement: [
                        'label',
                        'body'
                    ],
                    LogicalExpression: [
                        'left',
                        'right'
                    ],
                    MemberExpression: [
                        'object',
                        'property'
                    ],
                    NewExpression: [
                        'callee',
                        'arguments'
                    ],
                    ObjectExpression: ['properties'],
                    Program: ['body'],
                    Property: [
                        'key',
                        'value'
                    ],
                    ReturnStatement: ['argument'],
                    SequenceExpression: ['expressions'],
                    SwitchStatement: [
                        'discriminant',
                        'cases'
                    ],
                    SwitchCase: [
                        'test',
                        'consequent'
                    ],
                    ThisExpression: [],
                    ThrowStatement: ['argument'],
                    TryStatement: [
                        'block',
                        'handlers',
                        'finalizer'
                    ],
                    UnaryExpression: ['argument'],
                    UpdateExpression: ['argument'],
                    VariableDeclaration: ['declarations'],
                    VariableDeclarator: [
                        'id',
                        'init'
                    ],
                    WhileStatement: [
                        'test',
                        'body'
                    ],
                    WithStatement: [
                        'object',
                        'body'
                    ]
                };
                VisitorOption = {
                    Break: 1,
                    Skip: 2
                };
                wrappers = { PropertyWrapper: 'Property' };
                function traverse(top, visitor) {
                    var worklist, leavelist, node, nodeType, ret, current, current2, candidates, candidate, marker = {};
                    worklist = [top];
                    leavelist = [null];
                    while (worklist.length) {
                        node = worklist.pop();
                        nodeType = node.type;
                        if (node === marker) {
                            node = leavelist.pop();
                            if (visitor.leave) {
                                ret = visitor.leave(node, leavelist[leavelist.length - 1]);
                            } else {
                                ret = undefined;
                            }
                            if (ret === VisitorOption.Break) {
                                return;
                            }
                        } else if (node) {
                            if (wrappers.hasOwnProperty(nodeType)) {
                                node = node.node;
                                nodeType = wrappers[nodeType];
                            }
                            if (visitor.enter) {
                                ret = visitor.enter(node, leavelist[leavelist.length - 1]);
                            } else {
                                ret = undefined;
                            }
                            if (ret === VisitorOption.Break) {
                                return;
                            }
                            worklist.push(marker);
                            leavelist.push(node);
                            if (ret !== VisitorOption.Skip) {
                                candidates = VisitorKeys[nodeType];
                                current = candidates.length;
                                while ((current -= 1) >= 0) {
                                    candidate = node[candidates[current]];
                                    if (candidate) {
                                        if (isArray(candidate)) {
                                            current2 = candidate.length;
                                            while ((current2 -= 1) >= 0) {
                                                if (candidate[current2]) {
                                                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {
                                                        worklist.push({
                                                            type: 'PropertyWrapper',
                                                            node: candidate[current2]
                                                        });
                                                    } else {
                                                        worklist.push(candidate[current2]);
                                                    }
                                                }
                                            }
                                        } else {
                                            worklist.push(candidate);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                function replace(top, visitor) {
                    var worklist, leavelist, node, nodeType, target, tuple, ret, current, current2, candidates, candidate, marker = {}, result;
                    result = { top: top };
                    tuple = [
                        top,
                        result,
                        'top'
                    ];
                    worklist = [tuple];
                    leavelist = [tuple];
                    function notify(v) {
                        ret = v;
                    }
                    while (worklist.length) {
                        tuple = worklist.pop();
                        if (tuple === marker) {
                            tuple = leavelist.pop();
                            ret = undefined;
                            if (visitor.leave) {
                                node = tuple[0];
                                target = visitor.leave(tuple[0], leavelist[leavelist.length - 1][0], notify);
                                if (target !== undefined) {
                                    node = target;
                                }
                                tuple[1][tuple[2]] = node;
                            }
                            if (ret === VisitorOption.Break) {
                                return result.top;
                            }
                        } else if (tuple[0]) {
                            ret = undefined;
                            node = tuple[0];
                            nodeType = node.type;
                            if (wrappers.hasOwnProperty(nodeType)) {
                                tuple[0] = node = node.node;
                                nodeType = wrappers[nodeType];
                            }
                            if (visitor.enter) {
                                target = visitor.enter(tuple[0], leavelist[leavelist.length - 1][0], notify);
                                if (target !== undefined) {
                                    node = target;
                                }
                                tuple[1][tuple[2]] = node;
                                tuple[0] = node;
                            }
                            if (ret === VisitorOption.Break) {
                                return result.top;
                            }
                            if (tuple[0]) {
                                worklist.push(marker);
                                leavelist.push(tuple);
                                if (ret !== VisitorOption.Skip) {
                                    candidates = VisitorKeys[nodeType];
                                    current = candidates.length;
                                    while ((current -= 1) >= 0) {
                                        candidate = node[candidates[current]];
                                        if (candidate) {
                                            if (isArray(candidate)) {
                                                current2 = candidate.length;
                                                while ((current2 -= 1) >= 0) {
                                                    if (candidate[current2]) {
                                                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current] && null == candidates[current].type) {
                                                            worklist.push([
                                                                {
                                                                    type: 'PropertyWrapper',
                                                                    node: candidate[current2]
                                                                },
                                                                candidate,
                                                                current2
                                                            ]);
                                                        } else {
                                                            worklist.push([
                                                                candidate[current2],
                                                                candidate,
                                                                current2
                                                            ]);
                                                        }
                                                    }
                                                }
                                            } else {
                                                worklist.push([
                                                    candidate,
                                                    node,
                                                    candidates[current]
                                                ]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return result.top;
                }
                exports.version = '0.0.4';
                exports.Syntax = Syntax;
                exports.traverse = traverse;
                exports.replace = replace;
                exports.VisitorKeys = VisitorKeys;
                exports.VisitorOption = VisitorOption;
                return exports;
            }));    /* vim: set sw=4 ts=4 et tw=80 : */
            return exports;
        });
        require.define('/tools/entry-point.js', function (require, module, exports, __dirname, __filename, process, global) {
            exports = exports || {};
            /*
              Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
            
              Redistribution and use in source and binary forms, with or without
              modification, are permitted provided that the following conditions are met:
            
                * Redistributions of source code must retain the above copyright
                  notice, this list of conditions and the following disclaimer.
                * Redistributions in binary form must reproduce the above copyright
                  notice, this list of conditions and the following disclaimer in the
                  documentation and/or other materials provided with the distribution.
            
              THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
              AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
              IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
              ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
              DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
              (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
              LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
              ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
              THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */
            (function () {
                'use strict';
                var escodegen;
                escodegen = global.escodegen = escodegen;
                escodegen.browser = true;
            }());
            return exports;
        });
    }());
    /*! amdclean - v2.0.0 - 2014-05-12
    * http://gregfranko.com/amdclean
    * Copyright (c) 2014 Greg Franko; Licensed MIT */
    (function (root, factory, undefined) {
        'use strict';
        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, and plain browser loading
        if (true) {
            if (typeof exports !== 'undefined') {
                factory.env = 'node';
            } else {
                factory.env = 'web';
            }
            factory.amd = true;
            amdclean = function () {
                return factory({
                    'esprima': esprima,
                    'estraverse': estraverse,
                    'escodegen': escodegen,
                    'underscore': underscore
                }, root);
            }();
        } else if (typeof exports !== 'undefined') {
            factory.env = 'node';
            module.exports = factory(null, root);
        } else {
            factory.env = 'web';
            root.amdclean = factory(null, root);
        }
    }(this, function cleanamd(amdDependencies, scope) {
        'use strict';
        amdDependencies = amdDependencies || {};
        // Environment - either node or web
        var codeEnv = cleanamd.env, that = scope,
            // Third-Party Dependencies
            esprima = function () {
                if (cleanamd.amd && amdDependencies.esprima && amdDependencies.esprima.parse) {
                    return amdDependencies.esprima;
                } else if (that && that.esprima && that.esprima.parse) {
                    return that.esprima;
                } else if (codeEnv === 'node') {
                    return esprima;
                }
            }(), estraverse = function () {
                if (cleanamd.amd && amdDependencies.estraverse && amdDependencies.estraverse.traverse) {
                    return amdDependencies.estraverse;
                } else if (that && that.estraverse && that.estraverse.traverse) {
                    return that.estraverse;
                } else if (codeEnv === 'node') {
                    return estraverse;
                }
            }(), escodegen = function () {
                if (cleanamd.amd && amdDependencies.escodegen && amdDependencies.escodegen.generate) {
                    return amdDependencies.escodegen;
                } else if (that && that.escodegen && that.escodegen.generate) {
                    return that.escodegen;
                } else if (codeEnv === 'node') {
                    return escodegen;
                }
            }(), _ = function () {
                if (cleanamd.amd && amdDependencies.underscore) {
                    return amdDependencies.underscore;
                } else if (that && that._) {
                    return that._;
                } else if (codeEnv === 'node') {
                    return lodash;
                }
            }(), fs = codeEnv === 'node' ? fs : {},
            // End Third-Party Dependencies
            // The Public API object
            publicAPI = {
                'VERSION': '2.0.0',
                'defaultOptions': {
                    'code': '',
                    'filePath': '',
                    'globalModules': [],
                    'esprima': {
                        'comment': true,
                        'loc': true,
                        'range': true,
                        'tokens': true
                    },
                    'escodegen': {
                        'comment': true,
                        'format': { 'indent': { 'adjustMultilineComment': true } }
                    },
                    'commentCleanName': 'amdclean',
                    'ignoreModules': [],
                    'removeModules': [],
                    'removeAllRequires': false,
                    'removeUseStricts': true,
                    'transformAMDChecks': true,
                    'shimOverrides': {},
                    'prefixMode': 'standard',
                    'prefixTransform': function (moduleName) {
                        return moduleName;
                    },
                    'wrap': {
                        'start': '',
                        'end': ''
                    },
                    'aggressiveOptimizations': false
                },
                'env': codeEnv,
                'errorMsgs': {
                    'emptyCode': 'There is no code to generate the AST with',
                    'emptyAst': function (methodName) {
                        return 'An AST is not being passed to the ' + methodName + '() method';
                    },
                    'invalidObject': function (methodName) {
                        return 'An object is not being passed as the first parameter to the ' + methodName + '() method';
                    },
                    'lodash': 'There is not an _.isPlainObject() method.  Make sure you have included lodash (https://github.com/lodash/lodash).',
                    'esprima': 'There is not an esprima.parse() method.  Make sure you have included esprima (https://github.com/ariya/esprima).',
                    'estraverse': 'There is not an estraverse.replace() method.  Make sure you have included estraverse (https://github.com/Constellation/estraverse).',
                    'escodegen': 'There is not an escodegen.generate() method.  Make sure you have included escodegen (https://github.com/Constellation/escodegen).'
                },
                'storedModules': {},
                'callbackParameterMap': {},
                'dependencyBlacklist': {
                    'require': 'remove',
                    'exports': true,
                    'module': 'remove'
                },
                'defaultLOC': {
                    'start': {
                        'line': 0,
                        'column': 0
                    }
                },
                'defaultRange': [
                    0,
                    0
                ],
                'readFile': function (path) {
                    if (publicAPI.env !== 'node') {
                        return '';
                    }
                    return fs.readFileSync(path, 'utf8');
                },
                'isDefine': function (node) {
                    var expression = node.expression || {}, callee = expression.callee;
                    return _.isObject(node) && node.type === 'ExpressionStatement' && _.isObject(expression) && expression.type === 'CallExpression' && callee.type === 'Identifier' && callee.name === 'define';
                },
                'isRequire': function (node) {
                    var expression = node.expression || {}, callee = expression.callee;
                    return _.isObject(node) && node.type === 'ExpressionStatement' && _.isObject(expression) && expression.type === 'CallExpression' && callee.type === 'Identifier' && callee.name === 'require';
                },
                'isRequireExpression': function (node) {
                    return node.type === 'CallExpression' && node.callee && node.callee.name === 'require';
                },
                'isObjectExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'ObjectExpression';
                },
                'isFunctionExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'FunctionExpression';
                },
                'isFunctionCallExpression': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'CallExpression' && _.isPlainObject(expression.callee) && expression.callee.type === 'FunctionExpression';
                },
                'isUseStrict': function (expression) {
                    return expression && _.isPlainObject(expression) && expression.type === 'Literal' && expression.value === 'use strict';
                },
                'isAMDConditional': function (node) {
                    if (publicAPI.options.transformAMDChecks !== true || (node && node.type !== 'IfStatement' || !_.isObject(node.test) || !_.isObject(node.test.left) || _.isNull(node.test.left.value))) {
                        return false;
                    }
                    var matchObject = {
                            'left': {
                                'operator': 'typeof',
                                'argument': {
                                    'type': 'Identifier',
                                    'name': 'define'
                                }
                            },
                            'right': {
                                'type': 'Literal',
                                'value': 'function'
                            }
                        };
                    return _.where(node.test, matchObject).length || _.where([node.test], matchObject).length || _.where(node.test.left, matchObject).length || _.where([node.test.left], matchObject).length;
                },
                convertToCamelCase: function (input, delimiter) {
                    delimiter = delimiter || '_';
                    return input.replace(new RegExp(delimiter + '(.)', 'g'), function (match, group1) {
                        return group1.toUpperCase();
                    });
                },
                'prefixReservedWords': function (name) {
                    var reservedWord = false;
                    try {
                        if (name.length) {
                            eval('var ' + name + ' = 1;');
                        }
                    } catch (e) {
                        reservedWord = true;
                    }
                    if (reservedWord === true) {
                        return '_' + name;
                    } else {
                        return name;
                    }
                },
                'normalizeModuleName': function (name, moduleId) {
                    var pre_normalized, post_normalized, prefixMode = publicAPI.options.prefixMode, prefixTransform = publicAPI.options.prefixTransform, prefixTransformValue;
                    name = name || '';
                    if (name === '{}') {
                        if (publicAPI.dependencyBlacklist[name] === 'remove') {
                            return '';
                        } else {
                            return name;
                        }
                    }
                    pre_normalized = publicAPI.prefixReservedWords(name.replace(/\./g, '').replace(/[^A-Za-z0-9_$]/g, '_').replace(/^_+/, ''));
                    post_normalized = prefixMode === 'camelCase' ? publicAPI.convertToCamelCase(pre_normalized) : pre_normalized;
                    if (_.isFunction(prefixTransform)) {
                        prefixTransformValue = prefixTransform(post_normalized, moduleId);
                        if (_.isString(prefixTransformValue) && prefixTransformValue.length) {
                            return prefixTransformValue;
                        }
                    }
                    return post_normalized;
                },
                'returnExpressionIdentifier': function (name) {
                    return {
                        'type': 'ExpressionStatement',
                        'expression': {
                            'type': 'Identifier',
                            'name': name,
                            'range': publicAPI.defaultRange,
                            'loc': publicAPI.defaultLOC
                        },
                        'range': publicAPI.defaultRange,
                        'loc': publicAPI.defaultLOC
                    };
                },
                'convertToObjectDeclaration': function (obj, type) {
                    var node = obj.node, moduleName = obj.moduleName, moduleReturnValue = function () {
                            var modReturnValue, callee, params, returnStatement, nestedReturnStatement, internalFunctionExpression;
                            if (type === 'functionCallExpression') {
                                modReturnValue = obj.moduleReturnValue;
                                callee = modReturnValue.callee;
                                params = callee.params;
                                if (params && params.length && _.isArray(params) && _.where(params, { 'name': 'global' })) {
                                    if (_.isObject(callee.body)) {
                                        if (_.isArray(callee.body.body)) {
                                            returnStatement = _.where(callee.body.body, { 'type': 'ReturnStatement' })[0];
                                            if (_.isObject(returnStatement) && _.isObject(returnStatement.argument) && returnStatement.argument.type === 'FunctionExpression') {
                                                internalFunctionExpression = returnStatement.argument;
                                                if (_.isObject(internalFunctionExpression.body) && _.isArray(internalFunctionExpression.body.body)) {
                                                    nestedReturnStatement = _.where(internalFunctionExpression.body.body, { 'type': 'ReturnStatement' })[0];
                                                    if (_.isObject(nestedReturnStatement.argument) && _.isObject(nestedReturnStatement.argument.right) && _.isObject(nestedReturnStatement.argument.right.property)) {
                                                        if (nestedReturnStatement.argument.right.property.name) {
                                                            modReturnValue = {
                                                                'type': 'MemberExpression',
                                                                'computed': false,
                                                                'object': {
                                                                    'type': 'Identifier',
                                                                    'name': 'window',
                                                                    'range': publicAPI.defaultRange,
                                                                    'loc': publicAPI.defaultLOC
                                                                },
                                                                'property': {
                                                                    'type': 'Identifier',
                                                                    'name': nestedReturnStatement.argument.right.property.name,
                                                                    'range': publicAPI.defaultRange,
                                                                    'loc': publicAPI.defaultLOC
                                                                },
                                                                'range': publicAPI.defaultRange,
                                                                'loc': publicAPI.defaultLOC
                                                            };
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            modReturnValue = modReturnValue || obj.moduleReturnValue;
                            return modReturnValue;
                        }(), options = publicAPI.options, updatedNode = {
                            'type': 'ExpressionStatement',
                            'expression': {
                                'type': 'AssignmentExpression',
                                'operator': '=',
                                'left': {
                                    'type': 'Identifier',
                                    'name': moduleName,
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                },
                                'right': moduleReturnValue,
                                'range': publicAPI.defaultRange,
                                'loc': publicAPI.defaultLOC
                            },
                            'range': publicAPI.defaultRange,
                            'loc': publicAPI.defaultLOC
                        };
                    return updatedNode;
                },
                'convertToIIFE': function (obj) {
                    var callbackFuncParams = obj.callbackFuncParams, callbackFunc = obj.callbackFunc, dependencyNames = obj.dependencyNames;
                    return {
                        'type': 'ExpressionStatement',
                        'expression': {
                            'type': 'CallExpression',
                            'callee': {
                                'type': 'FunctionExpression',
                                'id': null,
                                'params': callbackFuncParams,
                                'defaults': [],
                                'body': callbackFunc.body,
                                'rest': callbackFunc.rest,
                                'generator': callbackFunc.generator,
                                'expression': callbackFunc.expression,
                                'range': callbackFunc.range || publicAPI.defaultRange,
                                'loc': callbackFunc.loc || publicAPI.defaultLOC
                            },
                            'arguments': dependencyNames,
                            'range': callbackFunc.range || publicAPI.defaultRange,
                            'loc': callbackFunc.loc || publicAPI.defaultLOC
                        },
                        'range': callbackFunc.range || publicAPI.defaultRange,
                        'loc': callbackFunc.loc || publicAPI.defaultLOC
                    };
                },
                'convertToIIFEDeclaration': function (obj) {
                    var moduleName = obj.moduleName, callbackFuncParams = obj.callbackFuncParams, isOptimized = obj.isOptimized, callbackFunc = function () {
                            var cbFunc = obj.callbackFunc;
                            if (cbFunc.type === 'Identifier' && cbFunc.name !== 'undefined') {
                                cbFunc = {
                                    'type': 'FunctionExpression',
                                    'id': null,
                                    'params': [],
                                    'defaults': [],
                                    'body': {
                                        'type': 'BlockStatement',
                                        'body': [{
                                                'type': 'ReturnStatement',
                                                'argument': {
                                                    'type': 'CallExpression',
                                                    'callee': {
                                                        'type': 'Identifier',
                                                        'name': cbFunc.name,
                                                        'range': cbFunc.range || publicAPI.defaultRange,
                                                        'loc': cbFunc.loc || publicAPI.defaultLOC
                                                    },
                                                    'arguments': callbackFuncParams,
                                                    'range': cbFunc.range || publicAPI.defaultRange,
                                                    'loc': cbFunc.loc || publicAPI.defaultLOC
                                                },
                                                'range': cbFunc.range || publicAPI.defaultRange,
                                                'loc': cbFunc.loc || publicAPI.defaultLOC
                                            }],
                                        'range': cbFunc.range || publicAPI.defaultRange,
                                        'loc': cbFunc.loc || publicAPI.defaultLOC
                                    },
                                    'rest': null,
                                    'generator': false,
                                    'expression': false,
                                    'range': cbFunc.range || publicAPI.defaultRange,
                                    'loc': cbFunc.loc || publicAPI.defaultLOC
                                };
                            }
                            return cbFunc;
                        }(), dependencyNames = obj.dependencyNames, options = publicAPI.options, cb = function () {
                            if (callbackFunc.type === 'Literal' || callbackFunc.type === 'Identifier' && callbackFunc.name === 'undefined' || isOptimized === true) {
                                return callbackFunc;
                            } else {
                                return {
                                    'type': 'CallExpression',
                                    'callee': {
                                        'type': 'FunctionExpression',
                                        'id': {
                                            'type': 'Identifier',
                                            'name': '',
                                            'range': callbackFunc.range || publicAPI.defaultRange,
                                            'loc': callbackFunc.loc || publicAPI.defaultLOC
                                        },
                                        'params': callbackFuncParams,
                                        'defaults': [],
                                        'body': callbackFunc.body,
                                        'rest': callbackFunc.rest,
                                        'generator': callbackFunc.generator,
                                        'expression': callbackFunc.expression,
                                        'range': callbackFunc.range || publicAPI.defaultRange,
                                        'loc': callbackFunc.loc || publicAPI.defaultLOC
                                    },
                                    'arguments': dependencyNames,
                                    'range': callbackFunc.range || publicAPI.defaultRange,
                                    'loc': callbackFunc.loc || publicAPI.defaultLOC
                                };
                            }
                        }(), updatedNode = {
                            'type': 'ExpressionStatement',
                            'expression': {
                                'type': 'AssignmentExpression',
                                'operator': '=',
                                'left': {
                                    'type': 'Identifier',
                                    'name': moduleName,
                                    'range': callbackFunc.range || publicAPI.defaultRange,
                                    'loc': callbackFunc.loc || publicAPI.defaultLOC
                                },
                                'right': cb,
                                'range': callbackFunc.range || publicAPI.defaultRange,
                                'loc': callbackFunc.loc || publicAPI.defaultLOC
                            },
                            'range': callbackFunc.range || publicAPI.defaultRange,
                            'loc': callbackFunc.loc || publicAPI.defaultLOC
                        };
                    return updatedNode;
                },
                isRelativeFilePath: function (path) {
                    var segments = path.split('/');
                    return segments.length !== -1 && (segments[0] === '.' || segments[0] === '..');
                },
                'normalizeDependencyName': function (moduleId, dep) {
                    if (!moduleId || !dep || !publicAPI.isRelativeFilePath(dep)) {
                        return dep;
                    }
                    var normalizePath = function (path) {
                            var segments = path.split('/'), normalizedSegments;
                            normalizedSegments = _.reduce(segments, function (memo, segment) {
                                switch (segment) {
                                case '.':
                                    break;
                                case '..':
                                    memo.pop();
                                    break;
                                default:
                                    memo.push(segment);
                                }
                                return memo;
                            }, []);
                            return normalizedSegments.join('/');
                        }, baseName = function (path) {
                            var segments = path.split('/');
                            segments.pop();
                            return segments.join('/');
                        };
                    return normalizePath([
                        baseName(moduleId),
                        dep
                    ].join('/'));
                },
                'convertToFunctionExpression': function (obj) {
                    var isDefine = obj.isDefine, isRequire = obj.isRequire, isOptimized = false, node = obj.node, moduleName = obj.moduleName, moduleId = obj.moduleId, dependencies = obj.dependencies, depLength = dependencies.length, options = publicAPI.options, aggressiveOptimizations = options.aggressiveOptimizations, dependencyNames = function () {
                            var deps = [], currentName;
                            _.each(dependencies, function (currentDependency, iterator) {
                                currentName = publicAPI.normalizeModuleName(publicAPI.normalizeDependencyName(moduleId, currentDependency), moduleId);
                                deps.push({
                                    'type': 'Identifier',
                                    'name': currentName,
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                });
                            });
                            return deps;
                        }(), callbackFunc = function () {
                            var callbackFunc = obj.moduleReturnValue, body, returnStatements, firstReturnStatement, returnStatementArg;
                            // If the module has NO dependencies and the callback function is not empty
                            if (!depLength && callbackFunc && callbackFunc.type === 'FunctionExpression' && callbackFunc.body && _.isArray(callbackFunc.body.body) && callbackFunc.body.body.length) {
                                // Filter 'use strict' statements
                                body = _.filter(callbackFunc.body.body, function (node) {
                                    if (publicAPI.options.removeUseStricts === true)
                                        return !publicAPI.isUseStrict(node.expression);
                                    else
                                        return node;
                                });
                                // Returns an array of all return statements
                                returnStatements = _.where(body, { 'type': 'ReturnStatement' });
                                // If there is a return statement
                                if (returnStatements.length) {
                                    firstReturnStatement = returnStatements[0];
                                    returnStatementArg = firstReturnStatement.argument;
                                    // If something other than a function expression is getting returned
                                    // and there is more than one AST child node in the factory function
                                    // return early
                                    if (!publicAPI.isFunctionExpression(firstReturnStatement) && body.length > 1 || returnStatementArg && returnStatementArg.type === 'Identifier') {
                                        return callbackFunc;
                                    } else {
                                        // Optimize the AMD module by setting the callback function to the return statement argument
                                        callbackFunc = returnStatementArg;
                                        isOptimized = true;
                                        if (callbackFunc.params) {
                                            depLength = callbackFunc.params.length;
                                        }
                                    }
                                }
                            } else if (callbackFunc && callbackFunc.type === 'FunctionExpression' && callbackFunc.body && _.isArray(callbackFunc.body.body) && callbackFunc.body.body.length === 0) {
                                callbackFunc = {
                                    'type': 'Identifier',
                                    'name': 'undefined',
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                };
                                depLength = 0;
                            }
                            return callbackFunc;
                        }(), hasReturnStatement = function () {
                            var returns = [];
                            if (callbackFunc && callbackFunc.body && _.isArray(callbackFunc.body.body)) {
                                returns = _.where(callbackFunc.body.body, { 'type': 'ReturnStatement' });
                                if (returns.length) {
                                    return true;
                                }
                            }
                            return false;
                        }(), hasExportsParam = false, originalCallbackFuncParams, callbackFuncParams = function () {
                            var deps = [], currentName, cbParams = callbackFunc.params || dependencyNames || [], mappedParameter = {};
                            _.each(cbParams, function (currentParam, iterator) {
                                if (currentParam) {
                                    currentName = currentParam.name;
                                } else {
                                    currentName = dependencyNames[iterator].name;
                                }
                                if (currentName === 'exports') {
                                    hasExportsParam = true;
                                }
                                if (currentName !== '{}' && publicAPI.dependencyBlacklist[currentName] !== 'remove') {
                                    deps.push({
                                        'type': 'Identifier',
                                        'name': currentName,
                                        'range': publicAPI.defaultRange,
                                        'loc': publicAPI.defaultLOC
                                    });
                                    // If a callback parameter is not the exact name of a stored module and there is a dependency that matches the current callback parameter
                                    if (options.aggressiveOptimizations === true && !publicAPI.storedModules[currentName] && dependencyNames[iterator]) {
                                        // If the current dependency has not been stored
                                        if (!publicAPI.callbackParameterMap[dependencyNames[iterator].name]) {
                                            publicAPI.callbackParameterMap[dependencyNames[iterator].name] = [{
                                                    'name': currentName,
                                                    'count': 1
                                                }];
                                        } else {
                                            mappedParameter = _.where(publicAPI.callbackParameterMap[dependencyNames[iterator].name], { 'name': currentName });
                                            if (mappedParameter.length) {
                                                mappedParameter = mappedParameter[0];
                                                mappedParameter.count += 1;
                                            } else {
                                                publicAPI.callbackParameterMap[dependencyNames[iterator].name].push({
                                                    'name': currentName,
                                                    'count': 1
                                                });
                                            }
                                        }
                                    }
                                }
                            });
                            originalCallbackFuncParams = deps;
                            // Only return callback function parameters that do not directly match the name of existing stored modules
                            return _.filter(deps || [], function (currentParam) {
                                return !publicAPI.storedModules[currentParam.name];
                            });
                        }(), dependencyNameLength, callbackFuncParamsLength;
                    // Only return dependency names that do not directly match the name of existing stored modules
                    dependencyNames = _.filter(dependencyNames || [], function (currentDep, iterator) {
                        var mappedCallbackParameter = originalCallbackFuncParams[iterator], currentDepName = currentDep.name;
                        // If the matching callback parameter matches the name of a stored module, then do not return it
                        // Else if the matching callback parameter does not match the name of a stored module, return the dependency
                        return !mappedCallbackParameter || publicAPI.storedModules[mappedCallbackParameter.name] && mappedCallbackParameter.name === currentDepName ? !publicAPI.storedModules[currentDepName] : !publicAPI.storedModules[mappedCallbackParameter.name];
                    });
                    dependencyNameLength = dependencyNames.length;
                    callbackFuncParamsLength = callbackFuncParams.length;
                    // If the module dependencies passed into the current module are greater than the used callback function parameters, do not pass the dependencies
                    if (dependencyNameLength && dependencyNameLength > callbackFuncParamsLength) {
                        dependencyNames.splice(dependencyNameLength - callbackFuncParamsLength, callbackFuncParamsLength);
                    }
                    if (!hasReturnStatement && hasExportsParam) {
                        callbackFunc.body.body.push({
                            'type': 'ReturnStatement',
                            'argument': {
                                'type': 'Identifier',
                                'name': 'exports',
                                'range': publicAPI.defaultRange,
                                'loc': publicAPI.defaultLOC
                            },
                            'range': publicAPI.defaultRange,
                            'loc': publicAPI.defaultLOC
                        });
                    }
                    if (isDefine) {
                        return publicAPI.convertToIIFEDeclaration({
                            moduleName: moduleName,
                            dependencyNames: dependencyNames,
                            callbackFuncParams: callbackFuncParams,
                            hasExportsParam: hasExportsParam,
                            callbackFunc: callbackFunc,
                            isOptimized: isOptimized
                        });
                    } else if (isRequire) {
                        return publicAPI.convertToIIFE({
                            dependencyNames: dependencyNames,
                            callbackFuncParams: callbackFuncParams,
                            callbackFunc: callbackFunc
                        });
                    }
                },
                'getNormalizedModuleName': function (node, parent) {
                    if (!publicAPI.isDefine(node)) {
                        return;
                    }
                    var moduleId = node.expression['arguments'][0].value, moduleName = publicAPI.normalizeModuleName(moduleId);
                    return moduleName;
                },
                'convertDefinesAndRequires': function (node, parent) {
                    var moduleName, args, dependencies, moduleReturnValue, moduleId, params, isDefine = publicAPI.isDefine(node), isRequire = publicAPI.isRequire(node), startLineNumber, comments, currentLineNumber, lineNumberObj = {}, callbackFuncArg = false, type = '', options = publicAPI.options, shouldBeIgnored;
                    if (node.type === 'Program') {
                        comments = function () {
                            var arr = [];
                            _.each(node.comments, function (currentComment, iterator) {
                                var currentCommentValue = currentComment.value.trim();
                                if (currentCommentValue === options.commentCleanName) {
                                    arr.push(currentComment);
                                }
                            });
                            return arr;
                        }();
                        _.each(comments, function (currentComment, iterator) {
                            currentLineNumber = currentComment.loc.start.line;
                            lineNumberObj[currentLineNumber] = true;
                        });
                        publicAPI.commentLineNumbers = lineNumberObj;
                    }
                    startLineNumber = isDefine || isRequire ? node.expression.loc.start.line : node && node.loc && node.loc.start ? node.loc.start.line : null;
                    shouldBeIgnored = publicAPI.commentLineNumbers[startLineNumber] || publicAPI.commentLineNumbers['' + (parseInt(startLineNumber, 10) - 1)];
                    if (!shouldBeIgnored && publicAPI.isAMDConditional(node)) {
                        node.test = {
                            'type': 'Literal',
                            'value': true,
                            'raw': 'true',
                            'range': publicAPI.defaultRange,
                            'loc': publicAPI.defaultLOC
                        };
                        return node;
                    }
                    if (isDefine || isRequire) {
                        args = Array.prototype.slice.call(node.expression['arguments'], 0);
                        dependencies = function () {
                            var deps = isRequire ? args[0] : args[args.length - 2], depNames = [];
                            if (_.isPlainObject(deps)) {
                                deps = deps.elements || [];
                            } else {
                                deps = [];
                            }
                            if (Array.isArray(deps) && deps.length) {
                                _.each(deps, function (currentDependency) {
                                    if (publicAPI.dependencyBlacklist[currentDependency.value] !== 'remove') {
                                        if (publicAPI.dependencyBlacklist[currentDependency.value]) {
                                            if (publicAPI.dependencyBlacklist[currentDependency.value] !== 'remove') {
                                                depNames.push('{}');
                                            }
                                        } else {
                                            depNames.push(currentDependency.value);
                                        }
                                    }
                                });
                            }
                            return depNames;
                        }();
                        moduleReturnValue = isRequire ? args[1] : args[args.length - 1];
                        moduleId = node.expression['arguments'][0].value;
                        moduleName = publicAPI.normalizeModuleName(moduleId);
                        params = {
                            node: node,
                            moduleName: moduleName,
                            moduleId: moduleId,
                            dependencies: dependencies,
                            moduleReturnValue: moduleReturnValue,
                            isDefine: isDefine,
                            isRequire: isRequire
                        };
                        if (isDefine) {
                            if (shouldBeIgnored) {
                                publicAPI.options.ignoreModules.push(moduleName);
                                return node;
                            }
                            if (_.contains(options.removeModules, moduleName)) {
                                // Remove the current module from the source
                                return { type: 'EmptyStatement' };
                            }
                            if (_.isObject(options.shimOverrides) && options.shimOverrides[moduleName]) {
                                params.moduleReturnValue = publicAPI.createAst({ 'code': options.shimOverrides[moduleName] });
                                if (_.isArray(params.moduleReturnValue.body) && _.isObject(params.moduleReturnValue.body[0])) {
                                    if (_.isObject(params.moduleReturnValue.body[0].expression)) {
                                        params.moduleReturnValue = params.moduleReturnValue.body[0].expression;
                                        type = 'objectExpression';
                                    }
                                } else {
                                    params.moduleReturnValue = moduleReturnValue;
                                }
                            }
                            if (params.moduleReturnValue && params.moduleReturnValue.type === 'Identifier') {
                                type = 'functionExpression';
                            }
                            if (_.contains(options.ignoreModules, moduleName)) {
                                return node;
                            } else if (publicAPI.isFunctionExpression(moduleReturnValue) || type === 'functionExpression') {
                                return publicAPI.convertToFunctionExpression(params);
                            } else if (publicAPI.isObjectExpression(moduleReturnValue) || type === 'objectExpression') {
                                return publicAPI.convertToObjectDeclaration(params);
                            } else if (publicAPI.isFunctionCallExpression(moduleReturnValue)) {
                                return publicAPI.convertToObjectDeclaration(params, 'functionCallExpression');
                            }
                        } else if (isRequire) {
                            if (shouldBeIgnored) {
                                return node;
                            }
                            callbackFuncArg = _.isArray(node.expression['arguments']) && node.expression['arguments'].length ? node.expression['arguments'][1] && node.expression['arguments'][1].body && node.expression['arguments'][1].body.body && node.expression['arguments'][1].body.body.length : false;
                            if (options.removeAllRequires !== true && callbackFuncArg) {
                                return publicAPI.convertToFunctionExpression(params);
                            } else {
                                // Remove the require include statement from the source
                                return { type: 'EmptyStatement' };
                            }
                        }
                    } else {
                        // If the node is a function expression that has an exports parameter and does not return anything, return exports
                        if (node.type === 'FunctionExpression' && _.isArray(node.params) && _.where(node.params, {
                                'type': 'Identifier',
                                'name': 'exports'
                            }).length && _.isObject(node.body) && _.isArray(node.body.body) && !_.where(node.body.body, {
                                'type': 'ReturnStatement',
                                'argument': { 'type': 'Identifier' }
                            }).length) {
                            // Adds the logical expression, 'exports = exports || {}', to the beginning of the function expression
                            node.body.body.unshift({
                                'type': 'ExpressionStatement',
                                'expression': {
                                    'type': 'AssignmentExpression',
                                    'operator': '=',
                                    'left': {
                                        'type': 'Identifier',
                                        'name': 'exports',
                                        'range': publicAPI.defaultRange,
                                        'loc': publicAPI.defaultLOC
                                    },
                                    'right': {
                                        'type': 'LogicalExpression',
                                        'operator': '||',
                                        'left': {
                                            'type': 'Identifier',
                                            'name': 'exports',
                                            'range': publicAPI.defaultRange,
                                            'loc': publicAPI.defaultLOC
                                        },
                                        'right': {
                                            'type': 'ObjectExpression',
                                            'properties': [],
                                            'range': publicAPI.defaultRange,
                                            'loc': publicAPI.defaultLOC
                                        },
                                        'range': publicAPI.defaultRange,
                                        'loc': publicAPI.defaultLOC
                                    },
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                },
                                'range': publicAPI.defaultRange,
                                'loc': publicAPI.defaultLOC
                            });
                            // Adds the return statement, 'return exports', to the end of the function expression 
                            node.body.body.push({
                                'type': 'ReturnStatement',
                                'argument': {
                                    'type': 'Identifier',
                                    'name': 'exports',
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                },
                                'range': publicAPI.defaultRange,
                                'loc': publicAPI.defaultLOC
                            });
                        }
                        return node;
                    }
                },
                'createAst': function (obj) {
                    var filePath = obj.filePath, code = obj.code || (filePath && publicAPI.env === 'node' ? publicAPI.readFile(filePath) : ''), esprimaOptions = publicAPI.options.esprima;
                    if (!code) {
                        throw new Error(publicAPI.errorMsgs.emptyCode);
                    } else {
                        if (!_.isPlainObject(esprima) || !_.isFunction(esprima.parse)) {
                            throw new Error(publicAPI.errorMsgs.esprima);
                        }
                        return esprima.parse(code, esprimaOptions);
                    }
                },
                'findAndStoreAllModuleIds': function (ast) {
                    if (!ast) {
                        throw new Error(publicAPI.errorMsgs.emptyAst('findAndStoreAllModuleIds'));
                    }
                    if (!_.isPlainObject(estraverse) || !_.isFunction(estraverse.traverse)) {
                        throw new Error(publicAPI.errorMsgs.estraverse);
                    }
                    estraverse.traverse(ast, {
                        'enter': function (node, parent) {
                            var moduleName = publicAPI.getNormalizedModuleName(node, parent);
                            // If the current module has not been stored, store it
                            if (moduleName && !publicAPI.storedModules[moduleName]) {
                                publicAPI.storedModules[moduleName] = true;
                            }
                        }
                    });
                },
                'traverseAndUpdateAst': function (obj) {
                    if (!_.isPlainObject(obj)) {
                        throw new Error(publicAPI.errorMsgs.invalidObject('traverseAndUpdateAst'));
                    }
                    var ast = obj.ast;
                    if (!ast) {
                        throw new Error(publicAPI.errorMsgs.emptyAst('traverseAndUpdateAst'));
                    }
                    if (!_.isPlainObject(estraverse) || !_.isFunction(estraverse.replace)) {
                        throw new Error(publicAPI.errorMsgs.estraverse);
                    }
                    estraverse.replace(ast, {
                        'enter': function (node, parent) {
                            return publicAPI.convertDefinesAndRequires(node, parent);
                        },
                        'leave': function (node, parent) {
                            return node;
                        }
                    });
                    return ast;
                },
                'generateCode': function (ast, options) {
                    var esprimaOptions = options.esprima || {}, escodegenOptions = options.escodegen || {};
                    if (!_.isPlainObject(escodegen) || !_.isFunction(escodegen.generate)) {
                        throw new Error(publicAPI.errorMsgs.escodegen);
                    }
                    // Check if both the esprima and escodegen comment options are set to true
                    if (esprimaOptions.comment === true && escodegenOptions.comment === true) {
                        try {
                            // Needed to keep source code comments when generating the code with escodegen
                            ast = escodegen.attachComments(ast, ast.comments, ast.tokens);
                        } catch (e) {
                            if (console && console.log) {
                                // There was an error when attaching comments
                                console.log('There was an error attaching comments: ', e);
                            }
                        }
                    }
                    return escodegen.generate(ast, escodegenOptions);
                },
                'clean': function (obj) {
                    var code = {}, ast = {}, options = {}, defaultOptions = _.cloneDeep(publicAPI.defaultOptions || {}), userOptions = obj || {}, mergedOptions = _.merge(defaultOptions, userOptions), generatedCode, originalAst, declarations = [], hoistedVariables = {}, hoistedCallbackParameters = {};
                    publicAPI.options = options = mergedOptions;
                    if (!_ || !_.isPlainObject) {
                        throw new Error(publicAPI.errorMsgs.lodash);
                    }
                    if (!_.isPlainObject(obj) && _.isString(obj)) {
                        code.code = obj;
                    } else if (_.isPlainObject(obj)) {
                        code = obj;
                    } else {
                        throw new Error(publicAPI.errorMsgs.invalidObject('clean'));
                    }
                    // Creates and stores an AST representation of the code
                    originalAst = publicAPI.createAst(code);
                    // Loops through the AST, finds all module ids, and stores them inside of publicAPI.storedModules
                    publicAPI.findAndStoreAllModuleIds(originalAst);
                    // Traverse the AST and removes any AMD trace
                    ast = publicAPI.traverseAndUpdateAst({ ast: originalAst });
                    // Post Clean Up
                    // Removes all empty statements from the source so that there are no single semicolons and
                    // Makes sure that all require() CommonJS calls are converted
                    // And all aggressive optimizations (if the option is turned on) are handled
                    if (ast && _.isArray(ast.body)) {
                        estraverse.replace(ast, {
                            enter: function (node, parent) {
                                var normalizedModuleName, assignmentName = node && node.left && node.left.name ? node.left.name : '', cb = node.right, assignmentNodes = [], assignments = {}, mappedParameters = _.filter(publicAPI.callbackParameterMap[assignmentName], function (currentParameter) {
                                        return currentParameter && currentParameter.count > 1;
                                    }), mappedCbDependencyNames, mappedCbParameterNames, paramsToRemove = [];
                                if (node === undefined || node.type === 'EmptyStatement') {
                                    _.each(parent.body, function (currentNode, iterator) {
                                        if (currentNode === undefined || currentNode.type === 'EmptyStatement') {
                                            parent.body.splice(iterator, 1);
                                        }
                                    });
                                } else if (publicAPI.isRequireExpression(node)) {
                                    if (node['arguments'] && node['arguments'][0] && node['arguments'][0].value) {
                                        normalizedModuleName = publicAPI.normalizeModuleName(node['arguments'][0].value);
                                        return {
                                            'type': 'Identifier',
                                            'name': normalizedModuleName,
                                            'range': publicAPI.defaultRange,
                                            'loc': publicAPI.defaultLOC
                                        };
                                    } else {
                                        return node;
                                    }
                                } else if (options.aggressiveOptimizations === true && node.type === 'AssignmentExpression' && assignmentName) {
                                    // The names of all of the current callback function parameters
                                    mappedCbParameterNames = _.map(cb && cb.callee && cb.callee.params ? cb.callee.params : [], function (currentParam) {
                                        return currentParam.name;
                                    });
                                    // The names of all of the current callback function dependencies
                                    mappedCbDependencyNames = _.map(cb.arguments, function (currentArg) {
                                        return currentArg.name;
                                    });
                                    // Loop through the dependency names
                                    _.each(mappedCbDependencyNames, function (currentDependencyName) {
                                        // Nested loop to see if any of the dependency names map to a callback parameter
                                        _.each(publicAPI.callbackParameterMap[currentDependencyName], function (currentMapping) {
                                            var mappedName = currentMapping.name, mappedCount = currentMapping.count;
                                            // Loops through all of the callback function parameter names to see if any of the parameters should be removed
                                            _.each(mappedCbParameterNames, function (currentParameterName, iterator) {
                                                if (mappedCount > 1 && mappedName === currentParameterName) {
                                                    paramsToRemove.push(iterator);
                                                }
                                            });
                                        });
                                    });
                                    _.each(paramsToRemove, function (currentParam) {
                                        cb.arguments.splice(currentParam, currentParam + 1);
                                        cb.callee.params.splice(currentParam, currentParam + 1);
                                    });
                                    // If the current Assignment Expression is a mapped callback parameter
                                    if (publicAPI.callbackParameterMap[assignmentName]) {
                                        node.right = function () {
                                            // If aggressive optimizations are turned on, the mapped parameter is used more than once, and there are mapped dependencies to be removed
                                            if (options.aggressiveOptimizations === true && mappedParameters.length) {
                                                // All of the necessary assignment nodes
                                                assignmentNodes = _.map(mappedParameters, function (currentDependency, iterator) {
                                                    return {
                                                        'type': 'AssignmentExpression',
                                                        'operator': '=',
                                                        'left': {
                                                            'type': 'Identifier',
                                                            'name': currentDependency.name,
                                                            'range': publicAPI.defaultRange,
                                                            'loc': publicAPI.defaultLOC
                                                        },
                                                        'right': iterator < mappedParameters.length - 1 ? {
                                                            'range': publicAPI.defaultRange,
                                                            'loc': publicAPI.defaultLOC
                                                        } : cb,
                                                        'range': publicAPI.defaultRange,
                                                        'loc': publicAPI.defaultLOC
                                                    };
                                                });
                                                // Creates an object containing all of the assignment expressions
                                                assignments = _.reduce(assignmentNodes, function (result, assignment, key) {
                                                    result.right = assignment;
                                                    return result;
                                                });
                                                // The constructed assignment object node
                                                return assignmentNodes.length ? assignments : cb;
                                            } else {
                                                return cb;
                                            }
                                        }();
                                        return node;
                                    }
                                }
                            }
                        });
                    }
                    // Makes any necessary modules global by appending a global instantiation to the code
                    // eg: window.exampleModule = exampleModule;
                    if (_.isArray(options.globalModules)) {
                        _.each(options.globalModules, function (currentModule) {
                            if (_.isString(currentModule) && currentModule.length) {
                                ast.body.push({
                                    'type': 'ExpressionStatement',
                                    'expression': {
                                        'type': 'AssignmentExpression',
                                        'operator': '=',
                                        'left': {
                                            'type': 'MemberExpression',
                                            'computed': false,
                                            'object': {
                                                'type': 'Identifier',
                                                'name': 'window',
                                                'range': publicAPI.defaultRange,
                                                'loc': publicAPI.defaultLOC
                                            },
                                            'property': {
                                                'type': 'Identifier',
                                                'name': currentModule,
                                                'range': publicAPI.defaultRange,
                                                'loc': publicAPI.defaultLOC
                                            },
                                            'range': publicAPI.defaultRange,
                                            'loc': publicAPI.defaultLOC
                                        },
                                        'right': {
                                            'type': 'Identifier',
                                            'name': currentModule,
                                            'range': publicAPI.defaultRange,
                                            'loc': publicAPI.defaultLOC
                                        },
                                        'range': publicAPI.defaultRange,
                                        'loc': publicAPI.defaultLOC
                                    },
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                });
                            }
                        });
                    }
                    hoistedCallbackParameters = function () {
                        var obj = {}, callbackParameterMap = publicAPI.callbackParameterMap, count, currentParameterName;
                        _.each(callbackParameterMap, function (mappedParameters) {
                            _.each(mappedParameters, function (currentParameter) {
                                if (currentParameter.count > 1) {
                                    currentParameterName = currentParameter.name;
                                    obj[currentParameterName] = true;
                                }
                            });
                        });
                        return obj;
                    }();
                    // Hoists all modules and necessary callback parameters
                    hoistedVariables = _.merge(_.cloneDeep(publicAPI.storedModules), hoistedCallbackParameters);
                    // Creates variable declarations for each AMD module/callback parameter that needs to be hoisted
                    _.each(hoistedVariables, function (moduleValue, moduleName) {
                        if (!_.contains(publicAPI.options.ignoreModules, moduleName)) {
                            declarations.push({
                                'type': 'VariableDeclarator',
                                'id': {
                                    'type': 'Identifier',
                                    'name': moduleName,
                                    'range': publicAPI.defaultRange,
                                    'loc': publicAPI.defaultLOC
                                },
                                'init': null,
                                'range': publicAPI.defaultRange,
                                'loc': publicAPI.defaultLOC
                            });
                        }
                    });
                    // If there are declarations, the declarations are preprended to the beginning of the code block
                    if (declarations.length) {
                        ast.body.unshift({
                            'type': 'VariableDeclaration',
                            'declarations': declarations,
                            'kind': 'var',
                            'range': publicAPI.defaultRange,
                            'loc': publicAPI.defaultLOC
                        });
                    }
                    // Resets all of the stored modules
                    publicAPI.storedModules = {};
                    // Resets all of the stored callback parameter/dependency mappings
                    publicAPI.callbackParameterMap = {};
                    // Converts the updated AST to a string of code
                    generatedCode = publicAPI.generateCode(ast, options);
                    // If there is a wrap option specified
                    if (_.isObject(publicAPI.options.wrap)) {
                        if (_.isString(publicAPI.options.wrap.start) && publicAPI.options.wrap.start.length) {
                            generatedCode = publicAPI.options.wrap.start + generatedCode;
                        }
                        if (_.isString(publicAPI.options.wrap.end) && publicAPI.options.wrap.end.length) {
                            generatedCode = generatedCode + publicAPI.options.wrap.end;
                        }
                    }
                    return generatedCode;
                }
            };
        return publicAPI;
    }));
    // End of amdclean module;
    // CodeMirror is the only global var we claim
    window.CodeMirror = function () {
        'use strict';
        // BROWSER SNIFFING
        // Crude, but necessary to handle a number of hard-to-feature-detect
        // bugs and behavior differences.
        var gecko = /gecko\/\d/i.test(navigator.userAgent);
        var ie = /MSIE \d/.test(navigator.userAgent);
        var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
        var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
        var webkit = /WebKit\//.test(navigator.userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
        var chrome = /Chrome\//.test(navigator.userAgent);
        var opera = /Opera\//.test(navigator.userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var khtml = /KHTML\//.test(navigator.userAgent);
        var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
        var phantom = /PhantomJS/.test(navigator.userAgent);
        var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
        // This is woefully incomplete. Suggestions for alternative methods welcome.
        var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
        var mac = ios || /Mac/.test(navigator.platform);
        var windows = /win/i.test(navigator.platform);
        var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
        if (opera_version)
            opera_version = Number(opera_version[1]);
        if (opera_version && opera_version >= 15) {
            opera = false;
            webkit = true;
        }
        // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
        var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
        var captureMiddleClick = gecko || ie && !ie_lt9;
        // Optimize some code when these features are not used
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        // CONSTRUCTOR
        function CodeMirror(place, options) {
            if (!(this instanceof CodeMirror))
                return new CodeMirror(place, options);
            this.options = options = options || {};
            // Determine effective options based on given values and defaults.
            for (var opt in defaults)
                if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
                    options[opt] = defaults[opt];
            setGuttersForLineNumbers(options);
            var docStart = typeof options.value == 'string' ? 0 : options.value.first;
            var display = this.display = makeDisplay(place, docStart);
            display.wrapper.CodeMirror = this;
            updateGutters(this);
            if (options.autofocus && !mobile)
                focusInput(this);
            this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: false,
                focused: false,
                suppressEdits: false,
                pasteIncoming: false,
                draggingText: false,
                highlight: new Delayed()
            };
            themeChanged(this);
            if (options.lineWrapping)
                this.display.wrapper.className += ' CodeMirror-wrap';
            var doc = options.value;
            if (typeof doc == 'string')
                doc = new Doc(options.value, options.mode);
            operation(this, attachDoc)(this, doc);
            // Override magic textarea content restore that IE sometimes does
            // on our hidden textarea on reload
            if (ie)
                setTimeout(bind(resetInput, this, true), 20);
            registerEventHandlers(this);
            // IE throws unspecified error in certain cases, when
            // trying to access activeElement before onload
            var hasFocus;
            try {
                hasFocus = document.activeElement == display.input;
            } catch (e) {
            }
            if (hasFocus || options.autofocus && !mobile)
                setTimeout(bind(onFocus, this), 20);
            else
                onBlur(this);
            operation(this, function () {
                for (var opt in optionHandlers)
                    if (optionHandlers.propertyIsEnumerable(opt))
                        optionHandlers[opt](this, options[opt], Init);
                for (var i = 0; i < initHooks.length; ++i)
                    initHooks[i](this);
            })();
        }
        // DISPLAY CONSTRUCTOR
        function makeDisplay(place, docStart) {
            var d = {};
            var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
            if (webkit)
                input.style.width = '1000px';
            else
                input.setAttribute('wrap', 'off');
            // if border: 0; -- iOS fails to open keyboard (issue #1287)
            if (ios)
                input.style.border = '1px solid black';
            input.setAttribute('autocorrect', 'off');
            input.setAttribute('autocapitalize', 'off');
            input.setAttribute('spellcheck', 'false');
            // Wraps and hides input textarea
            d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
            // The actual fake scrollbars.
            d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
            d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
            d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
            d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
            // DIVs containing the selection and the actual code
            d.lineDiv = elt('div', null, 'CodeMirror-code');
            d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
            // Blinky cursor, and element used to ensure cursor fits at the end of a line
            d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
            // Secondary cursor, shown when on a 'jump' in bi-directional text
            d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
            // Used to measure text size
            d.measure = elt('div', null, 'CodeMirror-measure');
            // Wraps everything that needs to exist inside the vertically-padded coordinate system
            d.lineSpace = elt('div', [
                d.measure,
                d.selectionDiv,
                d.lineDiv,
                d.cursor,
                d.otherCursor
            ], null, 'position: relative; outline: none');
            // Moved around its parent to cover visible view
            d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
            // Set to the height of the text, causes scrolling
            d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
            // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
            d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
            // Will contain the gutters, if any
            d.gutters = elt('div', null, 'CodeMirror-gutters');
            d.lineGutter = null;
            // Provides scrolling
            d.scroller = elt('div', [
                d.sizer,
                d.heightForcer,
                d.gutters
            ], 'CodeMirror-scroll');
            d.scroller.setAttribute('tabIndex', '-1');
            // The element in which the editor lives.
            d.wrapper = elt('div', [
                d.inputDiv,
                d.scrollbarH,
                d.scrollbarV,
                d.scrollbarFiller,
                d.gutterFiller,
                d.scroller
            ], 'CodeMirror');
            // Work around IE7 z-index bug
            if (ie_lt8) {
                d.gutters.style.zIndex = -1;
                d.scroller.style.paddingRight = 0;
            }
            if (place.appendChild)
                place.appendChild(d.wrapper);
            else
                place(d.wrapper);
            // Needed to hide big blue blinking cursor on Mobile Safari
            if (ios)
                input.style.width = '0px';
            if (!webkit)
                d.scroller.draggable = true;
            // Needed to handle Tab key in KHTML
            if (khtml) {
                d.inputDiv.style.height = '1px';
                d.inputDiv.style.position = 'absolute';
            }    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
            else if (ie_lt8)
                d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
            // Current visible range (may be bigger than the view window).
            d.viewOffset = d.lastSizeC = 0;
            d.showingFrom = d.showingTo = docStart;
            // Used to only resize the line number gutter when necessary (when
            // the amount of lines crosses a boundary that makes its width change)
            d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
            // See readInput and resetInput
            d.prevInput = '';
            // Set to true when a non-horizontal-scrolling widget is added. As
            // an optimization, widget aligning is skipped when d is false.
            d.alignWidgets = false;
            // Flag that indicates whether we currently expect input to appear
            // (after some event like 'keypress' or 'input') and are polling
            // intensively.
            d.pollingFast = false;
            // Self-resetting timeout for the poller
            d.poll = new Delayed();
            d.cachedCharWidth = d.cachedTextHeight = null;
            d.measureLineCache = [];
            d.measureLineCachePos = 0;
            // Tracks when resetInput has punted to just putting a short
            // string instead of the (large) selection.
            d.inaccurateSelection = false;
            // Tracks the maximum line length so that the horizontal scrollbar
            // can be kept static when scrolling.
            d.maxLine = null;
            d.maxLineLength = 0;
            d.maxLineChanged = false;
            // Used for measuring wheel scrolling granularity
            d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
            return d;
        }
        // STATE UPDATES
        // Used to get the editor into a consistent state again when options change.
        function loadMode(cm) {
            cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
            cm.doc.iter(function (line) {
                if (line.stateAfter)
                    line.stateAfter = null;
                if (line.styles)
                    line.styles = null;
            });
            cm.doc.frontier = cm.doc.first;
            startWorker(cm, 100);
            cm.state.modeGen++;
            if (cm.curOp)
                regChange(cm);
        }
        function wrappingChanged(cm) {
            if (cm.options.lineWrapping) {
                cm.display.wrapper.className += ' CodeMirror-wrap';
                cm.display.sizer.style.minWidth = '';
            } else {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
                computeMaxLength(cm);
            }
            estimateLineHeights(cm);
            regChange(cm);
            clearCaches(cm);
            setTimeout(function () {
                updateScrollbars(cm);
            }, 100);
        }
        function estimateHeight(cm) {
            var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
            var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
            return function (line) {
                if (lineIsHidden(cm.doc, line))
                    return 0;
                else if (wrapping)
                    return (Math.ceil(line.text.length / perLine) || 1) * th;
                else
                    return th;
            };
        }
        function estimateLineHeights(cm) {
            var doc = cm.doc, est = estimateHeight(cm);
            doc.iter(function (line) {
                var estHeight = est(line);
                if (estHeight != line.height)
                    updateLineHeight(line, estHeight);
            });
        }
        function keyMapChanged(cm) {
            var map = keyMap[cm.options.keyMap], style = map.style;
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
            cm.state.disableInput = map.disableInput;
        }
        function themeChanged(cm) {
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
            clearCaches(cm);
        }
        function guttersChanged(cm) {
            updateGutters(cm);
            regChange(cm);
            setTimeout(function () {
                alignHorizontally(cm);
            }, 20);
        }
        function updateGutters(cm) {
            var gutters = cm.display.gutters, specs = cm.options.gutters;
            removeChildren(gutters);
            for (var i = 0; i < specs.length; ++i) {
                var gutterClass = specs[i];
                var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
                if (gutterClass == 'CodeMirror-linenumbers') {
                    cm.display.lineGutter = gElt;
                    gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
                }
            }
            gutters.style.display = i ? '' : 'none';
        }
        function lineLength(doc, line) {
            if (line.height == 0)
                return 0;
            var len = line.text.length, merged, cur = line;
            while (merged = collapsedSpanAtStart(cur)) {
                var found = merged.find();
                cur = getLine(doc, found.from.line);
                len += found.from.ch - found.to.ch;
            }
            cur = line;
            while (merged = collapsedSpanAtEnd(cur)) {
                var found = merged.find();
                len -= cur.text.length - found.from.ch;
                cur = getLine(doc, found.to.line);
                len += cur.text.length - found.to.ch;
            }
            return len;
        }
        function computeMaxLength(cm) {
            var d = cm.display, doc = cm.doc;
            d.maxLine = getLine(doc, doc.first);
            d.maxLineLength = lineLength(doc, d.maxLine);
            d.maxLineChanged = true;
            doc.iter(function (line) {
                var len = lineLength(doc, line);
                if (len > d.maxLineLength) {
                    d.maxLineLength = len;
                    d.maxLine = line;
                }
            });
        }
        // Make sure the gutters options contains the element
        // "CodeMirror-linenumbers" when the lineNumbers option is true.
        function setGuttersForLineNumbers(options) {
            var found = indexOf(options.gutters, 'CodeMirror-linenumbers');
            if (found == -1 && options.lineNumbers) {
                options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
            } else if (found > -1 && !options.lineNumbers) {
                options.gutters = options.gutters.slice(0);
                options.gutters.splice(found, 1);
            }
        }
        // SCROLLBARS
        // Re-synchronize the fake scrollbars with the actual size of the
        // content. Optionally force a scrollTop.
        function updateScrollbars(cm) {
            var d = cm.display, docHeight = cm.doc.height;
            var totalHeight = docHeight + paddingVert(d);
            d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
            d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + 'px';
            var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
            var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;
            var needsV = scrollHeight > d.scroller.clientHeight + 1;
            if (needsV) {
                d.scrollbarV.style.display = 'block';
                d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
                d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
            } else {
                d.scrollbarV.style.display = '';
                d.scrollbarV.firstChild.style.height = '0';
            }
            if (needsH) {
                d.scrollbarH.style.display = 'block';
                d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
                d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
            } else {
                d.scrollbarH.style.display = '';
                d.scrollbarH.firstChild.style.width = '0';
            }
            if (needsH && needsV) {
                d.scrollbarFiller.style.display = 'block';
                d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
            } else
                d.scrollbarFiller.style.display = '';
            if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
                d.gutterFiller.style.display = 'block';
                d.gutterFiller.style.height = scrollbarWidth(d.measure) + 'px';
                d.gutterFiller.style.width = d.gutters.offsetWidth + 'px';
            } else
                d.gutterFiller.style.display = '';
            if (mac_geLion && scrollbarWidth(d.measure) === 0) {
                d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
                d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = 'none';
            }
        }
        function visibleLines(display, doc, viewPort) {
            var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
            if (typeof viewPort == 'number')
                top = viewPort;
            else if (viewPort) {
                top = viewPort.top;
                height = viewPort.bottom - viewPort.top;
            }
            top = Math.floor(top - paddingTop(display));
            var bottom = Math.ceil(top + height);
            return {
                from: lineAtHeight(doc, top),
                to: lineAtHeight(doc, bottom)
            };
        }
        // LINE NUMBERS
        function alignHorizontally(cm) {
            var display = cm.display;
            if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
                return;
            var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
            var gutterW = display.gutters.offsetWidth, l = comp + 'px';
            for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
                if (n.alignable) {
                    for (var i = 0, a = n.alignable; i < a.length; ++i)
                        a[i].style.left = l;
                }
            if (cm.options.fixedGutter)
                display.gutters.style.left = comp + gutterW + 'px';
        }
        function maybeUpdateLineNumberWidth(cm) {
            if (!cm.options.lineNumbers)
                return false;
            var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
            if (last.length != display.lineNumChars) {
                var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
                var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                display.lineGutter.style.width = '';
                display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
                display.lineNumWidth = display.lineNumInnerWidth + padding;
                display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
                display.lineGutter.style.width = display.lineNumWidth + 'px';
                return true;
            }
            return false;
        }
        function lineNumberFor(options, i) {
            return String(options.lineNumberFormatter(i + options.firstLineNumber));
        }
        function compensateForHScroll(display) {
            return getRect(display.scroller).left - getRect(display.sizer).left;
        }
        // DISPLAY DRAWING
        function updateDisplay(cm, changes, viewPort, forced) {
            var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
            var visible = visibleLines(cm.display, cm.doc, viewPort);
            for (var first = true;; first = false) {
                var oldWidth = cm.display.scroller.clientWidth;
                if (!updateDisplayInner(cm, changes, visible, forced))
                    break;
                updated = true;
                changes = [];
                updateSelection(cm);
                updateScrollbars(cm);
                if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
                    forced = true;
                    continue;
                }
                forced = false;
                // Clip forced viewport to actual scrollable area
                if (viewPort)
                    viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
                visible = visibleLines(cm.display, cm.doc, viewPort);
                if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
                    break;
            }
            if (updated) {
                signalLater(cm, 'update', cm);
                if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
                    signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
            }
            return updated;
        }
        // Uses a set of changes plus the current scroll position to
        // determine which DOM updates have to be made, and makes the
        // updates.
        function updateDisplayInner(cm, changes, visible, forced) {
            var display = cm.display, doc = cm.doc;
            if (!display.wrapper.clientWidth) {
                display.showingFrom = display.showingTo = doc.first;
                display.viewOffset = 0;
                return;
            }
            // Bail out if the visible area is already rendered and nothing changed.
            if (!forced && changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
                return;
            if (maybeUpdateLineNumberWidth(cm))
                changes = [{
                        from: doc.first,
                        to: doc.first + doc.size
                    }];
            var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
            display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
            // Used to determine which lines need their line numbers updated
            var positionsChangedFrom = Infinity;
            if (cm.options.lineNumbers)
                for (var i = 0; i < changes.length; ++i)
                    if (changes[i].diff && changes[i].from < positionsChangedFrom) {
                        positionsChangedFrom = changes[i].from;
                    }
            var end = doc.first + doc.size;
            var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
            var to = Math.min(end, visible.to + cm.options.viewportMargin);
            if (display.showingFrom < from && from - display.showingFrom < 20)
                from = Math.max(doc.first, display.showingFrom);
            if (display.showingTo > to && display.showingTo - to < 20)
                to = Math.min(end, display.showingTo);
            if (sawCollapsedSpans) {
                from = lineNo(visualLine(doc, getLine(doc, from)));
                while (to < end && lineIsHidden(doc, getLine(doc, to)))
                    ++to;
            }
            // Create a range of theoretically intact lines, and punch holes
            // in that using the change info.
            var intact = [{
                        from: Math.max(display.showingFrom, doc.first),
                        to: Math.min(display.showingTo, end)
                    }];
            if (intact[0].from >= intact[0].to)
                intact = [];
            else
                intact = computeIntact(intact, changes);
            // When merged lines are present, we might have to reduce the
            // intact ranges because changes in continued fragments of the
            // intact lines do require the lines to be redrawn.
            if (sawCollapsedSpans)
                for (var i = 0; i < intact.length; ++i) {
                    var range = intact[i], merged;
                    while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
                        var newTo = merged.find().from.line;
                        if (newTo > range.from)
                            range.to = newTo;
                        else {
                            intact.splice(i--, 1);
                            break;
                        }
                    }
                }
            // Clip off the parts that won't be visible
            var intactLines = 0;
            for (var i = 0; i < intact.length; ++i) {
                var range = intact[i];
                if (range.from < from)
                    range.from = from;
                if (range.to > to)
                    range.to = to;
                if (range.from >= range.to)
                    intact.splice(i--, 1);
                else
                    intactLines += range.to - range.from;
            }
            if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
                updateViewOffset(cm);
                return;
            }
            intact.sort(function (a, b) {
                return a.from - b.from;
            });
            // Avoid crashing on IE's "unspecified error" when in iframes
            try {
                var focused = document.activeElement;
            } catch (e) {
            }
            if (intactLines < (to - from) * 0.7)
                display.lineDiv.style.display = 'none';
            patchDisplay(cm, from, to, intact, positionsChangedFrom);
            display.lineDiv.style.display = '';
            if (focused && document.activeElement != focused && focused.offsetHeight)
                focused.focus();
            var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
            // This is just a bogus formula that detects when the editor is
            // resized or the font size changes.
            if (different) {
                display.lastSizeC = display.wrapper.clientHeight;
                startWorker(cm, 400);
            }
            display.showingFrom = from;
            display.showingTo = to;
            updateHeightsInViewport(cm);
            updateViewOffset(cm);
            return true;
        }
        function updateHeightsInViewport(cm) {
            var display = cm.display;
            var prevBottom = display.lineDiv.offsetTop;
            for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
                if (node.lineObj) {
                    if (ie_lt8) {
                        var bot = node.offsetTop + node.offsetHeight;
                        height = bot - prevBottom;
                        prevBottom = bot;
                    } else {
                        var box = getRect(node);
                        height = box.bottom - box.top;
                    }
                    var diff = node.lineObj.height - height;
                    if (height < 2)
                        height = textHeight(display);
                    if (diff > 0.001 || diff < -0.001) {
                        updateLineHeight(node.lineObj, height);
                        var widgets = node.lineObj.widgets;
                        if (widgets)
                            for (var i = 0; i < widgets.length; ++i)
                                widgets[i].height = widgets[i].node.offsetHeight;
                    }
                }
        }
        function updateViewOffset(cm) {
            var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
            // Position the mover div to align with the current virtual scroll position
            cm.display.mover.style.top = off + 'px';
        }
        function computeIntact(intact, changes) {
            for (var i = 0, l = changes.length || 0; i < l; ++i) {
                var change = changes[i], intact2 = [], diff = change.diff || 0;
                for (var j = 0, l2 = intact.length; j < l2; ++j) {
                    var range = intact[j];
                    if (change.to <= range.from && change.diff) {
                        intact2.push({
                            from: range.from + diff,
                            to: range.to + diff
                        });
                    } else if (change.to <= range.from || change.from >= range.to) {
                        intact2.push(range);
                    } else {
                        if (change.from > range.from)
                            intact2.push({
                                from: range.from,
                                to: change.from
                            });
                        if (change.to < range.to)
                            intact2.push({
                                from: change.to + diff,
                                to: range.to + diff
                            });
                    }
                }
                intact = intact2;
            }
            return intact;
        }
        function getDimensions(cm) {
            var d = cm.display, left = {}, width = {};
            for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
                left[cm.options.gutters[i]] = n.offsetLeft;
                width[cm.options.gutters[i]] = n.offsetWidth;
            }
            return {
                fixedPos: compensateForHScroll(d),
                gutterTotalWidth: d.gutters.offsetWidth,
                gutterLeft: left,
                gutterWidth: width,
                wrapperWidth: d.wrapper.clientWidth
            };
        }
        function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
            var dims = getDimensions(cm);
            var display = cm.display, lineNumbers = cm.options.lineNumbers;
            if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
                removeChildren(display.lineDiv);
            var container = display.lineDiv, cur = container.firstChild;
            function rm(node) {
                var next = node.nextSibling;
                if (webkit && mac && cm.display.currentWheelTarget == node) {
                    node.style.display = 'none';
                    node.lineObj = null;
                } else {
                    node.parentNode.removeChild(node);
                }
                return next;
            }
            var nextIntact = intact.shift(), lineN = from;
            cm.doc.iter(from, to, function (line) {
                if (nextIntact && nextIntact.to == lineN)
                    nextIntact = intact.shift();
                if (lineIsHidden(cm.doc, line)) {
                    if (line.height != 0)
                        updateLineHeight(line, 0);
                    if (line.widgets && cur && cur.previousSibling)
                        for (var i = 0; i < line.widgets.length; ++i) {
                            var w = line.widgets[i];
                            if (w.showIfHidden) {
                                var prev = cur.previousSibling;
                                if (/pre/i.test(prev.nodeName)) {
                                    var wrap = elt('div', null, null, 'position: relative');
                                    prev.parentNode.replaceChild(wrap, prev);
                                    wrap.appendChild(prev);
                                    prev = wrap;
                                }
                                var wnode = prev.appendChild(elt('div', [w.node], 'CodeMirror-linewidget'));
                                if (!w.handleMouseEvents)
                                    wnode.ignoreEvents = true;
                                positionLineWidget(w, wnode, prev, dims);
                            }
                        }
                } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
                    // This line is intact. Skip to the actual node. Update its
                    // line number if needed.
                    while (cur.lineObj != line)
                        cur = rm(cur);
                    if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
                        setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
                    cur = cur.nextSibling;
                } else {
                    // For lines with widgets, make an attempt to find and reuse
                    // the existing element, so that widgets aren't needlessly
                    // removed and re-inserted into the dom
                    if (line.widgets)
                        for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
                            if (search.lineObj == line && /div/i.test(search.nodeName)) {
                                reuse = search;
                                break;
                            }
                    // This line needs to be generated.
                    var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
                    if (lineNode != reuse) {
                        container.insertBefore(lineNode, cur);
                    } else {
                        while (cur != reuse)
                            cur = rm(cur);
                        cur = cur.nextSibling;
                    }
                    lineNode.lineObj = line;
                }
                ++lineN;
            });
            while (cur)
                cur = rm(cur);
        }
        function buildLineElement(cm, line, lineNo, dims, reuse) {
            var built = buildLineContent(cm, line), lineElement = built.pre;
            var markers = line.gutterMarkers, display = cm.display, wrap;
            var bgClass = built.bgClass ? built.bgClass + ' ' + (line.bgClass || '') : line.bgClass;
            if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)
                return lineElement;
            // Lines with gutter elements, widgets or a background class need
            // to be wrapped again, and have the extra elements added to the
            // wrapper div
            if (reuse) {
                reuse.alignable = null;
                var isOk = true, widgetsSeen = 0, insertBefore = null;
                for (var n = reuse.firstChild, next; n; n = next) {
                    next = n.nextSibling;
                    if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
                        reuse.removeChild(n);
                    } else {
                        for (var i = 0; i < line.widgets.length; ++i) {
                            var widget = line.widgets[i];
                            if (widget.node == n.firstChild) {
                                if (!widget.above && !insertBefore)
                                    insertBefore = n;
                                positionLineWidget(widget, n, reuse, dims);
                                ++widgetsSeen;
                                break;
                            }
                        }
                        if (i == line.widgets.length) {
                            isOk = false;
                            break;
                        }
                    }
                }
                reuse.insertBefore(lineElement, insertBefore);
                if (isOk && widgetsSeen == line.widgets.length) {
                    wrap = reuse;
                    reuse.className = line.wrapClass || '';
                }
            }
            if (!wrap) {
                wrap = elt('div', null, line.wrapClass, 'position: relative');
                wrap.appendChild(lineElement);
            }
            // Kludge to make sure the styled element lies behind the selection (by z-index)
            if (bgClass)
                wrap.insertBefore(elt('div', null, bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
            if (cm.options.lineNumbers || markers) {
                var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
                if (cm.options.fixedGutter)
                    (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
                if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
                    wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
                if (markers)
                    for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                        if (found)
                            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
                    }
            }
            if (ie_lt8)
                wrap.style.zIndex = 2;
            if (line.widgets && wrap != reuse)
                for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
                    if (!widget.handleMouseEvents)
                        node.ignoreEvents = true;
                    positionLineWidget(widget, node, wrap, dims);
                    if (widget.above)
                        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
                    else
                        wrap.appendChild(node);
                    signalLater(widget, 'redraw');
                }
            return wrap;
        }
        function positionLineWidget(widget, node, wrap, dims) {
            if (widget.noHScroll) {
                (wrap.alignable || (wrap.alignable = [])).push(node);
                var width = dims.wrapperWidth;
                node.style.left = dims.fixedPos + 'px';
                if (!widget.coverGutter) {
                    width -= dims.gutterTotalWidth;
                    node.style.paddingLeft = dims.gutterTotalWidth + 'px';
                }
                node.style.width = width + 'px';
            }
            if (widget.coverGutter) {
                node.style.zIndex = 5;
                node.style.position = 'relative';
                if (!widget.noHScroll)
                    node.style.marginLeft = -dims.gutterTotalWidth + 'px';
            }
        }
        // SELECTION / CURSOR
        function updateSelection(cm) {
            var display = cm.display;
            var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
            if (collapsed || cm.options.showCursorWhenSelecting)
                updateSelectionCursor(cm);
            else
                display.cursor.style.display = display.otherCursor.style.display = 'none';
            if (!collapsed)
                updateSelectionRange(cm);
            else
                display.selectionDiv.style.display = 'none';
            // Move the hidden textarea near the cursor to prevent scrolling artifacts
            if (cm.options.moveInputWithCursor) {
                var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
                var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
                display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
                display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
            }
        }
        // No selection, plain cursor
        function updateSelectionCursor(cm) {
            var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
            display.cursor.style.left = pos.left + 'px';
            display.cursor.style.top = pos.top + 'px';
            display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
            display.cursor.style.display = '';
            if (pos.other) {
                display.otherCursor.style.display = '';
                display.otherCursor.style.left = pos.other.left + 'px';
                display.otherCursor.style.top = pos.other.top + 'px';
                display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
            } else {
                display.otherCursor.style.display = 'none';
            }
        }
        // Highlight selection
        function updateSelectionRange(cm) {
            var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
            var fragment = document.createDocumentFragment();
            var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
            function add(left, top, width, bottom) {
                if (top < 0)
                    top = 0;
                fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
            }
            function drawForLine(line, fromArg, toArg) {
                var lineObj = getLine(doc, line);
                var lineLen = lineObj.text.length;
                var start, end;
                function coords(ch, bias) {
                    return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
                }
                iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
                    var leftPos = coords(from, 'left'), rightPos, left, right;
                    if (from == to) {
                        rightPos = leftPos;
                        left = right = leftPos.left;
                    } else {
                        rightPos = coords(to - 1, 'right');
                        if (dir == 'rtl') {
                            var tmp = leftPos;
                            leftPos = rightPos;
                            rightPos = tmp;
                        }
                        left = leftPos.left;
                        right = rightPos.right;
                    }
                    if (fromArg == null && from == 0)
                        left = pl;
                    if (rightPos.top - leftPos.top > 3) {
                        // Different lines, draw top part
                        add(left, leftPos.top, null, leftPos.bottom);
                        left = pl;
                        if (leftPos.bottom < rightPos.top)
                            add(left, leftPos.bottom, null, rightPos.top);
                    }
                    if (toArg == null && to == lineLen)
                        right = clientWidth;
                    if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
                        start = leftPos;
                    if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
                        end = rightPos;
                    if (left < pl + 1)
                        left = pl;
                    add(left, rightPos.top, right - left, rightPos.bottom);
                });
                return {
                    start: start,
                    end: end
                };
            }
            if (sel.from.line == sel.to.line) {
                drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
            } else {
                var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);
                var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
                var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
                var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
                if (singleVLine) {
                    if (leftEnd.top < rightStart.top - 2) {
                        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                        add(pl, rightStart.top, rightStart.left, rightStart.bottom);
                    } else {
                        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                    }
                }
                if (leftEnd.bottom < rightStart.top)
                    add(pl, leftEnd.bottom, null, rightStart.top);
            }
            removeChildrenAndAdd(display.selectionDiv, fragment);
            display.selectionDiv.style.display = '';
        }
        // Cursor-blinking
        function restartBlink(cm) {
            if (!cm.state.focused)
                return;
            var display = cm.display;
            clearInterval(display.blinker);
            var on = true;
            display.cursor.style.visibility = display.otherCursor.style.visibility = '';
            if (cm.options.cursorBlinkRate > 0)
                display.blinker = setInterval(function () {
                    display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
                }, cm.options.cursorBlinkRate);
        }
        // HIGHLIGHT WORKER
        function startWorker(cm, time) {
            if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
                cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
        function highlightWorker(cm) {
            var doc = cm.doc;
            if (doc.frontier < doc.first)
                doc.frontier = doc.first;
            if (doc.frontier >= cm.display.showingTo)
                return;
            var end = +new Date() + cm.options.workTime;
            var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
            var changed = [], prevChange;
            doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
                if (doc.frontier >= cm.display.showingFrom) {
                    // Visible
                    var oldStyles = line.styles;
                    line.styles = highlightLine(cm, line, state);
                    var ischange = !oldStyles || oldStyles.length != line.styles.length;
                    for (var i = 0; !ischange && i < oldStyles.length; ++i)
                        ischange = oldStyles[i] != line.styles[i];
                    if (ischange) {
                        if (prevChange && prevChange.end == doc.frontier)
                            prevChange.end++;
                        else
                            changed.push(prevChange = {
                                start: doc.frontier,
                                end: doc.frontier + 1
                            });
                    }
                    line.stateAfter = copyState(doc.mode, state);
                } else {
                    processLine(cm, line, state);
                    line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                }
                ++doc.frontier;
                if (+new Date() > end) {
                    startWorker(cm, cm.options.workDelay);
                    return true;
                }
            });
            if (changed.length)
                operation(cm, function () {
                    for (var i = 0; i < changed.length; ++i)
                        regChange(this, changed[i].start, changed[i].end);
                })();
        }
        // Finds the line to start with when starting a parse. Tries to
        // find a line with a stateAfter, so that it can start with a
        // valid state. If that fails, it returns the line with the
        // smallest indentation, which tends to need the least context to
        // parse correctly.
        function findStartLine(cm, n, precise) {
            var minindent, minline, doc = cm.doc;
            var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
            for (var search = n; search > lim; --search) {
                if (search <= doc.first)
                    return doc.first;
                var line = getLine(doc, search - 1);
                if (line.stateAfter && (!precise || search <= doc.frontier))
                    return search;
                var indented = countColumn(line.text, null, cm.options.tabSize);
                if (minline == null || minindent > indented) {
                    minline = search - 1;
                    minindent = indented;
                }
            }
            return minline;
        }
        function getStateBefore(cm, n, precise) {
            var doc = cm.doc, display = cm.display;
            if (!doc.mode.startState)
                return true;
            var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
            if (!state)
                state = startState(doc.mode);
            else
                state = copyState(doc.mode, state);
            doc.iter(pos, n, function (line) {
                processLine(cm, line, state);
                var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
                line.stateAfter = save ? copyState(doc.mode, state) : null;
                ++pos;
            });
            if (precise)
                doc.frontier = pos;
            return state;
        }
        // POSITION MEASUREMENT
        function paddingTop(display) {
            return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
            return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingLeft(display) {
            var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
            return e.offsetLeft;
        }
        function measureChar(cm, line, ch, data, bias) {
            var dir = -1;
            data = data || measureLine(cm, line);
            if (data.crude) {
                var left = data.left + ch * data.width;
                return {
                    left: left,
                    right: left + data.width,
                    top: data.top,
                    bottom: data.bottom
                };
            }
            for (var pos = ch;; pos += dir) {
                var r = data[pos];
                if (r)
                    break;
                if (dir < 0 && pos == 0)
                    dir = 1;
            }
            bias = pos > ch ? 'left' : pos < ch ? 'right' : bias;
            if (bias == 'left' && r.leftSide)
                r = r.leftSide;
            else if (bias == 'right' && r.rightSide)
                r = r.rightSide;
            return {
                left: pos < ch ? r.right : r.left,
                right: pos > ch ? r.left : r.right,
                top: r.top,
                bottom: r.bottom
            };
        }
        function findCachedMeasurement(cm, line) {
            var cache = cm.display.measureLineCache;
            for (var i = 0; i < cache.length; ++i) {
                var memo = cache[i];
                if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.wrapClass)
                    return memo;
            }
        }
        function clearCachedMeasurement(cm, line) {
            var exists = findCachedMeasurement(cm, line);
            if (exists)
                exists.text = exists.measure = exists.markedSpans = null;
        }
        function measureLine(cm, line) {
            // First look in the cache
            var cached = findCachedMeasurement(cm, line);
            if (cached)
                return cached.measure;
            // Failing that, recompute and store result in cache
            var measure = measureLineInner(cm, line);
            var cache = cm.display.measureLineCache;
            var memo = {
                    text: line.text,
                    width: cm.display.scroller.clientWidth,
                    markedSpans: line.markedSpans,
                    measure: measure,
                    classes: line.textClass + '|' + line.wrapClass
                };
            if (cache.length == 16)
                cache[++cm.display.measureLineCachePos % 16] = memo;
            else
                cache.push(memo);
            return measure;
        }
        function measureLineInner(cm, line) {
            if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)
                return crudelyMeasureLine(cm, line);
            var display = cm.display, measure = emptyArray(line.text.length);
            var pre = buildLineContent(cm, line, measure, true).pre;
            // IE does not cache element positions of inline elements between
            // calls to getBoundingClientRect. This makes the loop below,
            // which gathers the positions of all the characters on the line,
            // do an amount of layout work quadratic to the number of
            // characters. When line wrapping is off, we try to improve things
            // by first subdividing the line into a bunch of inline blocks, so
            // that IE can reuse most of the layout information from caches
            // for those blocks. This does interfere with line wrapping, so it
            // doesn't work when wrapping is on, but in that case the
            // situation is slightly better, since IE does cache line-wrapping
            // information and only recomputes per-line.
            if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
                var fragment = document.createDocumentFragment();
                var chunk = 10, n = pre.childNodes.length;
                for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
                    var wrap = elt('div', null, null, 'display: inline-block');
                    for (var j = 0; j < chunk && n; ++j) {
                        wrap.appendChild(pre.firstChild);
                        --n;
                    }
                    fragment.appendChild(wrap);
                }
                pre.appendChild(fragment);
            }
            removeChildrenAndAdd(display.measure, pre);
            var outer = getRect(display.lineDiv);
            var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
            // Work around an IE7/8 bug where it will sometimes have randomly
            // replaced our pre with a clone at this point.
            if (ie_lt9 && display.measure.first != pre)
                removeChildrenAndAdd(display.measure, pre);
            function measureRect(rect) {
                var top = rect.top - outer.top, bot = rect.bottom - outer.top;
                if (bot > maxBot)
                    bot = maxBot;
                if (top < 0)
                    top = 0;
                for (var i = vranges.length - 2; i >= 0; i -= 2) {
                    var rtop = vranges[i], rbot = vranges[i + 1];
                    if (rtop > bot || rbot < top)
                        continue;
                    if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
                        vranges[i] = Math.min(top, rtop);
                        vranges[i + 1] = Math.max(bot, rbot);
                        break;
                    }
                }
                if (i < 0) {
                    i = vranges.length;
                    vranges.push(top, bot);
                }
                return {
                    left: rect.left - outer.left,
                    right: rect.right - outer.left,
                    top: i,
                    bottom: null
                };
            }
            function finishRect(rect) {
                rect.bottom = vranges[rect.top + 1];
                rect.top = vranges[rect.top];
            }
            for (var i = 0, cur; i < measure.length; ++i)
                if (cur = measure[i]) {
                    var node = cur, rect = null;
                    // A widget might wrap, needs special care
                    if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
                        if (cur.firstChild.nodeType == 1)
                            node = cur.firstChild;
                        var rects = node.getClientRects();
                        if (rects.length > 1) {
                            rect = data[i] = measureRect(rects[0]);
                            rect.rightSide = measureRect(rects[rects.length - 1]);
                        }
                    }
                    if (!rect)
                        rect = data[i] = measureRect(getRect(node));
                    if (cur.measureRight)
                        rect.right = getRect(cur.measureRight).left;
                    if (cur.leftSide)
                        rect.leftSide = measureRect(getRect(cur.leftSide));
                }
            removeChildren(cm.display.measure);
            for (var i = 0, cur; i < data.length; ++i)
                if (cur = data[i]) {
                    finishRect(cur);
                    if (cur.leftSide)
                        finishRect(cur.leftSide);
                    if (cur.rightSide)
                        finishRect(cur.rightSide);
                }
            return data;
        }
        function crudelyMeasureLine(cm, line) {
            var copy = new Line(line.text.slice(0, 100), null);
            if (line.textClass)
                copy.textClass = line.textClass;
            var measure = measureLineInner(cm, copy);
            var left = measureChar(cm, copy, 0, measure, 'left');
            var right = measureChar(cm, copy, 99, measure, 'right');
            return {
                crude: true,
                top: left.top,
                left: left.left,
                bottom: left.bottom,
                width: (right.right - left.left) / 100
            };
        }
        function measureLineWidth(cm, line) {
            var hasBadSpan = false;
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans; ++i) {
                    var sp = line.markedSpans[i];
                    if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
                        hasBadSpan = true;
                }
            var cached = !hasBadSpan && findCachedMeasurement(cm, line);
            if (cached || line.text.length >= cm.options.crudeMeasuringFrom)
                return measureChar(cm, line, line.text.length, cached && cached.measure, 'right').right;
            var pre = buildLineContent(cm, line, null, true).pre;
            var end = pre.appendChild(zeroWidthElement(cm.display.measure));
            removeChildrenAndAdd(cm.display.measure, pre);
            return getRect(end).right - getRect(cm.display.lineDiv).left;
        }
        function clearCaches(cm) {
            cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
            cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
            if (!cm.options.lineWrapping)
                cm.display.maxLineChanged = true;
            cm.display.lineNumChars = null;
        }
        function pageScrollX() {
            return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
        }
        function pageScrollY() {
            return window.pageYOffset || (document.documentElement || document.body).scrollTop;
        }
        // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
        function intoCoordSystem(cm, lineObj, rect, context) {
            if (lineObj.widgets)
                for (var i = 0; i < lineObj.widgets.length; ++i)
                    if (lineObj.widgets[i].above) {
                        var size = widgetHeight(lineObj.widgets[i]);
                        rect.top += size;
                        rect.bottom += size;
                    }
            if (context == 'line')
                return rect;
            if (!context)
                context = 'local';
            var yOff = heightAtLine(cm, lineObj);
            if (context == 'local')
                yOff += paddingTop(cm.display);
            else
                yOff -= cm.display.viewOffset;
            if (context == 'page' || context == 'window') {
                var lOff = getRect(cm.display.lineSpace);
                yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
                var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
                rect.left += xOff;
                rect.right += xOff;
            }
            rect.top += yOff;
            rect.bottom += yOff;
            return rect;
        }
        // Context may be "window", "page", "div", or "local"/null
        // Result is in "div" coords
        function fromCoordSystem(cm, coords, context) {
            if (context == 'div')
                return coords;
            var left = coords.left, top = coords.top;
            // First move into "page" coordinate system
            if (context == 'page') {
                left -= pageScrollX();
                top -= pageScrollY();
            } else if (context == 'local' || !context) {
                var localBox = getRect(cm.display.sizer);
                left += localBox.left;
                top += localBox.top;
            }
            var lineSpaceBox = getRect(cm.display.lineSpace);
            return {
                left: left - lineSpaceBox.left,
                top: top - lineSpaceBox.top
            };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
            if (!lineObj)
                lineObj = getLine(cm.doc, pos.line);
            return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, measurement) {
            lineObj = lineObj || getLine(cm.doc, pos.line);
            if (!measurement)
                measurement = measureLine(cm, lineObj);
            function get(ch, right) {
                var m = measureChar(cm, lineObj, ch, measurement, right ? 'right' : 'left');
                if (right)
                    m.left = m.right;
                else
                    m.right = m.left;
                return intoCoordSystem(cm, lineObj, m, context);
            }
            function getBidi(ch, partPos) {
                var part = order[partPos], right = part.level % 2;
                if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
                    part = order[--partPos];
                    ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
                    right = true;
                } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
                    part = order[++partPos];
                    ch = bidiLeft(part) - part.level % 2;
                    right = false;
                }
                if (right && ch == part.to && ch > part.from)
                    return get(ch - 1);
                return get(ch, right);
            }
            var order = getOrder(lineObj), ch = pos.ch;
            if (!order)
                return get(ch);
            var partPos = getBidiPartAt(order, ch);
            var val = getBidi(ch, partPos);
            if (bidiOther != null)
                val.other = getBidi(ch, bidiOther);
            return val;
        }
        function PosWithInfo(line, ch, outside, xRel) {
            var pos = new Pos(line, ch);
            pos.xRel = xRel;
            if (outside)
                pos.outside = true;
            return pos;
        }
        // Coords must be lineSpace-local
        function coordsChar(cm, x, y) {
            var doc = cm.doc;
            y += cm.display.viewOffset;
            if (y < 0)
                return PosWithInfo(doc.first, 0, true, -1);
            var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
            if (lineNo > last)
                return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
            if (x < 0)
                x = 0;
            for (;;) {
                var lineObj = getLine(doc, lineNo);
                var found = coordsCharInner(cm, lineObj, lineNo, x, y);
                var merged = collapsedSpanAtEnd(lineObj);
                var mergedPos = merged && merged.find();
                if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                    lineNo = mergedPos.to.line;
                else
                    return found;
            }
        }
        function coordsCharInner(cm, lineObj, lineNo, x, y) {
            var innerOff = y - heightAtLine(cm, lineObj);
            var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
            var measurement = measureLine(cm, lineObj);
            function getX(ch) {
                var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
                wrongLine = true;
                if (innerOff > sp.bottom)
                    return sp.left - adjust;
                else if (innerOff < sp.top)
                    return sp.left + adjust;
                else
                    wrongLine = false;
                return sp.left;
            }
            var bidi = getOrder(lineObj), dist = lineObj.text.length;
            var from = lineLeft(lineObj), to = lineRight(lineObj);
            var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
            if (x > toX)
                return PosWithInfo(lineNo, to, toOutside, 1);
            // Do a binary search between these bounds.
            for (;;) {
                if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                    var ch = x < fromX || x - fromX <= toX - x ? from : to;
                    var xDiff = x - (ch == from ? fromX : toX);
                    while (isExtendingChar.test(lineObj.text.charAt(ch)))
                        ++ch;
                    var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);
                    return pos;
                }
                var step = Math.ceil(dist / 2), middle = from + step;
                if (bidi) {
                    middle = from;
                    for (var i = 0; i < step; ++i)
                        middle = moveVisually(lineObj, middle, 1);
                }
                var middleX = getX(middle);
                if (middleX > x) {
                    to = middle;
                    toX = middleX;
                    if (toOutside = wrongLine)
                        toX += 1000;
                    dist = step;
                } else {
                    from = middle;
                    fromX = middleX;
                    fromOutside = wrongLine;
                    dist -= step;
                }
            }
        }
        var measureText;
        function textHeight(display) {
            if (display.cachedTextHeight != null)
                return display.cachedTextHeight;
            if (measureText == null) {
                measureText = elt('pre');
                // Measure a bunch of lines, for browsers that compute
                // fractional heights.
                for (var i = 0; i < 49; ++i) {
                    measureText.appendChild(document.createTextNode('x'));
                    measureText.appendChild(elt('br'));
                }
                measureText.appendChild(document.createTextNode('x'));
            }
            removeChildrenAndAdd(display.measure, measureText);
            var height = measureText.offsetHeight / 50;
            if (height > 3)
                display.cachedTextHeight = height;
            removeChildren(display.measure);
            return height || 1;
        }
        function charWidth(display) {
            if (display.cachedCharWidth != null)
                return display.cachedCharWidth;
            var anchor = elt('span', 'x');
            var pre = elt('pre', [anchor]);
            removeChildrenAndAdd(display.measure, pre);
            var width = anchor.offsetWidth;
            if (width > 2)
                display.cachedCharWidth = width;
            return width || 10;
        }
        // OPERATIONS
        // Operations are used to wrap changes in such a way that each
        // change won't have to update the cursor and display (which would
        // be awkward, slow, and error-prone), but instead updates are
        // batched and then all combined and executed at once.
        var nextOpId = 0;
        function startOperation(cm) {
            cm.curOp = {
                changes: [],
                forceUpdate: false,
                updateInput: null,
                userSelChange: null,
                textChanged: null,
                selectionChanged: false,
                cursorActivity: false,
                updateMaxLine: false,
                updateScrollPos: false,
                id: ++nextOpId
            };
            if (!delayedCallbackDepth++)
                delayedCallbacks = [];
        }
        function endOperation(cm) {
            var op = cm.curOp, doc = cm.doc, display = cm.display;
            cm.curOp = null;
            if (op.updateMaxLine)
                computeMaxLength(cm);
            if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
                var width = measureLineWidth(cm, display.maxLine);
                display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
                display.maxLineChanged = false;
                var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
                if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
                    setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
            }
            var newScrollPos, updated;
            if (op.updateScrollPos) {
                newScrollPos = op.updateScrollPos;
            } else if (op.selectionChanged && display.scroller.clientHeight) {
                // don't rescroll if not visible
                var coords = cursorCoords(cm, doc.sel.head);
                newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
            }
            if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {
                updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);
                if (cm.display.scroller.offsetHeight)
                    cm.doc.scrollTop = cm.display.scroller.scrollTop;
            }
            if (!updated && op.selectionChanged)
                updateSelection(cm);
            if (op.updateScrollPos) {
                display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
                display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
                alignHorizontally(cm);
                if (op.scrollToPos)
                    scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
            } else if (newScrollPos) {
                scrollCursorIntoView(cm);
            }
            if (op.selectionChanged)
                restartBlink(cm);
            if (cm.state.focused && op.updateInput)
                resetInput(cm, op.userSelChange);
            var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
            if (hidden)
                for (var i = 0; i < hidden.length; ++i)
                    if (!hidden[i].lines.length)
                        signal(hidden[i], 'hide');
            if (unhidden)
                for (var i = 0; i < unhidden.length; ++i)
                    if (unhidden[i].lines.length)
                        signal(unhidden[i], 'unhide');
            var delayed;
            if (!--delayedCallbackDepth) {
                delayed = delayedCallbacks;
                delayedCallbacks = null;
            }
            if (op.textChanged)
                signal(cm, 'change', cm, op.textChanged);
            if (op.cursorActivity)
                signal(cm, 'cursorActivity', cm);
            if (delayed)
                for (var i = 0; i < delayed.length; ++i)
                    delayed[i]();
        }
        // Wraps a function in an operation. Returns the wrapped function.
        function operation(cm1, f) {
            return function () {
                var cm = cm1 || this, withOp = !cm.curOp;
                if (withOp)
                    startOperation(cm);
                try {
                    var result = f.apply(cm, arguments);
                } finally {
                    if (withOp)
                        endOperation(cm);
                }
                return result;
            };
        }
        function docOperation(f) {
            return function () {
                var withOp = this.cm && !this.cm.curOp, result;
                if (withOp)
                    startOperation(this.cm);
                try {
                    result = f.apply(this, arguments);
                } finally {
                    if (withOp)
                        endOperation(this.cm);
                }
                return result;
            };
        }
        function runInOp(cm, f) {
            var withOp = !cm.curOp, result;
            if (withOp)
                startOperation(cm);
            try {
                result = f();
            } finally {
                if (withOp)
                    endOperation(cm);
            }
            return result;
        }
        function regChange(cm, from, to, lendiff) {
            if (from == null)
                from = cm.doc.first;
            if (to == null)
                to = cm.doc.first + cm.doc.size;
            cm.curOp.changes.push({
                from: from,
                to: to,
                diff: lendiff
            });
        }
        // INPUT HANDLING
        function slowPoll(cm) {
            if (cm.display.pollingFast)
                return;
            cm.display.poll.set(cm.options.pollInterval, function () {
                readInput(cm);
                if (cm.state.focused)
                    slowPoll(cm);
            });
        }
        function fastPoll(cm) {
            var missed = false;
            cm.display.pollingFast = true;
            function p() {
                var changed = readInput(cm);
                if (!changed && !missed) {
                    missed = true;
                    cm.display.poll.set(60, p);
                } else {
                    cm.display.pollingFast = false;
                    slowPoll(cm);
                }
            }
            cm.display.poll.set(20, p);
        }
        // prevInput is a hack to work with IME. If we reset the textarea
        // on every change, that breaks IME. So we look for changes
        // compared to the previous content instead. (Modern browsers have
        // events that indicate IME taking place, but these are not widely
        // supported or compatible enough yet to rely on.)
        function readInput(cm) {
            var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
            if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput)
                return false;
            if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
                input.value = input.value.substring(0, input.value.length - 1);
                cm.state.fakedLastChar = false;
            }
            var text = input.value;
            if (text == prevInput && posEq(sel.from, sel.to))
                return false;
            if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
                resetInput(cm, true);
                return false;
            }
            var withOp = !cm.curOp;
            if (withOp)
                startOperation(cm);
            sel.shift = false;
            var same = 0, l = Math.min(prevInput.length, text.length);
            while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
                ++same;
            var from = sel.from, to = sel.to;
            if (same < prevInput.length)
                from = Pos(from.line, from.ch - (prevInput.length - same));
            else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
            var updateInput = cm.curOp.updateInput;
            var changeEvent = {
                    from: from,
                    to: to,
                    text: splitLines(text.slice(same)),
                    origin: cm.state.pasteIncoming ? 'paste' : '+input'
                };
            makeChange(cm.doc, changeEvent, 'end');
            cm.curOp.updateInput = updateInput;
            signalLater(cm, 'inputRead', cm, changeEvent);
            if (text.length > 1000 || text.indexOf('\n') > -1)
                input.value = cm.display.prevInput = '';
            else
                cm.display.prevInput = text;
            if (withOp)
                endOperation(cm);
            cm.state.pasteIncoming = false;
            return true;
        }
        function resetInput(cm, user) {
            var minimal, selected, doc = cm.doc;
            if (!posEq(doc.sel.from, doc.sel.to)) {
                cm.display.prevInput = '';
                minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
                var content = minimal ? '-' : selected || cm.getSelection();
                cm.display.input.value = content;
                if (cm.state.focused)
                    selectInput(cm.display.input);
                if (ie && !ie_lt9)
                    cm.display.inputHasSelection = content;
            } else if (user) {
                cm.display.prevInput = cm.display.input.value = '';
                if (ie && !ie_lt9)
                    cm.display.inputHasSelection = null;
            }
            cm.display.inaccurateSelection = minimal;
        }
        function focusInput(cm) {
            if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
                cm.display.input.focus();
        }
        function isReadOnly(cm) {
            return cm.options.readOnly || cm.doc.cantEdit;
        }
        // EVENT HANDLERS
        function registerEventHandlers(cm) {
            var d = cm.display;
            on(d.scroller, 'mousedown', operation(cm, onMouseDown));
            if (ie)
                on(d.scroller, 'dblclick', operation(cm, function (e) {
                    if (signalDOMEvent(cm, e))
                        return;
                    var pos = posFromMouse(cm, e);
                    if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
                        return;
                    e_preventDefault(e);
                    var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
                    extendSelection(cm.doc, word.from, word.to);
                }));
            else
                on(d.scroller, 'dblclick', function (e) {
                    signalDOMEvent(cm, e) || e_preventDefault(e);
                });
            on(d.lineSpace, 'selectstart', function (e) {
                if (!eventInWidget(d, e))
                    e_preventDefault(e);
            });
            // Gecko browsers fire contextmenu *after* opening the menu, at
            // which point we can't mess with it anymore. Context menu is
            // handled in onMouseDown for Gecko.
            if (!captureMiddleClick)
                on(d.scroller, 'contextmenu', function (e) {
                    onContextMenu(cm, e);
                });
            on(d.scroller, 'scroll', function () {
                if (d.scroller.clientHeight) {
                    setScrollTop(cm, d.scroller.scrollTop);
                    setScrollLeft(cm, d.scroller.scrollLeft, true);
                    signal(cm, 'scroll', cm);
                }
            });
            on(d.scrollbarV, 'scroll', function () {
                if (d.scroller.clientHeight)
                    setScrollTop(cm, d.scrollbarV.scrollTop);
            });
            on(d.scrollbarH, 'scroll', function () {
                if (d.scroller.clientHeight)
                    setScrollLeft(cm, d.scrollbarH.scrollLeft);
            });
            on(d.scroller, 'mousewheel', function (e) {
                onScrollWheel(cm, e);
            });
            on(d.scroller, 'DOMMouseScroll', function (e) {
                onScrollWheel(cm, e);
            });
            function reFocus() {
                if (cm.state.focused)
                    setTimeout(bind(focusInput, cm), 0);
            }
            on(d.scrollbarH, 'mousedown', reFocus);
            on(d.scrollbarV, 'mousedown', reFocus);
            // Prevent wrapper from ever scrolling
            on(d.wrapper, 'scroll', function () {
                d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
            });
            var resizeTimer;
            function onResize() {
                if (resizeTimer == null)
                    resizeTimer = setTimeout(function () {
                        resizeTimer = null;
                        // Might be a text scaling operation, clear size caches.
                        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
                        clearCaches(cm);
                        runInOp(cm, bind(regChange, cm));
                    }, 100);
            }
            on(window, 'resize', onResize);
            // Above handler holds on to the editor and its data structures.
            // Here we poll to unregister it when the editor is no longer in
            // the document, so that it can be garbage-collected.
            function unregister() {
                for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
                }
                if (p)
                    setTimeout(unregister, 5000);
                else
                    off(window, 'resize', onResize);
            }
            setTimeout(unregister, 5000);
            on(d.input, 'keyup', operation(cm, function (e) {
                if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                    return;
                if (e.keyCode == 16)
                    cm.doc.sel.shift = false;
            }));
            on(d.input, 'input', function () {
                if (ie && !ie_lt9 && cm.display.inputHasSelection)
                    cm.display.inputHasSelection = null;
                fastPoll(cm);
            });
            on(d.input, 'keydown', operation(cm, onKeyDown));
            on(d.input, 'keypress', operation(cm, onKeyPress));
            on(d.input, 'focus', bind(onFocus, cm));
            on(d.input, 'blur', bind(onBlur, cm));
            function drag_(e) {
                if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
                    return;
                e_stop(e);
            }
            if (cm.options.dragDrop) {
                on(d.scroller, 'dragstart', function (e) {
                    onDragStart(cm, e);
                });
                on(d.scroller, 'dragenter', drag_);
                on(d.scroller, 'dragover', drag_);
                on(d.scroller, 'drop', operation(cm, onDrop));
            }
            on(d.scroller, 'paste', function (e) {
                if (eventInWidget(d, e))
                    return;
                focusInput(cm);
                fastPoll(cm);
            });
            on(d.input, 'paste', function () {
                // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
                // Add a char to the end of textarea before paste occur so that
                // selection doesn't span to the end of textarea.
                if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
                    var start = d.input.selectionStart, end = d.input.selectionEnd;
                    d.input.value += '$';
                    d.input.selectionStart = start;
                    d.input.selectionEnd = end;
                    cm.state.fakedLastChar = true;
                }
                cm.state.pasteIncoming = true;
                fastPoll(cm);
            });
            function prepareCopy() {
                if (d.inaccurateSelection) {
                    d.prevInput = '';
                    d.inaccurateSelection = false;
                    d.input.value = cm.getSelection();
                    selectInput(d.input);
                }
            }
            on(d.input, 'cut', prepareCopy);
            on(d.input, 'copy', prepareCopy);
            // Needed to handle Tab key in KHTML
            if (khtml)
                on(d.sizer, 'mouseup', function () {
                    if (document.activeElement == d.input)
                        d.input.blur();
                    focusInput(cm);
                });
        }
        function eventInWidget(display, e) {
            for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
                if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
                    return true;
            }
        }
        function posFromMouse(cm, e, liberal) {
            var display = cm.display;
            if (!liberal) {
                var target = e_target(e);
                if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller)
                    return null;
            }
            var x, y, space = getRect(display.lineSpace);
            // Fails unpredictably on IE[67] when mouse is dragged around quickly.
            try {
                x = e.clientX;
                y = e.clientY;
            } catch (e) {
                return null;
            }
            return coordsChar(cm, x - space.left, y - space.top);
        }
        var lastClick, lastDoubleClick;
        function onMouseDown(e) {
            if (signalDOMEvent(this, e))
                return;
            var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
            sel.shift = e.shiftKey;
            if (eventInWidget(display, e)) {
                if (!webkit) {
                    display.scroller.draggable = false;
                    setTimeout(function () {
                        display.scroller.draggable = true;
                    }, 100);
                }
                return;
            }
            if (clickInGutter(cm, e))
                return;
            var start = posFromMouse(cm, e);
            switch (e_button(e)) {
            case 3:
                if (captureMiddleClick)
                    onContextMenu.call(cm, cm, e);
                return;
            case 2:
                if (webkit)
                    cm.state.lastMiddleDown = +new Date();
                if (start)
                    extendSelection(cm.doc, start);
                setTimeout(bind(focusInput, cm), 20);
                e_preventDefault(e);
                return;
            }
            // For button 1, if it was clicked inside the editor
            // (posFromMouse returning non-null), we have to adjust the
            // selection.
            if (!start) {
                if (e_target(e) == display.scroller)
                    e_preventDefault(e);
                return;
            }
            if (!cm.state.focused)
                onFocus(cm);
            var now = +new Date(), type = 'single';
            if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
                type = 'triple';
                e_preventDefault(e);
                setTimeout(bind(focusInput, cm), 20);
                selectLine(cm, start.line);
            } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
                type = 'double';
                lastDoubleClick = {
                    time: now,
                    pos: start
                };
                e_preventDefault(e);
                var word = findWordAt(getLine(doc, start.line).text, start);
                extendSelection(cm.doc, word.from, word.to);
            } else {
                lastClick = {
                    time: now,
                    pos: start
                };
            }
            var last = start;
            if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
                var dragEnd = operation(cm, function (e2) {
                        if (webkit)
                            display.scroller.draggable = false;
                        cm.state.draggingText = false;
                        off(document, 'mouseup', dragEnd);
                        off(display.scroller, 'drop', dragEnd);
                        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                            e_preventDefault(e2);
                            extendSelection(cm.doc, start);
                            focusInput(cm);
                        }
                    });
                // Let the drag handler handle this.
                if (webkit)
                    display.scroller.draggable = true;
                cm.state.draggingText = dragEnd;
                // IE's approach to draggable
                if (display.scroller.dragDrop)
                    display.scroller.dragDrop();
                on(document, 'mouseup', dragEnd);
                on(display.scroller, 'drop', dragEnd);
                return;
            }
            e_preventDefault(e);
            if (type == 'single')
                extendSelection(cm.doc, clipPos(doc, start));
            var startstart = sel.from, startend = sel.to, lastPos = start;
            function doSelect(cur) {
                if (posEq(lastPos, cur))
                    return;
                lastPos = cur;
                if (type == 'single') {
                    extendSelection(cm.doc, clipPos(doc, start), cur);
                    return;
                }
                startstart = clipPos(doc, startstart);
                startend = clipPos(doc, startend);
                if (type == 'double') {
                    var word = findWordAt(getLine(doc, cur.line).text, cur);
                    if (posLess(cur, startstart))
                        extendSelection(cm.doc, word.from, startend);
                    else
                        extendSelection(cm.doc, startstart, word.to);
                } else if (type == 'triple') {
                    if (posLess(cur, startstart))
                        extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
                    else
                        extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
                }
            }
            var editorSize = getRect(display.wrapper);
            // Used to ensure timeout re-tries don't fire when another extend
            // happened in the meantime (clearTimeout isn't reliable -- at
            // least on Chrome, the timeouts still happen even when cleared,
            // if the clear happens after their scheduled firing time).
            var counter = 0;
            function extend(e) {
                var curCount = ++counter;
                var cur = posFromMouse(cm, e, true);
                if (!cur)
                    return;
                if (!posEq(cur, last)) {
                    if (!cm.state.focused)
                        onFocus(cm);
                    last = cur;
                    doSelect(cur);
                    var visible = visibleLines(display, doc);
                    if (cur.line >= visible.to || cur.line < visible.from)
                        setTimeout(operation(cm, function () {
                            if (counter == curCount)
                                extend(e);
                        }), 150);
                } else {
                    var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                    if (outside)
                        setTimeout(operation(cm, function () {
                            if (counter != curCount)
                                return;
                            display.scroller.scrollTop += outside;
                            extend(e);
                        }), 50);
                }
            }
            function done(e) {
                counter = Infinity;
                e_preventDefault(e);
                focusInput(cm);
                off(document, 'mousemove', move);
                off(document, 'mouseup', up);
            }
            var move = operation(cm, function (e) {
                    if (!ie && !e_button(e))
                        done(e);
                    else
                        extend(e);
                });
            var up = operation(cm, done);
            on(document, 'mousemove', move);
            on(document, 'mouseup', up);
        }
        function gutterEvent(cm, e, type, prevent, signalfn) {
            try {
                var mX = e.clientX, mY = e.clientY;
            } catch (e) {
                return false;
            }
            if (mX >= Math.floor(getRect(cm.display.gutters).right))
                return false;
            if (prevent)
                e_preventDefault(e);
            var display = cm.display;
            var lineBox = getRect(display.lineDiv);
            if (mY > lineBox.bottom || !hasHandler(cm, type))
                return e_defaultPrevented(e);
            mY -= lineBox.top - display.viewOffset;
            for (var i = 0; i < cm.options.gutters.length; ++i) {
                var g = display.gutters.childNodes[i];
                if (g && getRect(g).right >= mX) {
                    var line = lineAtHeight(cm.doc, mY);
                    var gutter = cm.options.gutters[i];
                    signalfn(cm, type, cm, line, gutter, e);
                    return e_defaultPrevented(e);
                }
            }
        }
        function contextMenuInGutter(cm, e) {
            if (!hasHandler(cm, 'gutterContextMenu'))
                return false;
            return gutterEvent(cm, e, 'gutterContextMenu', false, signal);
        }
        function clickInGutter(cm, e) {
            return gutterEvent(cm, e, 'gutterClick', true, signalLater);
        }
        // Kludge to work around strange IE behavior where it'll sometimes
        // re-fire a series of drag-related events right after the drop (#1551)
        var lastDrop = 0;
        function onDrop(e) {
            var cm = this;
            if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
                return;
            e_preventDefault(e);
            if (ie)
                lastDrop = +new Date();
            var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
            if (!pos || isReadOnly(cm))
                return;
            if (files && files.length && window.FileReader && window.File) {
                var n = files.length, text = Array(n), read = 0;
                var loadFile = function (file, i) {
                    var reader = new FileReader();
                    reader.onload = function () {
                        text[i] = reader.result;
                        if (++read == n) {
                            pos = clipPos(cm.doc, pos);
                            makeChange(cm.doc, {
                                from: pos,
                                to: pos,
                                text: splitLines(text.join('\n')),
                                origin: 'paste'
                            }, 'around');
                        }
                    };
                    reader.readAsText(file);
                };
                for (var i = 0; i < n; ++i)
                    loadFile(files[i], i);
            } else {
                // Don't do a replace if the drop happened inside of the selected text.
                if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
                    cm.state.draggingText(e);
                    // Ensure the editor is re-focused
                    setTimeout(bind(focusInput, cm), 20);
                    return;
                }
                try {
                    var text = e.dataTransfer.getData('Text');
                    if (text) {
                        var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
                        setSelection(cm.doc, pos, pos);
                        if (cm.state.draggingText)
                            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
                        cm.replaceSelection(text, null, 'paste');
                        focusInput(cm);
                        onFocus(cm);
                    }
                } catch (e) {
                }
            }
        }
        function onDragStart(cm, e) {
            if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
                e_stop(e);
                return;
            }
            if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
                return;
            var txt = cm.getSelection();
            e.dataTransfer.setData('Text', txt);
            // Use dummy image instead of default browsers image.
            // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
            if (e.dataTransfer.setDragImage && !safari) {
                var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
                img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
                if (opera) {
                    img.width = img.height = 1;
                    cm.display.wrapper.appendChild(img);
                    // Force a relayout, or Opera won't use our image for some obscure reason
                    img._top = img.offsetTop;
                }
                e.dataTransfer.setDragImage(img, 0, 0);
                if (opera)
                    img.parentNode.removeChild(img);
            }
        }
        function setScrollTop(cm, val) {
            if (Math.abs(cm.doc.scrollTop - val) < 2)
                return;
            cm.doc.scrollTop = val;
            if (!gecko)
                updateDisplay(cm, [], val);
            if (cm.display.scroller.scrollTop != val)
                cm.display.scroller.scrollTop = val;
            if (cm.display.scrollbarV.scrollTop != val)
                cm.display.scrollbarV.scrollTop = val;
            if (gecko)
                updateDisplay(cm, []);
            startWorker(cm, 100);
        }
        function setScrollLeft(cm, val, isScroller) {
            if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
                return;
            val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
            cm.doc.scrollLeft = val;
            alignHorizontally(cm);
            if (cm.display.scroller.scrollLeft != val)
                cm.display.scroller.scrollLeft = val;
            if (cm.display.scrollbarH.scrollLeft != val)
                cm.display.scrollbarH.scrollLeft = val;
        }
        // Since the delta values reported on mouse wheel events are
        // unstandardized between browsers and even browser versions, and
        // generally horribly unpredictable, this code starts by measuring
        // the scroll effect that the first few mouse wheel events have,
        // and, from that, detects the way it can convert deltas to pixel
        // offsets afterwards.
        //
        // The reason we want to know the amount a wheel event will scroll
        // is that it gives us a chance to update the display before the
        // actual scrolling happens, reducing flickering.
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        // Fill in a browser-detected starting value on browsers where we
        // know one. These don't have to be accurate -- the result of them
        // being wrong would just be a slight flicker on the first wheel
        // scroll (if it is large enough).
        if (ie)
            wheelPixelsPerUnit = -0.53;
        else if (gecko)
            wheelPixelsPerUnit = 15;
        else if (chrome)
            wheelPixelsPerUnit = -0.7;
        else if (safari)
            wheelPixelsPerUnit = -1 / 3;
        function onScrollWheel(cm, e) {
            var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
            if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
                dx = e.detail;
            if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
                dy = e.detail;
            else if (dy == null)
                dy = e.wheelDelta;
            var display = cm.display, scroll = display.scroller;
            // Quit if there's nothing to scroll here
            if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
                return;
            // Webkit browsers on OS X abort momentum scrolls when the target
            // of the scroll event is removed from the scrollable element.
            // This hack (see related code in patchDisplay) makes sure the
            // element is kept around.
            if (dy && mac && webkit) {
                for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
                    if (cur.lineObj) {
                        cm.display.currentWheelTarget = cur;
                        break;
                    }
                }
            }
            // On some browsers, horizontal scrolling will cause redraws to
            // happen before the gutter has been realigned, causing it to
            // wriggle around in a most unseemly way. When we have an
            // estimated pixels/delta value, we just handle horizontal
            // scrolling entirely here. It'll be slightly off from native, but
            // better than glitching out.
            if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
                if (dy)
                    setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
                setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
                e_preventDefault(e);
                display.wheelStartX = null;
                // Abort measurement, if in progress
                return;
            }
            if (dy && wheelPixelsPerUnit != null) {
                var pixels = dy * wheelPixelsPerUnit;
                var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                if (pixels < 0)
                    top = Math.max(0, top + pixels - 50);
                else
                    bot = Math.min(cm.doc.height, bot + pixels + 50);
                updateDisplay(cm, [], {
                    top: top,
                    bottom: bot
                });
            }
            if (wheelSamples < 20) {
                if (display.wheelStartX == null) {
                    display.wheelStartX = scroll.scrollLeft;
                    display.wheelStartY = scroll.scrollTop;
                    display.wheelDX = dx;
                    display.wheelDY = dy;
                    setTimeout(function () {
                        if (display.wheelStartX == null)
                            return;
                        var movedX = scroll.scrollLeft - display.wheelStartX;
                        var movedY = scroll.scrollTop - display.wheelStartY;
                        var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                        display.wheelStartX = display.wheelStartY = null;
                        if (!sample)
                            return;
                        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                        ++wheelSamples;
                    }, 200);
                } else {
                    display.wheelDX += dx;
                    display.wheelDY += dy;
                }
            }
        }
        function doHandleBinding(cm, bound, dropShift) {
            if (typeof bound == 'string') {
                bound = commands[bound];
                if (!bound)
                    return false;
            }
            // Ensure previous input has been read, so that the handler sees a
            // consistent view of the document
            if (cm.display.pollingFast && readInput(cm))
                cm.display.pollingFast = false;
            var doc = cm.doc, prevShift = doc.sel.shift, done = false;
            try {
                if (isReadOnly(cm))
                    cm.state.suppressEdits = true;
                if (dropShift)
                    doc.sel.shift = false;
                done = bound(cm) != Pass;
            } finally {
                doc.sel.shift = prevShift;
                cm.state.suppressEdits = false;
            }
            return done;
        }
        function allKeyMaps(cm) {
            var maps = cm.state.keyMaps.slice(0);
            if (cm.options.extraKeys)
                maps.push(cm.options.extraKeys);
            maps.push(cm.options.keyMap);
            return maps;
        }
        var maybeTransition;
        function handleKeyBinding(cm, e) {
            // Handle auto keymap transitions
            var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
            clearTimeout(maybeTransition);
            if (next && !isModifierKey(e))
                maybeTransition = setTimeout(function () {
                    if (getKeyMap(cm.options.keyMap) == startMap) {
                        cm.options.keyMap = next.call ? next.call(null, cm) : next;
                        keyMapChanged(cm);
                    }
                }, 50);
            var name = keyName(e, true), handled = false;
            if (!name)
                return false;
            var keymaps = allKeyMaps(cm);
            if (e.shiftKey) {
                // First try to resolve full name (including 'Shift-'). Failing
                // that, see if there is a cursor-motion command (starting with
                // 'go') bound to the keyname without 'Shift-'.
                handled = lookupKey('Shift-' + name, keymaps, function (b) {
                    return doHandleBinding(cm, b, true);
                }) || lookupKey(name, keymaps, function (b) {
                    if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
                        return doHandleBinding(cm, b);
                });
            } else {
                handled = lookupKey(name, keymaps, function (b) {
                    return doHandleBinding(cm, b);
                });
            }
            if (handled) {
                e_preventDefault(e);
                restartBlink(cm);
                if (ie_lt9) {
                    e.oldKeyCode = e.keyCode;
                    e.keyCode = 0;
                }
                signalLater(cm, 'keyHandled', cm, name, e);
            }
            return handled;
        }
        function handleCharBinding(cm, e, ch) {
            var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
                    return doHandleBinding(cm, b, true);
                });
            if (handled) {
                e_preventDefault(e);
                restartBlink(cm);
                signalLater(cm, 'keyHandled', cm, '\'' + ch + '\'', e);
            }
            return handled;
        }
        var lastStoppedKey = null;
        function onKeyDown(e) {
            var cm = this;
            if (!cm.state.focused)
                onFocus(cm);
            if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                return;
            if (ie && e.keyCode == 27)
                e.returnValue = false;
            var code = e.keyCode;
            // IE does strange things with escape.
            cm.doc.sel.shift = code == 16 || e.shiftKey;
            // First give onKeyEvent option a chance to handle this.
            var handled = handleKeyBinding(cm, e);
            if (opera) {
                lastStoppedKey = handled ? code : null;
                // Opera has no cut event... we try to at least catch the key combo
                if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
                    cm.replaceSelection('');
            }
        }
        function onKeyPress(e) {
            var cm = this;
            if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
                return;
            var keyCode = e.keyCode, charCode = e.charCode;
            if (opera && keyCode == lastStoppedKey) {
                lastStoppedKey = null;
                e_preventDefault(e);
                return;
            }
            if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
                return;
            var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
            if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
                setTimeout(operation(cm, function () {
                    indentLine(cm, cm.doc.sel.to.line, 'smart');
                }), 75);
            if (handleCharBinding(cm, e, ch))
                return;
            if (ie && !ie_lt9)
                cm.display.inputHasSelection = null;
            fastPoll(cm);
        }
        function onFocus(cm) {
            if (cm.options.readOnly == 'nocursor')
                return;
            if (!cm.state.focused) {
                signal(cm, 'focus', cm);
                cm.state.focused = true;
                if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
                    cm.display.wrapper.className += ' CodeMirror-focused';
                if (!cm.curOp) {
                    resetInput(cm, true);
                    if (webkit)
                        setTimeout(bind(resetInput, cm, true), 0);    // Issue #1730
                }
            }
            slowPoll(cm);
            restartBlink(cm);
        }
        function onBlur(cm) {
            if (cm.state.focused) {
                signal(cm, 'blur', cm);
                cm.state.focused = false;
                cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
            }
            clearInterval(cm.display.blinker);
            setTimeout(function () {
                if (!cm.state.focused)
                    cm.doc.sel.shift = false;
            }, 150);
        }
        var detectingSelectAll;
        function onContextMenu(cm, e) {
            if (signalDOMEvent(cm, e, 'contextmenu'))
                return;
            var display = cm.display, sel = cm.doc.sel;
            if (eventInWidget(display, e) || contextMenuInGutter(cm, e))
                return;
            var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
            if (!pos || opera)
                return;
            // Opera is difficult.
            // Reset the current text selection only if the click is done outside of the selection
            // and 'resetSelectionOnContextMenu' option is true.
            var reset = cm.options.resetSelectionOnContextMenu;
            if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))
                operation(cm, setSelection)(cm.doc, pos, pos);
            var oldCSS = display.input.style.cssText;
            display.inputDiv.style.position = 'absolute';
            display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
            focusInput(cm);
            resetInput(cm, true);
            // Adds "Select all" to context menu in FF
            if (posEq(sel.from, sel.to))
                display.input.value = display.prevInput = ' ';
            function prepareSelectAllHack() {
                if (display.input.selectionStart != null) {
                    var extval = display.input.value = '\u200b' + (posEq(sel.from, sel.to) ? '' : display.input.value);
                    display.prevInput = '\u200b';
                    display.input.selectionStart = 1;
                    display.input.selectionEnd = extval.length;
                }
            }
            function rehide() {
                display.inputDiv.style.position = 'relative';
                display.input.style.cssText = oldCSS;
                if (ie_lt9)
                    display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
                slowPoll(cm);
                // Try to detect the user choosing select-all
                if (display.input.selectionStart != null) {
                    if (!ie || ie_lt9)
                        prepareSelectAllHack();
                    clearTimeout(detectingSelectAll);
                    var i = 0, poll = function () {
                            if (display.prevInput == ' ' && display.input.selectionStart == 0)
                                operation(cm, commands.selectAll)(cm);
                            else if (i++ < 10)
                                detectingSelectAll = setTimeout(poll, 500);
                            else
                                resetInput(cm);
                        };
                    detectingSelectAll = setTimeout(poll, 200);
                }
            }
            if (ie && !ie_lt9)
                prepareSelectAllHack();
            if (captureMiddleClick) {
                e_stop(e);
                var mouseup = function () {
                    off(window, 'mouseup', mouseup);
                    setTimeout(rehide, 20);
                };
                on(window, 'mouseup', mouseup);
            } else {
                setTimeout(rehide, 50);
            }
        }
        // UPDATING
        var changeEnd = CodeMirror.changeEnd = function (change) {
                if (!change.text)
                    return change.to;
                return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
            };
        // Make sure a position will be valid after the given change.
        function clipPostChange(doc, change, pos) {
            if (!posLess(change.from, pos))
                return clipPos(doc, pos);
            var diff = change.text.length - 1 - (change.to.line - change.from.line);
            if (pos.line > change.to.line + diff) {
                var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
                if (preLine > lastLine)
                    return Pos(lastLine, getLine(doc, lastLine).text.length);
                return clipToLen(pos, getLine(doc, preLine).text.length);
            }
            if (pos.line == change.to.line + diff)
                return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
            var inside = pos.line - change.from.line;
            return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
        }
        // Hint can be null|"end"|"start"|"around"|{anchor,head}
        function computeSelAfterChange(doc, change, hint) {
            if (hint && typeof hint == 'object')
                // Assumed to be {anchor, head} object
                return {
                    anchor: clipPostChange(doc, change, hint.anchor),
                    head: clipPostChange(doc, change, hint.head)
                };
            if (hint == 'start')
                return {
                    anchor: change.from,
                    head: change.from
                };
            var end = changeEnd(change);
            if (hint == 'around')
                return {
                    anchor: change.from,
                    head: end
                };
            if (hint == 'end')
                return {
                    anchor: end,
                    head: end
                };
            // hint is null, leave the selection alone as much as possible
            var adjustPos = function (pos) {
                if (posLess(pos, change.from))
                    return pos;
                if (!posLess(change.to, pos))
                    return end;
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                if (pos.line == change.to.line)
                    ch += end.ch - change.to.ch;
                return Pos(line, ch);
            };
            return {
                anchor: adjustPos(doc.sel.anchor),
                head: adjustPos(doc.sel.head)
            };
        }
        function filterChange(doc, change, update) {
            var obj = {
                    canceled: false,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function () {
                        this.canceled = true;
                    }
                };
            if (update)
                obj.update = function (from, to, text, origin) {
                    if (from)
                        this.from = clipPos(doc, from);
                    if (to)
                        this.to = clipPos(doc, to);
                    if (text)
                        this.text = text;
                    if (origin !== undefined)
                        this.origin = origin;
                };
            signal(doc, 'beforeChange', doc, obj);
            if (doc.cm)
                signal(doc.cm, 'beforeChange', doc.cm, obj);
            if (obj.canceled)
                return null;
            return {
                from: obj.from,
                to: obj.to,
                text: obj.text,
                origin: obj.origin
            };
        }
        // Replace the range from from to to by the strings in replacement.
        // change is a {from, to, text [, origin]} object
        function makeChange(doc, change, selUpdate, ignoreReadOnly) {
            if (doc.cm) {
                if (!doc.cm.curOp)
                    return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
                if (doc.cm.state.suppressEdits)
                    return;
            }
            if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
                change = filterChange(doc, change, true);
                if (!change)
                    return;
            }
            // Possibly split or suppress the update based on the presence
            // of read-only spans in its range.
            var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
            if (split) {
                for (var i = split.length - 1; i >= 1; --i)
                    makeChangeNoReadonly(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: ['']
                    });
                if (split.length)
                    makeChangeNoReadonly(doc, {
                        from: split[0].from,
                        to: split[0].to,
                        text: change.text
                    }, selUpdate);
            } else {
                makeChangeNoReadonly(doc, change, selUpdate);
            }
        }
        function makeChangeNoReadonly(doc, change, selUpdate) {
            if (change.text.length == 1 && change.text[0] == '' && posEq(change.from, change.to))
                return;
            var selAfter = computeSelAfterChange(doc, change, selUpdate);
            addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
            makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
            var rebased = [];
            linkedDocs(doc, function (doc, sharedHist) {
                if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
            });
        }
        function makeChangeFromHistory(doc, type) {
            if (doc.cm && doc.cm.state.suppressEdits)
                return;
            var hist = doc.history;
            var event = (type == 'undo' ? hist.done : hist.undone).pop();
            if (!event)
                return;
            var anti = {
                    changes: [],
                    anchorBefore: event.anchorAfter,
                    headBefore: event.headAfter,
                    anchorAfter: event.anchorBefore,
                    headAfter: event.headBefore,
                    generation: hist.generation
                };
            (type == 'undo' ? hist.undone : hist.done).push(anti);
            hist.generation = event.generation || ++hist.maxGeneration;
            var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
            for (var i = event.changes.length - 1; i >= 0; --i) {
                var change = event.changes[i];
                change.origin = type;
                if (filter && !filterChange(doc, change, false)) {
                    (type == 'undo' ? hist.done : hist.undone).length = 0;
                    return;
                }
                anti.changes.push(historyChangeFromChange(doc, change));
                var after = i ? computeSelAfterChange(doc, change, null) : {
                        anchor: event.anchorBefore,
                        head: event.headBefore
                    };
                makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
                var rebased = [];
                linkedDocs(doc, function (doc, sharedHist) {
                    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                        rebaseHist(doc.history, change);
                        rebased.push(doc.history);
                    }
                    makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                });
            }
        }
        function shiftDoc(doc, distance) {
            function shiftPos(pos) {
                return Pos(pos.line + distance, pos.ch);
            }
            doc.first += distance;
            if (doc.cm)
                regChange(doc.cm, doc.first, doc.first, distance);
            doc.sel.head = shiftPos(doc.sel.head);
            doc.sel.anchor = shiftPos(doc.sel.anchor);
            doc.sel.from = shiftPos(doc.sel.from);
            doc.sel.to = shiftPos(doc.sel.to);
        }
        function makeChangeSingleDoc(doc, change, selAfter, spans) {
            if (doc.cm && !doc.cm.curOp)
                return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
            if (change.to.line < doc.first) {
                shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                return;
            }
            if (change.from.line > doc.lastLine())
                return;
            // Clip the change to the size of this doc
            if (change.from.line < doc.first) {
                var shift = change.text.length - 1 - (doc.first - change.from.line);
                shiftDoc(doc, shift);
                change = {
                    from: Pos(doc.first, 0),
                    to: Pos(change.to.line + shift, change.to.ch),
                    text: [lst(change.text)],
                    origin: change.origin
                };
            }
            var last = doc.lastLine();
            if (change.to.line > last) {
                change = {
                    from: change.from,
                    to: Pos(last, getLine(doc, last).text.length),
                    text: [change.text[0]],
                    origin: change.origin
                };
            }
            change.removed = getBetween(doc, change.from, change.to);
            if (!selAfter)
                selAfter = computeSelAfterChange(doc, change, null);
            if (doc.cm)
                makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
            else
                updateDoc(doc, change, spans, selAfter);
        }
        function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
            var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
            var recomputeMaxLength = false, checkWidthStart = from.line;
            if (!cm.options.lineWrapping) {
                checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
                doc.iter(checkWidthStart, to.line + 1, function (line) {
                    if (line == display.maxLine) {
                        recomputeMaxLength = true;
                        return true;
                    }
                });
            }
            if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
                cm.curOp.cursorActivity = true;
            updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
            if (!cm.options.lineWrapping) {
                doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
                    var len = lineLength(doc, line);
                    if (len > display.maxLineLength) {
                        display.maxLine = line;
                        display.maxLineLength = len;
                        display.maxLineChanged = true;
                        recomputeMaxLength = false;
                    }
                });
                if (recomputeMaxLength)
                    cm.curOp.updateMaxLine = true;
            }
            // Adjust frontier, schedule worker
            doc.frontier = Math.min(doc.frontier, from.line);
            startWorker(cm, 400);
            var lendiff = change.text.length - (to.line - from.line) - 1;
            // Remember that these lines changed, for updating the display
            regChange(cm, from.line, to.line + 1, lendiff);
            if (hasHandler(cm, 'change')) {
                var changeObj = {
                        from: from,
                        to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                if (cm.curOp.textChanged) {
                    for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
                    }
                    cur.next = changeObj;
                } else
                    cm.curOp.textChanged = changeObj;
            }
        }
        function replaceRange(doc, code, from, to, origin) {
            if (!to)
                to = from;
            if (posLess(to, from)) {
                var tmp = to;
                to = from;
                from = tmp;
            }
            if (typeof code == 'string')
                code = splitLines(code);
            makeChange(doc, {
                from: from,
                to: to,
                text: code,
                origin: origin
            }, null);
        }
        // POSITION OBJECT
        function Pos(line, ch) {
            if (!(this instanceof Pos))
                return new Pos(line, ch);
            this.line = line;
            this.ch = ch;
        }
        CodeMirror.Pos = Pos;
        function posEq(a, b) {
            return a.line == b.line && a.ch == b.ch;
        }
        function posLess(a, b) {
            return a.line < b.line || a.line == b.line && a.ch < b.ch;
        }
        function copyPos(x) {
            return Pos(x.line, x.ch);
        }
        // SELECTION
        function clipLine(doc, n) {
            return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
        }
        function clipPos(doc, pos) {
            if (pos.line < doc.first)
                return Pos(doc.first, 0);
            var last = doc.first + doc.size - 1;
            if (pos.line > last)
                return Pos(last, getLine(doc, last).text.length);
            return clipToLen(pos, getLine(doc, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
            var ch = pos.ch;
            if (ch == null || ch > linelen)
                return Pos(pos.line, linelen);
            else if (ch < 0)
                return Pos(pos.line, 0);
            else
                return pos;
        }
        function isLine(doc, l) {
            return l >= doc.first && l < doc.first + doc.size;
        }
        // If shift is held, this will move the selection anchor. Otherwise,
        // it'll set the whole selection.
        function extendSelection(doc, pos, other, bias) {
            if (doc.sel.shift || doc.sel.extend) {
                var anchor = doc.sel.anchor;
                if (other) {
                    var posBefore = posLess(pos, anchor);
                    if (posBefore != posLess(other, anchor)) {
                        anchor = pos;
                        pos = other;
                    } else if (posBefore != posLess(pos, other)) {
                        pos = other;
                    }
                }
                setSelection(doc, anchor, pos, bias);
            } else {
                setSelection(doc, pos, other || pos, bias);
            }
            if (doc.cm)
                doc.cm.curOp.userSelChange = true;
        }
        function filterSelectionChange(doc, anchor, head) {
            var obj = {
                    anchor: anchor,
                    head: head
                };
            signal(doc, 'beforeSelectionChange', doc, obj);
            if (doc.cm)
                signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
            obj.anchor = clipPos(doc, obj.anchor);
            obj.head = clipPos(doc, obj.head);
            return obj;
        }
        // Update the selection. Last two args are only used by
        // updateDoc, since they have to be expressed in the line
        // numbers before the update.
        function setSelection(doc, anchor, head, bias, checkAtomic) {
            if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
                var filtered = filterSelectionChange(doc, anchor, head);
                head = filtered.head;
                anchor = filtered.anchor;
            }
            var sel = doc.sel;
            sel.goalColumn = null;
            if (bias == null)
                bias = posLess(head, sel.head) ? -1 : 1;
            // Skip over atomic spans.
            if (checkAtomic || !posEq(anchor, sel.anchor))
                anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
            if (checkAtomic || !posEq(head, sel.head))
                head = skipAtomic(doc, head, bias, checkAtomic != 'push');
            if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
                return;
            sel.anchor = anchor;
            sel.head = head;
            var inv = posLess(head, anchor);
            sel.from = inv ? head : anchor;
            sel.to = inv ? anchor : head;
            if (doc.cm)
                doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
            signalLater(doc, 'cursorActivity', doc);
        }
        function reCheckSelection(cm) {
            setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
        }
        function skipAtomic(doc, pos, bias, mayClear) {
            var flipped = false, curPos = pos;
            var dir = bias || 1;
            doc.cantEdit = false;
            search:
                for (;;) {
                    var line = getLine(doc, curPos.line);
                    if (line.markedSpans) {
                        for (var i = 0; i < line.markedSpans.length; ++i) {
                            var sp = line.markedSpans[i], m = sp.marker;
                            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                                if (mayClear) {
                                    signal(m, 'beforeCursorEnter');
                                    if (m.explicitlyCleared) {
                                        if (!line.markedSpans)
                                            break;
                                        else {
                                            --i;
                                            continue;
                                        }
                                    }
                                }
                                if (!m.atomic)
                                    continue;
                                var newPos = m.find()[dir < 0 ? 'from' : 'to'];
                                if (posEq(newPos, curPos)) {
                                    newPos.ch += dir;
                                    if (newPos.ch < 0) {
                                        if (newPos.line > doc.first)
                                            newPos = clipPos(doc, Pos(newPos.line - 1));
                                        else
                                            newPos = null;
                                    } else if (newPos.ch > line.text.length) {
                                        if (newPos.line < doc.first + doc.size - 1)
                                            newPos = Pos(newPos.line + 1, 0);
                                        else
                                            newPos = null;
                                    }
                                    if (!newPos) {
                                        if (flipped) {
                                            // Driven in a corner -- no valid cursor position found at all
                                            // -- try again *with* clearing, if we didn't already
                                            if (!mayClear)
                                                return skipAtomic(doc, pos, bias, true);
                                            // Otherwise, turn off editing until further notice, and return the start of the doc
                                            doc.cantEdit = true;
                                            return Pos(doc.first, 0);
                                        }
                                        flipped = true;
                                        newPos = pos;
                                        dir = -dir;
                                    }
                                }
                                curPos = newPos;
                                continue search;
                            }
                        }
                    }
                    return curPos;
                }
        }
        // SCROLLING
        function scrollCursorIntoView(cm) {
            var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);
            if (!cm.state.focused)
                return;
            var display = cm.display, box = getRect(display.sizer), doScroll = null;
            if (coords.top + box.top < 0)
                doScroll = true;
            else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
                doScroll = false;
            if (doScroll != null && !phantom) {
                var hidden = display.cursor.style.display == 'none';
                if (hidden) {
                    display.cursor.style.display = '';
                    display.cursor.style.left = coords.left + 'px';
                    display.cursor.style.top = coords.top - display.viewOffset + 'px';
                }
                display.cursor.scrollIntoView(doScroll);
                if (hidden)
                    display.cursor.style.display = 'none';
            }
        }
        function scrollPosIntoView(cm, pos, margin) {
            if (margin == null)
                margin = 0;
            for (;;) {
                var changed = false, coords = cursorCoords(cm, pos);
                var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
                var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                if (scrollPos.scrollTop != null) {
                    setScrollTop(cm, scrollPos.scrollTop);
                    if (Math.abs(cm.doc.scrollTop - startTop) > 1)
                        changed = true;
                }
                if (scrollPos.scrollLeft != null) {
                    setScrollLeft(cm, scrollPos.scrollLeft);
                    if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
                        changed = true;
                }
                if (!changed)
                    return coords;
            }
        }
        function scrollIntoView(cm, x1, y1, x2, y2) {
            var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
            if (scrollPos.scrollTop != null)
                setScrollTop(cm, scrollPos.scrollTop);
            if (scrollPos.scrollLeft != null)
                setScrollLeft(cm, scrollPos.scrollLeft);
        }
        function calculateScrollPos(cm, x1, y1, x2, y2) {
            var display = cm.display, snapMargin = textHeight(cm.display);
            if (y1 < 0)
                y1 = 0;
            var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
            var docBottom = cm.doc.height + paddingVert(display);
            var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
            if (y1 < screentop) {
                result.scrollTop = atTop ? 0 : y1;
            } else if (y2 > screentop + screen) {
                var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
                if (newTop != screentop)
                    result.scrollTop = newTop;
            }
            var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
            x1 += display.gutters.offsetWidth;
            x2 += display.gutters.offsetWidth;
            var gutterw = display.gutters.offsetWidth;
            var atLeft = x1 < gutterw + 10;
            if (x1 < screenleft + gutterw || atLeft) {
                if (atLeft)
                    x1 = 0;
                result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
            } else if (x2 > screenw + screenleft - 3) {
                result.scrollLeft = x2 + 10 - screenw;
            }
            return result;
        }
        function updateScrollPos(cm, left, top) {
            cm.curOp.updateScrollPos = {
                scrollLeft: left == null ? cm.doc.scrollLeft : left,
                scrollTop: top == null ? cm.doc.scrollTop : top
            };
        }
        function addToScrollPos(cm, left, top) {
            var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
                    scrollLeft: cm.doc.scrollLeft,
                    scrollTop: cm.doc.scrollTop
                });
            var scroll = cm.display.scroller;
            pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
            pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
        }
        // API UTILITIES
        function indentLine(cm, n, how, aggressive) {
            var doc = cm.doc;
            if (how == null)
                how = 'add';
            if (how == 'smart') {
                if (!cm.doc.mode.indent)
                    how = 'prev';
                else
                    var state = getStateBefore(cm, n);
            }
            var tabSize = cm.options.tabSize;
            var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
            var curSpaceString = line.text.match(/^\s*/)[0], indentation;
            if (how == 'smart') {
                indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
                if (indentation == Pass) {
                    if (!aggressive)
                        return;
                    how = 'prev';
                }
            }
            if (how == 'prev') {
                if (n > doc.first)
                    indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
                else
                    indentation = 0;
            } else if (how == 'add') {
                indentation = curSpace + cm.options.indentUnit;
            } else if (how == 'subtract') {
                indentation = curSpace - cm.options.indentUnit;
            } else if (typeof how == 'number') {
                indentation = curSpace + how;
            }
            indentation = Math.max(0, indentation);
            var indentString = '', pos = 0;
            if (cm.options.indentWithTabs)
                for (var i = Math.floor(indentation / tabSize); i; --i) {
                    pos += tabSize;
                    indentString += '\t';
                }
            if (pos < indentation)
                indentString += spaceStr(indentation - pos);
            if (indentString != curSpaceString)
                replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
            line.stateAfter = null;
        }
        function changeLine(cm, handle, op) {
            var no = handle, line = handle, doc = cm.doc;
            if (typeof handle == 'number')
                line = getLine(doc, clipLine(doc, handle));
            else
                no = lineNo(handle);
            if (no == null)
                return null;
            if (op(line, no))
                regChange(cm, no, no + 1);
            else
                return null;
            return line;
        }
        function findPosH(doc, pos, dir, unit, visually) {
            var line = pos.line, ch = pos.ch, origDir = dir;
            var lineObj = getLine(doc, line);
            var possible = true;
            function findNextLine() {
                var l = line + dir;
                if (l < doc.first || l >= doc.first + doc.size)
                    return possible = false;
                line = l;
                return lineObj = getLine(doc, l);
            }
            function moveOnce(boundToLine) {
                var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
                if (next == null) {
                    if (!boundToLine && findNextLine()) {
                        if (visually)
                            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
                        else
                            ch = dir < 0 ? lineObj.text.length : 0;
                    } else
                        return possible = false;
                } else
                    ch = next;
                return true;
            }
            if (unit == 'char')
                moveOnce();
            else if (unit == 'column')
                moveOnce(true);
            else if (unit == 'word' || unit == 'group') {
                var sawType = null, group = unit == 'group';
                for (var first = true;; first = false) {
                    if (dir < 0 && !moveOnce(!first))
                        break;
                    var cur = lineObj.text.charAt(ch) || '\n';
                    var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
                    if (sawType && sawType != type) {
                        if (dir < 0) {
                            dir = 1;
                            moveOnce();
                        }
                        break;
                    }
                    if (type)
                        sawType = type;
                    if (dir > 0 && !moveOnce(!first))
                        break;
                }
            }
            var result = skipAtomic(doc, Pos(line, ch), origDir, true);
            if (!possible)
                result.hitSide = true;
            return result;
        }
        function findPosV(cm, pos, dir, unit) {
            var doc = cm.doc, x = pos.left, y;
            if (unit == 'page') {
                var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
                y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
            } else if (unit == 'line') {
                y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
            }
            for (;;) {
                var target = coordsChar(cm, x, y);
                if (!target.outside)
                    break;
                if (dir < 0 ? y <= 0 : y >= doc.height) {
                    target.hitSide = true;
                    break;
                }
                y += dir * 5;
            }
            return target;
        }
        function findWordAt(line, pos) {
            var start = pos.ch, end = pos.ch;
            if (line) {
                if ((pos.xRel < 0 || end == line.length) && start)
                    --start;
                else
                    ++end;
                var startChar = line.charAt(start);
                var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
                        return /\s/.test(ch);
                    } : function (ch) {
                        return !/\s/.test(ch) && !isWordChar(ch);
                    };
                while (start > 0 && check(line.charAt(start - 1)))
                    --start;
                while (end < line.length && check(line.charAt(end)))
                    ++end;
            }
            return {
                from: Pos(pos.line, start),
                to: Pos(pos.line, end)
            };
        }
        function selectLine(cm, line) {
            extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
        }
        // PROTOTYPE
        // The publicly visible API. Note that operation(null, f) means
        // 'wrap f in an operation, performed on its `this` parameter'
        CodeMirror.prototype = {
            constructor: CodeMirror,
            focus: function () {
                window.focus();
                focusInput(this);
                onFocus(this);
                fastPoll(this);
            },
            setOption: function (option, value) {
                var options = this.options, old = options[option];
                if (options[option] == value && option != 'mode')
                    return;
                options[option] = value;
                if (optionHandlers.hasOwnProperty(option))
                    operation(this, optionHandlers[option])(this, value, old);
            },
            getOption: function (option) {
                return this.options[option];
            },
            getDoc: function () {
                return this.doc;
            },
            addKeyMap: function (map, bottom) {
                this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
            },
            removeKeyMap: function (map) {
                var maps = this.state.keyMaps;
                for (var i = 0; i < maps.length; ++i)
                    if (maps[i] == map || typeof maps[i] != 'string' && maps[i].name == map) {
                        maps.splice(i, 1);
                        return true;
                    }
            },
            addOverlay: operation(null, function (spec, options) {
                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                if (mode.startState)
                    throw new Error('Overlays may not be stateful.');
                this.state.overlays.push({
                    mode: mode,
                    modeSpec: spec,
                    opaque: options && options.opaque
                });
                this.state.modeGen++;
                regChange(this);
            }),
            removeOverlay: operation(null, function (spec) {
                var overlays = this.state.overlays;
                for (var i = 0; i < overlays.length; ++i) {
                    var cur = overlays[i].modeSpec;
                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {
                        overlays.splice(i, 1);
                        this.state.modeGen++;
                        regChange(this);
                        return;
                    }
                }
            }),
            indentLine: operation(null, function (n, dir, aggressive) {
                if (typeof dir != 'string' && typeof dir != 'number') {
                    if (dir == null)
                        dir = this.options.smartIndent ? 'smart' : 'prev';
                    else
                        dir = dir ? 'add' : 'subtract';
                }
                if (isLine(this.doc, n))
                    indentLine(this, n, dir, aggressive);
            }),
            indentSelection: operation(null, function (how) {
                var sel = this.doc.sel;
                if (posEq(sel.from, sel.to))
                    return indentLine(this, sel.from.line, how);
                var e = sel.to.line - (sel.to.ch ? 0 : 1);
                for (var i = sel.from.line; i <= e; ++i)
                    indentLine(this, i, how);
            }),
            getTokenAt: function (pos, precise) {
                var doc = this.doc;
                pos = clipPos(doc, pos);
                var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
                var line = getLine(doc, pos.line);
                var stream = new StringStream(line.text, this.options.tabSize);
                while (stream.pos < pos.ch && !stream.eol()) {
                    stream.start = stream.pos;
                    var style = mode.token(stream, state);
                }
                return {
                    start: stream.start,
                    end: stream.pos,
                    string: stream.current(),
                    className: style || null,
                    type: style || null,
                    state: state
                };
            },
            getTokenTypeAt: function (pos) {
                pos = clipPos(this.doc, pos);
                var styles = getLineStyles(this, getLine(this.doc, pos.line));
                var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                if (ch == 0)
                    return styles[2];
                for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                        after = mid;
                    else if (styles[mid * 2 + 1] < ch)
                        before = mid + 1;
                    else
                        return styles[mid * 2 + 2];
                }
            },
            getModeAt: function (pos) {
                var mode = this.doc.mode;
                if (!mode.innerMode)
                    return mode;
                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function (pos, type) {
                if (!helpers.hasOwnProperty(type))
                    return;
                var help = helpers[type], mode = this.getModeAt(pos);
                return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name];
            },
            getStateAfter: function (line, precise) {
                var doc = this.doc;
                line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
                return getStateBefore(this, line + 1, precise);
            },
            cursorCoords: function (start, mode) {
                var pos, sel = this.doc.sel;
                if (start == null)
                    pos = sel.head;
                else if (typeof start == 'object')
                    pos = clipPos(this.doc, start);
                else
                    pos = start ? sel.from : sel.to;
                return cursorCoords(this, pos, mode || 'page');
            },
            charCoords: function (pos, mode) {
                return charCoords(this, clipPos(this.doc, pos), mode || 'page');
            },
            coordsChar: function (coords, mode) {
                coords = fromCoordSystem(this, coords, mode || 'page');
                return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function (height, mode) {
                height = fromCoordSystem(this, {
                    top: height,
                    left: 0
                }, mode || 'page').top;
                return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function (line, mode) {
                var end = false, last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first)
                    line = this.doc.first;
                else if (line > last) {
                    line = last;
                    end = true;
                }
                var lineObj = getLine(this.doc, line);
                return intoCoordSystem(this, getLine(this.doc, line), {
                    top: 0,
                    left: 0
                }, mode || 'page').top + (end ? lineObj.height : 0);
            },
            defaultTextHeight: function () {
                return textHeight(this.display);
            },
            defaultCharWidth: function () {
                return charWidth(this.display);
            },
            setGutterMarker: operation(null, function (line, gutterID, value) {
                return changeLine(this, line, function (line) {
                    var markers = line.gutterMarkers || (line.gutterMarkers = {});
                    markers[gutterID] = value;
                    if (!value && isEmpty(markers))
                        line.gutterMarkers = null;
                    return true;
                });
            }),
            clearGutter: operation(null, function (gutterID) {
                var cm = this, doc = cm.doc, i = doc.first;
                doc.iter(function (line) {
                    if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                        line.gutterMarkers[gutterID] = null;
                        regChange(cm, i, i + 1);
                        if (isEmpty(line.gutterMarkers))
                            line.gutterMarkers = null;
                    }
                    ++i;
                });
            }),
            addLineClass: operation(null, function (handle, where, cls) {
                return changeLine(this, handle, function (line) {
                    var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                    if (!line[prop])
                        line[prop] = cls;
                    else if (new RegExp('(?:^|\\s)' + cls + '(?:$|\\s)').test(line[prop]))
                        return false;
                    else
                        line[prop] += ' ' + cls;
                    return true;
                });
            }),
            removeLineClass: operation(null, function (handle, where, cls) {
                return changeLine(this, handle, function (line) {
                    var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                    var cur = line[prop];
                    if (!cur)
                        return false;
                    else if (cls == null)
                        line[prop] = null;
                    else {
                        var found = cur.match(new RegExp('(?:^|\\s+)' + cls + '(?:$|\\s+)'));
                        if (!found)
                            return false;
                        var end = found.index + found[0].length;
                        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
                    }
                    return true;
                });
            }),
            addLineWidget: operation(null, function (handle, node, options) {
                return addLineWidget(this, handle, node, options);
            }),
            removeLineWidget: function (widget) {
                widget.clear();
            },
            lineInfo: function (line) {
                if (typeof line == 'number') {
                    if (!isLine(this.doc, line))
                        return null;
                    var n = line;
                    line = getLine(this.doc, line);
                    if (!line)
                        return null;
                } else {
                    var n = lineNo(line);
                    if (n == null)
                        return null;
                }
                return {
                    line: n,
                    handle: line,
                    text: line.text,
                    gutterMarkers: line.gutterMarkers,
                    textClass: line.textClass,
                    bgClass: line.bgClass,
                    wrapClass: line.wrapClass,
                    widgets: line.widgets
                };
            },
            getViewport: function () {
                return {
                    from: this.display.showingFrom,
                    to: this.display.showingTo
                };
            },
            addWidget: function (pos, node, scroll, vert, horiz) {
                var display = this.display;
                pos = cursorCoords(this, clipPos(this.doc, pos));
                var top = pos.bottom, left = pos.left;
                node.style.position = 'absolute';
                display.sizer.appendChild(node);
                if (vert == 'over') {
                    top = pos.top;
                } else if (vert == 'above' || vert == 'near') {
                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                    // Default to positioning above (if specified and possible); otherwise default to positioning below
                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                        top = pos.top - node.offsetHeight;
                    else if (pos.bottom + node.offsetHeight <= vspace)
                        top = pos.bottom;
                    if (left + node.offsetWidth > hspace)
                        left = hspace - node.offsetWidth;
                }
                node.style.top = top + 'px';
                node.style.left = node.style.right = '';
                if (horiz == 'right') {
                    left = display.sizer.clientWidth - node.offsetWidth;
                    node.style.right = '0px';
                } else {
                    if (horiz == 'left')
                        left = 0;
                    else if (horiz == 'middle')
                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                    node.style.left = left + 'px';
                }
                if (scroll)
                    scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
            },
            triggerOnKeyDown: operation(null, onKeyDown),
            execCommand: function (cmd) {
                return commands[cmd](this);
            },
            findPosH: function (from, amount, unit, visually) {
                var dir = 1;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                    cur = findPosH(this.doc, cur, dir, unit, visually);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveH: operation(null, function (dir, unit) {
                var sel = this.doc.sel, pos;
                if (sel.shift || sel.extend || posEq(sel.from, sel.to))
                    pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
                else
                    pos = dir < 0 ? sel.from : sel.to;
                extendSelection(this.doc, pos, pos, dir);
            }),
            deleteH: operation(null, function (dir, unit) {
                var sel = this.doc.sel;
                if (!posEq(sel.from, sel.to))
                    replaceRange(this.doc, '', sel.from, sel.to, '+delete');
                else
                    replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
                this.curOp.userSelChange = true;
            }),
            findPosV: function (from, amount, unit, goalColumn) {
                var dir = 1, x = goalColumn;
                if (amount < 0) {
                    dir = -1;
                    amount = -amount;
                }
                for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                    var coords = cursorCoords(this, cur, 'div');
                    if (x == null)
                        x = coords.left;
                    else
                        coords.left = x;
                    cur = findPosV(this, coords, dir, unit);
                    if (cur.hitSide)
                        break;
                }
                return cur;
            },
            moveV: operation(null, function (dir, unit) {
                var sel = this.doc.sel;
                var pos = cursorCoords(this, sel.head, 'div');
                if (sel.goalColumn != null)
                    pos.left = sel.goalColumn;
                var target = findPosV(this, pos, dir, unit);
                if (unit == 'page')
                    addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
                extendSelection(this.doc, target, target, dir);
                sel.goalColumn = pos.left;
            }),
            toggleOverwrite: function (value) {
                if (value != null && value == this.state.overwrite)
                    return;
                if (this.state.overwrite = !this.state.overwrite)
                    this.display.cursor.className += ' CodeMirror-overwrite';
                else
                    this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
            },
            hasFocus: function () {
                return this.state.focused;
            },
            scrollTo: operation(null, function (x, y) {
                updateScrollPos(this, x, y);
            }),
            getScrollInfo: function () {
                var scroller = this.display.scroller, co = scrollerCutOff;
                return {
                    left: scroller.scrollLeft,
                    top: scroller.scrollTop,
                    height: scroller.scrollHeight - co,
                    width: scroller.scrollWidth - co,
                    clientHeight: scroller.clientHeight - co,
                    clientWidth: scroller.clientWidth - co
                };
            },
            scrollIntoView: operation(null, function (pos, margin) {
                if (typeof pos == 'number')
                    pos = Pos(pos, 0);
                if (!margin)
                    margin = 0;
                var coords = pos;
                if (!pos || pos.line != null) {
                    this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
                    this.curOp.scrollToPosMargin = margin;
                    coords = cursorCoords(this, this.curOp.scrollToPos);
                }
                var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
                updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
            }),
            setSize: operation(null, function (width, height) {
                function interpret(val) {
                    return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
                }
                if (width != null)
                    this.display.wrapper.style.width = interpret(width);
                if (height != null)
                    this.display.wrapper.style.height = interpret(height);
                if (this.options.lineWrapping)
                    this.display.measureLineCache.length = this.display.measureLineCachePos = 0;
                this.curOp.forceUpdate = true;
            }),
            operation: function (f) {
                return runInOp(this, f);
            },
            refresh: operation(null, function () {
                var badHeight = this.display.cachedTextHeight == null;
                clearCaches(this);
                updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
                regChange(this);
                if (badHeight)
                    estimateLineHeights(this);
            }),
            swapDoc: operation(null, function (doc) {
                var old = this.doc;
                old.cm = null;
                attachDoc(this, doc);
                clearCaches(this);
                resetInput(this, true);
                updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
                signalLater(this, 'swapDoc', this, old);
                return old;
            }),
            getInputField: function () {
                return this.display.input;
            },
            getWrapperElement: function () {
                return this.display.wrapper;
            },
            getScrollerElement: function () {
                return this.display.scroller;
            },
            getGutterElement: function () {
                return this.display.gutters;
            }
        };
        eventMixin(CodeMirror);
        // OPTION DEFAULTS
        var optionHandlers = CodeMirror.optionHandlers = {};
        // The default configuration options.
        var defaults = CodeMirror.defaults = {};
        function option(name, deflt, handle, notOnInit) {
            CodeMirror.defaults[name] = deflt;
            if (handle)
                optionHandlers[name] = notOnInit ? function (cm, val, old) {
                    if (old != Init)
                        handle(cm, val, old);
                } : handle;
        }
        var Init = CodeMirror.Init = {
                toString: function () {
                    return 'CodeMirror.Init';
                }
            };
        // These two are, on init, called from the constructor because they
        // have to be initialized before the editor can start at all.
        option('value', '', function (cm, val) {
            cm.setValue(val);
        }, true);
        option('mode', null, function (cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
        }, true);
        option('indentUnit', 2, loadMode, true);
        option('indentWithTabs', false);
        option('smartIndent', true);
        option('tabSize', 4, function (cm) {
            loadMode(cm);
            clearCaches(cm);
            regChange(cm);
        }, true);
        option('electricChars', true);
        option('rtlMoveVisually', !windows);
        option('theme', 'default', function (cm) {
            themeChanged(cm);
            guttersChanged(cm);
        }, true);
        option('keyMap', 'default', keyMapChanged);
        option('extraKeys', null);
        option('onKeyEvent', null);
        option('onDragEvent', null);
        option('lineWrapping', false, wrappingChanged, true);
        option('gutters', [], function (cm) {
            setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('fixedGutter', true, function (cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
            cm.refresh();
        }, true);
        option('coverGutterNextToScrollbar', false, updateScrollbars, true);
        option('lineNumbers', false, function (cm) {
            setGuttersForLineNumbers(cm.options);
            guttersChanged(cm);
        }, true);
        option('firstLineNumber', 1, guttersChanged, true);
        option('lineNumberFormatter', function (integer) {
            return integer;
        }, guttersChanged, true);
        option('showCursorWhenSelecting', false, updateSelection, true);
        option('resetSelectionOnContextMenu', true);
        option('readOnly', false, function (cm, val) {
            if (val == 'nocursor') {
                onBlur(cm);
                cm.display.input.blur();
            } else if (!val)
                resetInput(cm, true);
        });
        option('dragDrop', true);
        option('cursorBlinkRate', 530);
        option('cursorScrollMargin', 0);
        option('cursorHeight', 1);
        option('workTime', 100);
        option('workDelay', 100);
        option('flattenSpans', true);
        option('pollInterval', 100);
        option('undoDepth', 40, function (cm, val) {
            cm.doc.history.undoDepth = val;
        });
        option('historyEventDelay', 500);
        option('viewportMargin', 10, function (cm) {
            cm.refresh();
        }, true);
        option('maxHighlightLength', 10000, function (cm) {
            loadMode(cm);
            cm.refresh();
        }, true);
        option('crudeMeasuringFrom', 10000);
        option('moveInputWithCursor', true, function (cm, val) {
            if (!val)
                cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
        });
        option('tabindex', null, function (cm, val) {
            cm.display.input.tabIndex = val || '';
        });
        option('autofocus', null);
        // MODE DEFINITION AND QUERYING
        // Known modes, by name and by MIME
        var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
        CodeMirror.defineMode = function (name, mode) {
            if (!CodeMirror.defaults.mode && name != 'null')
                CodeMirror.defaults.mode = name;
            if (arguments.length > 2) {
                mode.dependencies = [];
                for (var i = 2; i < arguments.length; ++i)
                    mode.dependencies.push(arguments[i]);
            }
            modes[name] = mode;
        };
        CodeMirror.defineMIME = function (mime, spec) {
            mimeModes[mime] = spec;
        };
        CodeMirror.resolveMode = function (spec) {
            if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
                spec = mimeModes[spec];
            } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
                var found = mimeModes[spec.name];
                spec = createObj(found, spec);
                spec.name = found.name;
            } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
                return CodeMirror.resolveMode('application/xml');
            }
            if (typeof spec == 'string')
                return { name: spec };
            else
                return spec || { name: 'null' };
        };
        CodeMirror.getMode = function (options, spec) {
            var spec = CodeMirror.resolveMode(spec);
            var mfactory = modes[spec.name];
            if (!mfactory)
                return CodeMirror.getMode(options, 'text/plain');
            var modeObj = mfactory(options, spec);
            if (modeExtensions.hasOwnProperty(spec.name)) {
                var exts = modeExtensions[spec.name];
                for (var prop in exts) {
                    if (!exts.hasOwnProperty(prop))
                        continue;
                    if (modeObj.hasOwnProperty(prop))
                        modeObj['_' + prop] = modeObj[prop];
                    modeObj[prop] = exts[prop];
                }
            }
            modeObj.name = spec.name;
            return modeObj;
        };
        CodeMirror.defineMode('null', function () {
            return {
                token: function (stream) {
                    stream.skipToEnd();
                }
            };
        });
        CodeMirror.defineMIME('text/plain', 'null');
        var modeExtensions = CodeMirror.modeExtensions = {};
        CodeMirror.extendMode = function (mode, properties) {
            var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
            copyObj(properties, exts);
        };
        // EXTENSIONS
        CodeMirror.defineExtension = function (name, func) {
            CodeMirror.prototype[name] = func;
        };
        CodeMirror.defineDocExtension = function (name, func) {
            Doc.prototype[name] = func;
        };
        CodeMirror.defineOption = option;
        var initHooks = [];
        CodeMirror.defineInitHook = function (f) {
            initHooks.push(f);
        };
        var helpers = CodeMirror.helpers = {};
        CodeMirror.registerHelper = function (type, name, value) {
            if (!helpers.hasOwnProperty(type))
                helpers[type] = CodeMirror[type] = {};
            helpers[type][name] = value;
        };
        // UTILITIES
        CodeMirror.isWordChar = isWordChar;
        // MODE STATE HANDLING
        // Utility functions for working with state. Exported because modes
        // sometimes need to do this.
        function copyState(mode, state) {
            if (state === true)
                return state;
            if (mode.copyState)
                return mode.copyState(state);
            var nstate = {};
            for (var n in state) {
                var val = state[n];
                if (val instanceof Array)
                    val = val.concat([]);
                nstate[n] = val;
            }
            return nstate;
        }
        CodeMirror.copyState = copyState;
        function startState(mode, a1, a2) {
            return mode.startState ? mode.startState(a1, a2) : true;
        }
        CodeMirror.startState = startState;
        CodeMirror.innerMode = function (mode, state) {
            while (mode.innerMode) {
                var info = mode.innerMode(state);
                if (!info || info.mode == mode)
                    break;
                state = info.state;
                mode = info.mode;
            }
            return info || {
                mode: mode,
                state: state
            };
        };
        // STANDARD COMMANDS
        var commands = CodeMirror.commands = {
                selectAll: function (cm) {
                    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
                },
                killLine: function (cm) {
                    var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
                    if (!sel && cm.getLine(from.line).length == from.ch)
                        cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
                    else
                        cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
                },
                deleteLine: function (cm) {
                    var l = cm.getCursor().line;
                    cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
                },
                delLineLeft: function (cm) {
                    var cur = cm.getCursor();
                    cm.replaceRange('', Pos(cur.line, 0), cur, '+delete');
                },
                undo: function (cm) {
                    cm.undo();
                },
                redo: function (cm) {
                    cm.redo();
                },
                goDocStart: function (cm) {
                    cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function (cm) {
                    cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function (cm) {
                    cm.extendSelection(lineStart(cm, cm.getCursor().line));
                },
                goLineStartSmart: function (cm) {
                    var cur = cm.getCursor(), start = lineStart(cm, cur.line);
                    var line = cm.getLineHandle(start.line);
                    var order = getOrder(line);
                    if (!order || order[0].level == 0) {
                        var firstNonWS = Math.max(0, line.text.search(/\S/));
                        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
                        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
                    } else
                        cm.extendSelection(start);
                },
                goLineEnd: function (cm) {
                    cm.extendSelection(lineEnd(cm, cm.getCursor().line));
                },
                goLineRight: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
                    cm.extendSelection(cm.coordsChar({
                        left: cm.display.lineDiv.offsetWidth + 100,
                        top: top
                    }, 'div'));
                },
                goLineLeft: function (cm) {
                    var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
                    cm.extendSelection(cm.coordsChar({
                        left: 0,
                        top: top
                    }, 'div'));
                },
                goLineUp: function (cm) {
                    cm.moveV(-1, 'line');
                },
                goLineDown: function (cm) {
                    cm.moveV(1, 'line');
                },
                goPageUp: function (cm) {
                    cm.moveV(-1, 'page');
                },
                goPageDown: function (cm) {
                    cm.moveV(1, 'page');
                },
                goCharLeft: function (cm) {
                    cm.moveH(-1, 'char');
                },
                goCharRight: function (cm) {
                    cm.moveH(1, 'char');
                },
                goColumnLeft: function (cm) {
                    cm.moveH(-1, 'column');
                },
                goColumnRight: function (cm) {
                    cm.moveH(1, 'column');
                },
                goWordLeft: function (cm) {
                    cm.moveH(-1, 'word');
                },
                goGroupRight: function (cm) {
                    cm.moveH(1, 'group');
                },
                goGroupLeft: function (cm) {
                    cm.moveH(-1, 'group');
                },
                goWordRight: function (cm) {
                    cm.moveH(1, 'word');
                },
                delCharBefore: function (cm) {
                    cm.deleteH(-1, 'char');
                },
                delCharAfter: function (cm) {
                    cm.deleteH(1, 'char');
                },
                delWordBefore: function (cm) {
                    cm.deleteH(-1, 'word');
                },
                delWordAfter: function (cm) {
                    cm.deleteH(1, 'word');
                },
                delGroupBefore: function (cm) {
                    cm.deleteH(-1, 'group');
                },
                delGroupAfter: function (cm) {
                    cm.deleteH(1, 'group');
                },
                indentAuto: function (cm) {
                    cm.indentSelection('smart');
                },
                indentMore: function (cm) {
                    cm.indentSelection('add');
                },
                indentLess: function (cm) {
                    cm.indentSelection('subtract');
                },
                insertTab: function (cm) {
                    cm.replaceSelection('\t', 'end', '+input');
                },
                defaultTab: function (cm) {
                    if (cm.somethingSelected())
                        cm.indentSelection('add');
                    else
                        cm.replaceSelection('\t', 'end', '+input');
                },
                transposeChars: function (cm) {
                    var cur = cm.getCursor(), line = cm.getLine(cur.line);
                    if (cur.ch > 0 && cur.ch < line.length - 1)
                        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
                },
                newlineAndIndent: function (cm) {
                    operation(cm, function () {
                        cm.replaceSelection('\n', 'end', '+input');
                        cm.indentLine(cm.getCursor().line, null, true);
                    })();
                },
                toggleOverwrite: function (cm) {
                    cm.toggleOverwrite();
                }
            };
        // STANDARD KEYMAPS
        var keyMap = CodeMirror.keyMap = {};
        keyMap.basic = {
            'Left': 'goCharLeft',
            'Right': 'goCharRight',
            'Up': 'goLineUp',
            'Down': 'goLineDown',
            'End': 'goLineEnd',
            'Home': 'goLineStartSmart',
            'PageUp': 'goPageUp',
            'PageDown': 'goPageDown',
            'Delete': 'delCharAfter',
            'Backspace': 'delCharBefore',
            'Shift-Backspace': 'delCharBefore',
            'Tab': 'defaultTab',
            'Shift-Tab': 'indentAuto',
            'Enter': 'newlineAndIndent',
            'Insert': 'toggleOverwrite'
        };
        // Note that the save and find-related commands aren't defined by
        // default. Unknown commands are simply ignored.
        keyMap.pcDefault = {
            'Ctrl-A': 'selectAll',
            'Ctrl-D': 'deleteLine',
            'Ctrl-Z': 'undo',
            'Shift-Ctrl-Z': 'redo',
            'Ctrl-Y': 'redo',
            'Ctrl-Home': 'goDocStart',
            'Alt-Up': 'goDocStart',
            'Ctrl-End': 'goDocEnd',
            'Ctrl-Down': 'goDocEnd',
            'Ctrl-Left': 'goGroupLeft',
            'Ctrl-Right': 'goGroupRight',
            'Alt-Left': 'goLineStart',
            'Alt-Right': 'goLineEnd',
            'Ctrl-Backspace': 'delGroupBefore',
            'Ctrl-Delete': 'delGroupAfter',
            'Ctrl-S': 'save',
            'Ctrl-F': 'find',
            'Ctrl-G': 'findNext',
            'Shift-Ctrl-G': 'findPrev',
            'Shift-Ctrl-F': 'replace',
            'Shift-Ctrl-R': 'replaceAll',
            'Ctrl-[': 'indentLess',
            'Ctrl-]': 'indentMore',
            fallthrough: 'basic'
        };
        keyMap.macDefault = {
            'Cmd-A': 'selectAll',
            'Cmd-D': 'deleteLine',
            'Cmd-Z': 'undo',
            'Shift-Cmd-Z': 'redo',
            'Cmd-Y': 'redo',
            'Cmd-Up': 'goDocStart',
            'Cmd-End': 'goDocEnd',
            'Cmd-Down': 'goDocEnd',
            'Alt-Left': 'goGroupLeft',
            'Alt-Right': 'goGroupRight',
            'Cmd-Left': 'goLineStart',
            'Cmd-Right': 'goLineEnd',
            'Alt-Backspace': 'delGroupBefore',
            'Ctrl-Alt-Backspace': 'delGroupAfter',
            'Alt-Delete': 'delGroupAfter',
            'Cmd-S': 'save',
            'Cmd-F': 'find',
            'Cmd-G': 'findNext',
            'Shift-Cmd-G': 'findPrev',
            'Cmd-Alt-F': 'replace',
            'Shift-Cmd-Alt-F': 'replaceAll',
            'Cmd-[': 'indentLess',
            'Cmd-]': 'indentMore',
            'Cmd-Backspace': 'delLineLeft',
            fallthrough: [
                'basic',
                'emacsy'
            ]
        };
        keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
        keyMap.emacsy = {
            'Ctrl-F': 'goCharRight',
            'Ctrl-B': 'goCharLeft',
            'Ctrl-P': 'goLineUp',
            'Ctrl-N': 'goLineDown',
            'Alt-F': 'goWordRight',
            'Alt-B': 'goWordLeft',
            'Ctrl-A': 'goLineStart',
            'Ctrl-E': 'goLineEnd',
            'Ctrl-V': 'goPageDown',
            'Shift-Ctrl-V': 'goPageUp',
            'Ctrl-D': 'delCharAfter',
            'Ctrl-H': 'delCharBefore',
            'Alt-D': 'delWordAfter',
            'Alt-Backspace': 'delWordBefore',
            'Ctrl-K': 'killLine',
            'Ctrl-T': 'transposeChars'
        };
        // KEYMAP DISPATCH
        function getKeyMap(val) {
            if (typeof val == 'string')
                return keyMap[val];
            else
                return val;
        }
        function lookupKey(name, maps, handle) {
            function lookup(map) {
                map = getKeyMap(map);
                var found = map[name];
                if (found === false)
                    return 'stop';
                if (found != null && handle(found))
                    return true;
                if (map.nofallthrough)
                    return 'stop';
                var fallthrough = map.fallthrough;
                if (fallthrough == null)
                    return false;
                if (Object.prototype.toString.call(fallthrough) != '[object Array]')
                    return lookup(fallthrough);
                for (var i = 0, e = fallthrough.length; i < e; ++i) {
                    var done = lookup(fallthrough[i]);
                    if (done)
                        return done;
                }
                return false;
            }
            for (var i = 0; i < maps.length; ++i) {
                var done = lookup(maps[i]);
                if (done)
                    return done != 'stop';
            }
        }
        function isModifierKey(event) {
            var name = keyNames[event.keyCode];
            return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
        }
        function keyName(event, noShift) {
            if (opera && event.keyCode == 34 && event['char'])
                return false;
            var name = keyNames[event.keyCode];
            if (name == null || event.altGraphKey)
                return false;
            if (event.altKey)
                name = 'Alt-' + name;
            if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
                name = 'Ctrl-' + name;
            if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
                name = 'Cmd-' + name;
            if (!noShift && event.shiftKey)
                name = 'Shift-' + name;
            return name;
        }
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.keyName = keyName;
        // FROMTEXTAREA
        CodeMirror.fromTextArea = function (textarea, options) {
            if (!options)
                options = {};
            options.value = textarea.value;
            if (!options.tabindex && textarea.tabindex)
                options.tabindex = textarea.tabindex;
            if (!options.placeholder && textarea.placeholder)
                options.placeholder = textarea.placeholder;
            // Set autofocus to true if this textarea is focused, or if it has
            // autofocus and no other element is focused.
            if (options.autofocus == null) {
                var hasFocus = document.body;
                // doc.activeElement occasionally throws on IE
                try {
                    hasFocus = document.activeElement;
                } catch (e) {
                }
                options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
            }
            function save() {
                textarea.value = cm.getValue();
            }
            if (textarea.form) {
                on(textarea.form, 'submit', save);
                // Deplorable hack to make the submit method do the right thing.
                if (!options.leaveSubmitMethodAlone) {
                    var form = textarea.form, realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function () {
                                save();
                                form.submit = realSubmit;
                                form.submit();
                                form.submit = wrappedSubmit;
                            };
                    } catch (e) {
                    }
                }
            }
            textarea.style.display = 'none';
            var cm = CodeMirror(function (node) {
                    textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
            cm.save = save;
            cm.getTextArea = function () {
                return textarea;
            };
            cm.toTextArea = function () {
                save();
                textarea.parentNode.removeChild(cm.getWrapperElement());
                textarea.style.display = '';
                if (textarea.form) {
                    off(textarea.form, 'submit', save);
                    if (typeof textarea.form.submit == 'function')
                        textarea.form.submit = realSubmit;
                }
            };
            return cm;
        };
        // STRING STREAM
        // Fed to the mode parsers, provides helper functions to make
        // parsers more succinct.
        // The character stream used by a mode's parser.
        function StringStream(string, tabSize) {
            this.pos = this.start = 0;
            this.string = string;
            this.tabSize = tabSize || 8;
            this.lastColumnPos = this.lastColumnValue = 0;
        }
        StringStream.prototype = {
            eol: function () {
                return this.pos >= this.string.length;
            },
            sol: function () {
                return this.pos == 0;
            },
            peek: function () {
                return this.string.charAt(this.pos) || undefined;
            },
            next: function () {
                if (this.pos < this.string.length)
                    return this.string.charAt(this.pos++);
            },
            eat: function (match) {
                var ch = this.string.charAt(this.pos);
                if (typeof match == 'string')
                    var ok = ch == match;
                else
                    var ok = ch && (match.test ? match.test(ch) : match(ch));
                if (ok) {
                    ++this.pos;
                    return ch;
                }
            },
            eatWhile: function (match) {
                var start = this.pos;
                while (this.eat(match)) {
                }
                return this.pos > start;
            },
            eatSpace: function () {
                var start = this.pos;
                while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                    ++this.pos;
                return this.pos > start;
            },
            skipToEnd: function () {
                this.pos = this.string.length;
            },
            skipTo: function (ch) {
                var found = this.string.indexOf(ch, this.pos);
                if (found > -1) {
                    this.pos = found;
                    return true;
                }
            },
            backUp: function (n) {
                this.pos -= n;
            },
            column: function () {
                if (this.lastColumnPos < this.start) {
                    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                    this.lastColumnPos = this.start;
                }
                return this.lastColumnValue;
            },
            indentation: function () {
                return countColumn(this.string, null, this.tabSize);
            },
            match: function (pattern, consume, caseInsensitive) {
                if (typeof pattern == 'string') {
                    var cased = function (str) {
                        return caseInsensitive ? str.toLowerCase() : str;
                    };
                    var substr = this.string.substr(this.pos, pattern.length);
                    if (cased(substr) == cased(pattern)) {
                        if (consume !== false)
                            this.pos += pattern.length;
                        return true;
                    }
                } else {
                    var match = this.string.slice(this.pos).match(pattern);
                    if (match && match.index > 0)
                        return null;
                    if (match && consume !== false)
                        this.pos += match[0].length;
                    return match;
                }
            },
            current: function () {
                return this.string.slice(this.start, this.pos);
            }
        };
        CodeMirror.StringStream = StringStream;
        // TEXTMARKERS
        function TextMarker(doc, type) {
            this.lines = [];
            this.type = type;
            this.doc = doc;
        }
        CodeMirror.TextMarker = TextMarker;
        eventMixin(TextMarker);
        TextMarker.prototype.clear = function () {
            if (this.explicitlyCleared)
                return;
            var cm = this.doc.cm, withOp = cm && !cm.curOp;
            if (withOp)
                startOperation(cm);
            if (hasHandler(this, 'clear')) {
                var found = this.find();
                if (found)
                    signalLater(this, 'clear', found.from, found.to);
            }
            var min = null, max = null;
            for (var i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i];
                var span = getMarkedSpanFor(line.markedSpans, this);
                if (span.to != null)
                    max = lineNo(line);
                line.markedSpans = removeMarkedSpan(line.markedSpans, span);
                if (span.from != null)
                    min = lineNo(line);
                else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
                    updateLineHeight(line, textHeight(cm.display));
            }
            if (cm && this.collapsed && !cm.options.lineWrapping)
                for (var i = 0; i < this.lines.length; ++i) {
                    var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
                    if (len > cm.display.maxLineLength) {
                        cm.display.maxLine = visual;
                        cm.display.maxLineLength = len;
                        cm.display.maxLineChanged = true;
                    }
                }
            if (min != null && cm)
                regChange(cm, min, max + 1);
            this.lines.length = 0;
            this.explicitlyCleared = true;
            if (this.atomic && this.doc.cantEdit) {
                this.doc.cantEdit = false;
                if (cm)
                    reCheckSelection(cm);
            }
            if (withOp)
                endOperation(cm);
        };
        TextMarker.prototype.find = function () {
            var from, to;
            for (var i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i];
                var span = getMarkedSpanFor(line.markedSpans, this);
                if (span.from != null || span.to != null) {
                    var found = lineNo(line);
                    if (span.from != null)
                        from = Pos(found, span.from);
                    if (span.to != null)
                        to = Pos(found, span.to);
                }
            }
            if (this.type == 'bookmark')
                return from;
            return from && {
                from: from,
                to: to
            };
        };
        TextMarker.prototype.changed = function () {
            var pos = this.find(), cm = this.doc.cm;
            if (!pos || !cm)
                return;
            if (this.type != 'bookmark')
                pos = pos.from;
            var line = getLine(this.doc, pos.line);
            clearCachedMeasurement(cm, line);
            if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {
                for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling)
                    if (node.lineObj == line) {
                        if (node.offsetHeight != line.height)
                            updateLineHeight(line, node.offsetHeight);
                        break;
                    }
                runInOp(cm, function () {
                    cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;
                });
            }
        };
        TextMarker.prototype.attachLine = function (line) {
            if (!this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
                    (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
            this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function (line) {
            this.lines.splice(indexOf(this.lines, line), 1);
            if (!this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
            }
        };
        function markText(doc, from, to, options, type) {
            if (options && options.shared)
                return markTextShared(doc, from, to, options, type);
            if (doc.cm && !doc.cm.curOp)
                return operation(doc.cm, markText)(doc, from, to, options, type);
            var marker = new TextMarker(doc, type);
            if (type == 'range' && !posLess(from, to))
                return marker;
            if (options)
                copyObj(options, marker);
            if (marker.replacedWith) {
                marker.collapsed = true;
                marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
                if (!options.handleMouseEvents)
                    marker.replacedWith.ignoreEvents = true;
            }
            if (marker.collapsed)
                sawCollapsedSpans = true;
            if (marker.addToHistory)
                addToHistory(doc, {
                    from: from,
                    to: to,
                    origin: 'markText'
                }, {
                    head: doc.sel.head,
                    anchor: doc.sel.anchor
                }, NaN);
            var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
            doc.iter(curLine, to.line + 1, function (line) {
                if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
                    updateMaxLine = true;
                var span = {
                        from: null,
                        to: null,
                        marker: marker
                    };
                size += line.text.length;
                if (curLine == from.line) {
                    span.from = from.ch;
                    size -= from.ch;
                }
                if (curLine == to.line) {
                    span.to = to.ch;
                    size -= line.text.length - to.ch;
                }
                if (marker.collapsed) {
                    if (curLine == to.line)
                        collapsedAtEnd = collapsedSpanAt(line, to.ch);
                    if (curLine == from.line)
                        collapsedAtStart = collapsedSpanAt(line, from.ch);
                    else
                        updateLineHeight(line, 0);
                }
                addMarkedSpan(line, span);
                ++curLine;
            });
            if (marker.collapsed)
                doc.iter(from.line, to.line + 1, function (line) {
                    if (lineIsHidden(doc, line))
                        updateLineHeight(line, 0);
                });
            if (marker.clearOnEnter)
                on(marker, 'beforeCursorEnter', function () {
                    marker.clear();
                });
            if (marker.readOnly) {
                sawReadOnlySpans = true;
                if (doc.history.done.length || doc.history.undone.length)
                    doc.clearHistory();
            }
            if (marker.collapsed) {
                if (collapsedAtStart != collapsedAtEnd)
                    throw new Error('Inserting collapsed marker overlapping an existing one');
                marker.size = size;
                marker.atomic = true;
            }
            if (cm) {
                if (updateMaxLine)
                    cm.curOp.updateMaxLine = true;
                if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)
                    regChange(cm, from.line, to.line + 1);
                if (marker.atomic)
                    reCheckSelection(cm);
            }
            return marker;
        }
        // SHARED TEXTMARKERS
        function SharedTextMarker(markers, primary) {
            this.markers = markers;
            this.primary = primary;
            for (var i = 0, me = this; i < markers.length; ++i) {
                markers[i].parent = this;
                on(markers[i], 'clear', function () {
                    me.clear();
                });
            }
        }
        CodeMirror.SharedTextMarker = SharedTextMarker;
        eventMixin(SharedTextMarker);
        SharedTextMarker.prototype.clear = function () {
            if (this.explicitlyCleared)
                return;
            this.explicitlyCleared = true;
            for (var i = 0; i < this.markers.length; ++i)
                this.markers[i].clear();
            signalLater(this, 'clear');
        };
        SharedTextMarker.prototype.find = function () {
            return this.primary.find();
        };
        function markTextShared(doc, from, to, options, type) {
            options = copyObj(options);
            options.shared = false;
            var markers = [markText(doc, from, to, options, type)], primary = markers[0];
            var widget = options.replacedWith;
            linkedDocs(doc, function (doc) {
                if (widget)
                    options.replacedWith = widget.cloneNode(true);
                markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                for (var i = 0; i < doc.linked.length; ++i)
                    if (doc.linked[i].isParent)
                        return;
                primary = lst(markers);
            });
            return new SharedTextMarker(markers, primary);
        }
        // TEXTMARKER SPANS
        function getMarkedSpanFor(spans, marker) {
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker)
                        return span;
                }
        }
        function removeMarkedSpan(spans, span) {
            for (var r, i = 0; i < spans.length; ++i)
                if (spans[i] != span)
                    (r || (r = [])).push(spans[i]);
            return r;
        }
        function addMarkedSpan(line, span) {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
            span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
            if (old)
                for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push({
                            from: span.from,
                            to: endsAfter ? null : span.to,
                            marker: marker
                        });
                    }
                }
            return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
            if (old)
                for (var i = 0, nw; i < old.length; ++i) {
                    var span = old[i], marker = span.marker;
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push({
                            from: startsBefore ? null : span.from - endCh,
                            to: span.to == null ? null : span.to - endCh,
                            marker: marker
                        });
                    }
                }
            return nw;
        }
        function stretchSpansOverChange(doc, change) {
            var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
            var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
            if (!oldFirst && !oldLast)
                return null;
            var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
            // Get the spans that 'stick out' on both sides
            var first = markedSpansBefore(oldFirst, startCh, isInsert);
            var last = markedSpansAfter(oldLast, endCh, isInsert);
            // Next, merge those two ends
            var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
            if (first) {
                // Fix up .to properties of first
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (span.to == null) {
                        var found = getMarkedSpanFor(last, span.marker);
                        if (!found)
                            span.to = startCh;
                        else if (sameLine)
                            span.to = found.to == null ? null : found.to + offset;
                    }
                }
            }
            if (last) {
                // Fix up .from in last (or move them into first in case of sameLine)
                for (var i = 0; i < last.length; ++i) {
                    var span = last[i];
                    if (span.to != null)
                        span.to += offset;
                    if (span.from == null) {
                        var found = getMarkedSpanFor(first, span.marker);
                        if (!found) {
                            span.from = offset;
                            if (sameLine)
                                (first || (first = [])).push(span);
                        }
                    } else {
                        span.from += offset;
                        if (sameLine)
                            (first || (first = [])).push(span);
                    }
                }
            }
            if (sameLine && first) {
                // Make sure we didn't create any zero-length spans
                for (var i = 0; i < first.length; ++i)
                    if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != 'bookmark')
                        first.splice(i--, 1);
                if (!first.length)
                    first = null;
            }
            var newMarkers = [first];
            if (!sameLine) {
                // Fill gap with whole-line-spans
                var gap = change.text.length - 2, gapMarkers;
                if (gap > 0 && first)
                    for (var i = 0; i < first.length; ++i)
                        if (first[i].to == null)
                            (gapMarkers || (gapMarkers = [])).push({
                                from: null,
                                to: null,
                                marker: first[i].marker
                            });
                for (var i = 0; i < gap; ++i)
                    newMarkers.push(gapMarkers);
                newMarkers.push(last);
            }
            return newMarkers;
        }
        function mergeOldSpans(doc, change) {
            var old = getOldSpans(doc, change);
            var stretched = stretchSpansOverChange(doc, change);
            if (!old)
                return stretched;
            if (!stretched)
                return old;
            for (var i = 0; i < old.length; ++i) {
                var oldCur = old[i], stretchCur = stretched[i];
                if (oldCur && stretchCur) {
                    spans:
                        for (var j = 0; j < stretchCur.length; ++j) {
                            var span = stretchCur[j];
                            for (var k = 0; k < oldCur.length; ++k)
                                if (oldCur[k].marker == span.marker)
                                    continue spans;
                            oldCur.push(span);
                        }
                } else if (stretchCur) {
                    old[i] = stretchCur;
                }
            }
            return old;
        }
        function removeReadOnlyRanges(doc, from, to) {
            var markers = null;
            doc.iter(from.line, to.line + 1, function (line) {
                if (line.markedSpans)
                    for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                            (markers || (markers = [])).push(mark);
                    }
            });
            if (!markers)
                return null;
            var parts = [{
                        from: from,
                        to: to
                    }];
            for (var i = 0; i < markers.length; ++i) {
                var mk = markers[i], m = mk.find();
                for (var j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (posLess(p.to, m.from) || posLess(m.to, p.from))
                        continue;
                    var newParts = [
                            j,
                            1
                        ];
                    if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
                        newParts.push({
                            from: p.from,
                            to: m.from
                        });
                    if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
                        newParts.push({
                            from: m.to,
                            to: p.to
                        });
                    parts.splice.apply(parts, newParts);
                    j += newParts.length - 1;
                }
            }
            return parts;
        }
        function collapsedSpanAt(line, ch) {
            var sps = sawCollapsedSpans && line.markedSpans, found;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (!sp.marker.collapsed)
                        continue;
                    if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
                        found = sp.marker;
                }
            return found;
        }
        function collapsedSpanAtStart(line) {
            return collapsedSpanAt(line, -1);
        }
        function collapsedSpanAtEnd(line) {
            return collapsedSpanAt(line, line.text.length + 1);
        }
        function visualLine(doc, line) {
            var merged;
            while (merged = collapsedSpanAtStart(line))
                line = getLine(doc, merged.find().from.line);
            return line;
        }
        function lineIsHidden(doc, line) {
            var sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp, i = 0; i < sps.length; ++i) {
                    sp = sps[i];
                    if (!sp.marker.collapsed)
                        continue;
                    if (sp.from == null)
                        return true;
                    if (sp.marker.replacedWith)
                        continue;
                    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                        return true;
                }
        }
        function lineIsHiddenInner(doc, line, span) {
            if (span.to == null) {
                var end = span.marker.find().to, endLine = getLine(doc, end.line);
                return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
            }
            if (span.marker.inclusiveRight && span.to == line.text.length)
                return true;
            for (var sp, i = 0; i < line.markedSpans.length; ++i) {
                sp = line.markedSpans[i];
                if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                    return true;
            }
        }
        function detachMarkedSpans(line) {
            var spans = line.markedSpans;
            if (!spans)
                return;
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.detachLine(line);
            line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
            if (!spans)
                return;
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.attachLine(line);
            line.markedSpans = spans;
        }
        // LINE WIDGETS
        var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
                if (options)
                    for (var opt in options)
                        if (options.hasOwnProperty(opt))
                            this[opt] = options[opt];
                this.cm = cm;
                this.node = node;
            };
        eventMixin(LineWidget);
        function widgetOperation(f) {
            return function () {
                var withOp = !this.cm.curOp;
                if (withOp)
                    startOperation(this.cm);
                try {
                    var result = f.apply(this, arguments);
                } finally {
                    if (withOp)
                        endOperation(this.cm);
                }
                return result;
            };
        }
        LineWidget.prototype.clear = widgetOperation(function () {
            var ws = this.line.widgets, no = lineNo(this.line);
            if (no == null || !ws)
                return;
            for (var i = 0; i < ws.length; ++i)
                if (ws[i] == this)
                    ws.splice(i--, 1);
            if (!ws.length)
                this.line.widgets = null;
            var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
            updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
            if (aboveVisible)
                addToScrollPos(this.cm, 0, -this.height);
            regChange(this.cm, no, no + 1);
        });
        LineWidget.prototype.changed = widgetOperation(function () {
            var oldH = this.height;
            this.height = null;
            var diff = widgetHeight(this) - oldH;
            if (!diff)
                return;
            updateLineHeight(this.line, this.line.height + diff);
            var no = lineNo(this.line);
            regChange(this.cm, no, no + 1);
        });
        function widgetHeight(widget) {
            if (widget.height != null)
                return widget.height;
            if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
                removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
            return widget.height = widget.node.offsetHeight;
        }
        function addLineWidget(cm, handle, node, options) {
            var widget = new LineWidget(cm, node, options);
            if (widget.noHScroll)
                cm.display.alignWidgets = true;
            changeLine(cm, handle, function (line) {
                var widgets = line.widgets || (line.widgets = []);
                if (widget.insertAt == null)
                    widgets.push(widget);
                else
                    widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
                widget.line = line;
                if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
                    var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
                    updateLineHeight(line, line.height + widgetHeight(widget));
                    if (aboveVisible)
                        addToScrollPos(cm, 0, widget.height);
                }
                return true;
            });
            return widget;
        }
        // LINE DATA STRUCTURE
        // Line objects. These hold state related to a line, including
        // highlighting info (the styles array).
        var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
                this.text = text;
                attachMarkedSpans(this, markedSpans);
                this.height = estimateHeight ? estimateHeight(this) : 1;
            };
        eventMixin(Line);
        function updateLine(line, text, markedSpans, estimateHeight) {
            line.text = text;
            if (line.stateAfter)
                line.stateAfter = null;
            if (line.styles)
                line.styles = null;
            if (line.order != null)
                line.order = null;
            detachMarkedSpans(line);
            attachMarkedSpans(line, markedSpans);
            var estHeight = estimateHeight ? estimateHeight(line) : 1;
            if (estHeight != line.height)
                updateLineHeight(line, estHeight);
        }
        function cleanUpLine(line) {
            line.parent = null;
            detachMarkedSpans(line);
        }
        // Run the given mode's parser over a line, update the styles
        // array, which contains alternating fragments of text and CSS
        // classes.
        function runMode(cm, text, mode, state, f) {
            var flattenSpans = mode.flattenSpans;
            if (flattenSpans == null)
                flattenSpans = cm.options.flattenSpans;
            var curStart = 0, curStyle = null;
            var stream = new StringStream(text, cm.options.tabSize), style;
            if (text == '' && mode.blankLine)
                mode.blankLine(state);
            while (!stream.eol()) {
                if (stream.pos > cm.options.maxHighlightLength) {
                    flattenSpans = false;
                    stream.pos = text.length;
                    style = null;
                } else {
                    style = mode.token(stream, state);
                }
                if (!flattenSpans || curStyle != style) {
                    if (curStart < stream.start)
                        f(stream.start, curStyle);
                    curStart = stream.start;
                    curStyle = style;
                }
                stream.start = stream.pos;
            }
            while (curStart < stream.pos) {
                // Webkit seems to refuse to render text nodes longer than 57444 characters
                var pos = Math.min(stream.pos, curStart + 50000);
                f(pos, curStyle);
                curStart = pos;
            }
        }
        function highlightLine(cm, line, state) {
            // A styles array always starts with a number identifying the
            // mode/overlays that it is based on (for easy invalidation).
            var st = [cm.state.modeGen];
            // Compute the base array of styles
            runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
                st.push(end, style);
            });
            // Run overlays, adjust style array.
            for (var o = 0; o < cm.state.overlays.length; ++o) {
                var overlay = cm.state.overlays[o], i = 1, at = 0;
                runMode(cm, line.text, overlay.mode, true, function (end, style) {
                    var start = i;
                    // Ensure there's a token end at the current position, and that i points at it
                    while (at < end) {
                        var i_end = st[i];
                        if (i_end > end)
                            st.splice(i, 1, end, st[i + 1], i_end);
                        i += 2;
                        at = Math.min(end, i_end);
                    }
                    if (!style)
                        return;
                    if (overlay.opaque) {
                        st.splice(start, i - start, end, style);
                        i = start + 2;
                    } else {
                        for (; start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = cur ? cur + ' ' + style : style;
                        }
                    }
                });
            }
            return st;
        }
        function getLineStyles(cm, line) {
            if (!line.styles || line.styles[0] != cm.state.modeGen)
                line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            return line.styles;
        }
        // Lightweight form of highlight -- proceed over this line and
        // update state, but don't save a style array.
        function processLine(cm, line, state) {
            var mode = cm.doc.mode;
            var stream = new StringStream(line.text, cm.options.tabSize);
            if (line.text == '' && mode.blankLine)
                mode.blankLine(state);
            while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
                mode.token(stream, state);
                stream.start = stream.pos;
            }
        }
        var styleToClassCache = {};
        function interpretTokenStyle(style, builder) {
            if (!style)
                return null;
            for (;;) {
                var lineClass = style.match(/(?:^|\s)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? 'bgClass' : 'textClass';
                if (builder[prop] == null)
                    builder[prop] = lineClass[2];
                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(builder[prop]))
                    builder[prop] += ' ' + lineClass[2];
            }
            return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
        }
        function buildLineContent(cm, realLine, measure, copyWidgets) {
            var merged, line = realLine, empty = true;
            while (merged = collapsedSpanAtStart(line))
                line = getLine(cm.doc, merged.find().from.line);
            var builder = {
                    pre: elt('pre'),
                    col: 0,
                    pos: 0,
                    measure: null,
                    measuredSomething: false,
                    cm: cm,
                    copyWidgets: copyWidgets
                };
            do {
                if (line.text)
                    empty = false;
                builder.measure = line == realLine && measure;
                builder.pos = 0;
                builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
                if ((ie || webkit) && cm.getOption('lineWrapping'))
                    builder.addToken = buildTokenSplitSpaces(builder.addToken);
                var next = insertLineContent(line, builder, getLineStyles(cm, line));
                if (measure && line == realLine && !builder.measuredSomething) {
                    measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
                    builder.measuredSomething = true;
                }
                if (next)
                    line = getLine(cm.doc, next.to.line);
            } while (next);
            if (measure && !builder.measuredSomething && !measure[0])
                measure[0] = builder.pre.appendChild(empty ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
            if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
                builder.pre.appendChild(document.createTextNode('\xa0'));
            var order;
            // Work around problem with the reported dimensions of single-char
            // direction spans on IE (issue #1129). See also the comment in
            // cursorCoords.
            if (measure && ie && (order = getOrder(line))) {
                var l = order.length - 1;
                if (order[l].from == order[l].to)
                    --l;
                var last = order[l], prev = order[l - 1];
                if (last.from + 1 == last.to && prev && last.level < prev.level) {
                    var span = measure[builder.pos - 1];
                    if (span)
                        span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
                }
            }
            var textClass = builder.textClass ? builder.textClass + ' ' + (realLine.textClass || '') : realLine.textClass;
            if (textClass)
                builder.pre.className = textClass;
            signal(cm, 'renderLine', cm, realLine, builder.pre);
            return builder;
        }
        var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
        function buildToken(builder, text, style, startStyle, endStyle, title) {
            if (!text)
                return;
            if (!tokenSpecialChars.test(text)) {
                builder.col += text.length;
                var content = document.createTextNode(text);
            } else {
                var content = document.createDocumentFragment(), pos = 0;
                while (true) {
                    tokenSpecialChars.lastIndex = pos;
                    var m = tokenSpecialChars.exec(text);
                    var skipped = m ? m.index - pos : text.length - pos;
                    if (skipped) {
                        content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
                        builder.col += skipped;
                    }
                    if (!m)
                        break;
                    pos += skipped + 1;
                    if (m[0] == '\t') {
                        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                        content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
                        builder.col += tabWidth;
                    } else {
                        var token = elt('span', '\u2022', 'cm-invalidchar');
                        token.title = '\\u' + m[0].charCodeAt(0).toString(16);
                        content.appendChild(token);
                        builder.col += 1;
                    }
                }
            }
            if (style || startStyle || endStyle || builder.measure) {
                var fullStyle = style || '';
                if (startStyle)
                    fullStyle += startStyle;
                if (endStyle)
                    fullStyle += endStyle;
                var token = elt('span', [content], fullStyle);
                if (title)
                    token.title = title;
                return builder.pre.appendChild(token);
            }
            builder.pre.appendChild(content);
        }
        function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
            var wrapping = builder.cm.options.lineWrapping;
            for (var i = 0; i < text.length; ++i) {
                var ch = text.charAt(i), start = i == 0;
                if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
                    ch = text.slice(i, i + 2);
                    ++i;
                } else if (i && wrapping && spanAffectsWrapping(text, i)) {
                    builder.pre.appendChild(elt('wbr'));
                }
                var old = builder.measure[builder.pos];
                var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
                if (old)
                    span.leftSide = old.leftSide || old;
                // In IE single-space nodes wrap differently than spaces
                // embedded in larger text nodes, except when set to
                // white-space: normal (issue #1268).
                if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
                    span.style.whiteSpace = 'normal';
                builder.pos += ch.length;
            }
            if (text.length)
                builder.measuredSomething = true;
        }
        function buildTokenSplitSpaces(inner) {
            function split(old) {
                var out = ' ';
                for (var i = 0; i < old.length - 2; ++i)
                    out += i % 2 ? ' ' : '\xa0';
                out += ' ';
                return out;
            }
            return function (builder, text, style, startStyle, endStyle, title) {
                return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
            };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
            var widget = !ignoreWidget && marker.replacedWith;
            if (widget) {
                if (builder.copyWidgets)
                    widget = widget.cloneNode(true);
                builder.pre.appendChild(widget);
                if (builder.measure) {
                    if (size) {
                        builder.measure[builder.pos] = widget;
                    } else {
                        var elt = zeroWidthElement(builder.cm.display.measure);
                        if (marker.type == 'bookmark' && !marker.insertLeft)
                            builder.measure[builder.pos] = builder.pre.appendChild(elt);
                        else if (builder.measure[builder.pos])
                            return;
                        else
                            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);
                    }
                    builder.measuredSomething = true;
                }
            }
            builder.pos += size;
        }
        // Outputs a number of spans to make up a line, taking highlighting
        // and marked text into account.
        function insertLineContent(line, builder, styles) {
            var spans = line.markedSpans, allText = line.text, at = 0;
            if (!spans) {
                for (var i = 1; i < styles.length; i += 2)
                    builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder));
                return;
            }
            var len = allText.length, pos = 0, i = 1, text = '', style;
            var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
            for (;;) {
                if (nextChange == pos) {
                    // Update current marker set
                    spanStyle = spanEndStyle = spanStartStyle = title = '';
                    collapsed = null;
                    nextChange = Infinity;
                    var foundBookmarks = [];
                    for (var j = 0; j < spans.length; ++j) {
                        var sp = spans[j], m = sp.marker;
                        if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
                            if (sp.to != null && nextChange > sp.to) {
                                nextChange = sp.to;
                                spanEndStyle = '';
                            }
                            if (m.className)
                                spanStyle += ' ' + m.className;
                            if (m.startStyle && sp.from == pos)
                                spanStartStyle += ' ' + m.startStyle;
                            if (m.endStyle && sp.to == nextChange)
                                spanEndStyle += ' ' + m.endStyle;
                            if (m.title && !title)
                                title = m.title;
                            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size))
                                collapsed = sp;
                        } else if (sp.from > pos && nextChange > sp.from) {
                            nextChange = sp.from;
                        }
                        if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
                            foundBookmarks.push(m);
                    }
                    if (collapsed && (collapsed.from || 0) == pos) {
                        buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                        if (collapsed.to == null)
                            return collapsed.marker.find();
                    }
                    if (!collapsed && foundBookmarks.length)
                        for (var j = 0; j < foundBookmarks.length; ++j)
                            buildCollapsedSpan(builder, 0, foundBookmarks[j]);
                }
                if (pos >= len)
                    break;
                var upto = Math.min(len, nextChange);
                while (true) {
                    if (text) {
                        var end = pos + text.length;
                        if (!collapsed) {
                            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title);
                        }
                        if (end >= upto) {
                            text = text.slice(upto - pos);
                            pos = upto;
                            break;
                        }
                        pos = end;
                        spanStartStyle = '';
                    }
                    text = allText.slice(at, at = styles[i++]);
                    style = interpretTokenStyle(styles[i++], builder);
                }
            }
        }
        // DOCUMENT DATA STRUCTURE
        function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
            function spansFor(n) {
                return markedSpans ? markedSpans[n] : null;
            }
            function update(line, text, spans) {
                updateLine(line, text, spans, estimateHeight);
                signalLater(line, 'change', line, change);
            }
            var from = change.from, to = change.to, text = change.text;
            var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
            var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
            // First adjust the line structure
            if (from.ch == 0 && to.ch == 0 && lastText == '') {
                // This is a whole-line replace. Treated specially to make
                // sure line objects move the way they are supposed to.
                for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                update(lastLine, lastLine.text, lastSpans);
                if (nlines)
                    doc.remove(from.line, nlines);
                if (added.length)
                    doc.insert(from.line, added);
            } else if (firstLine == lastLine) {
                if (text.length == 1) {
                    update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
                } else {
                    for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
                        added.push(new Line(text[i], spansFor(i), estimateHeight));
                    added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                    doc.insert(from.line + 1, added);
                }
            } else if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
                doc.remove(from.line + 1, nlines);
            } else {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                if (nlines > 1)
                    doc.remove(from.line + 1, nlines - 1);
                doc.insert(from.line + 1, added);
            }
            signalLater(doc, 'change', doc, change);
            setSelection(doc, selAfter.anchor, selAfter.head, null, true);
        }
        function LeafChunk(lines) {
            this.lines = lines;
            this.parent = null;
            for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
                lines[i].parent = this;
                height += lines[i].height;
            }
            this.height = height;
        }
        LeafChunk.prototype = {
            chunkSize: function () {
                return this.lines.length;
            },
            removeInner: function (at, n) {
                for (var i = at, e = at + n; i < e; ++i) {
                    var line = this.lines[i];
                    this.height -= line.height;
                    cleanUpLine(line);
                    signalLater(line, 'delete');
                }
                this.lines.splice(at, n);
            },
            collapse: function (lines) {
                lines.splice.apply(lines, [
                    lines.length,
                    0
                ].concat(this.lines));
            },
            insertInner: function (at, lines, height) {
                this.height += height;
                this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                for (var i = 0, e = lines.length; i < e; ++i)
                    lines[i].parent = this;
            },
            iterN: function (at, n, op) {
                for (var e = at + n; at < e; ++at)
                    if (op(this.lines[at]))
                        return true;
            }
        };
        function BranchChunk(children) {
            this.children = children;
            var size = 0, height = 0;
            for (var i = 0, e = children.length; i < e; ++i) {
                var ch = children[i];
                size += ch.chunkSize();
                height += ch.height;
                ch.parent = this;
            }
            this.size = size;
            this.height = height;
            this.parent = null;
        }
        BranchChunk.prototype = {
            chunkSize: function () {
                return this.size;
            },
            removeInner: function (at, n) {
                this.size -= n;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var rm = Math.min(n, sz - at), oldHeight = child.height;
                        child.removeInner(at, rm);
                        this.height -= oldHeight - child.height;
                        if (sz == rm) {
                            this.children.splice(i--, 1);
                            child.parent = null;
                        }
                        if ((n -= rm) == 0)
                            break;
                        at = 0;
                    } else
                        at -= sz;
                }
                if (this.size - n < 25) {
                    var lines = [];
                    this.collapse(lines);
                    this.children = [new LeafChunk(lines)];
                    this.children[0].parent = this;
                }
            },
            collapse: function (lines) {
                for (var i = 0, e = this.children.length; i < e; ++i)
                    this.children[i].collapse(lines);
            },
            insertInner: function (at, lines, height) {
                this.size += lines.length;
                this.height += height;
                for (var i = 0, e = this.children.length; i < e; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at <= sz) {
                        child.insertInner(at, lines, height);
                        if (child.lines && child.lines.length > 50) {
                            while (child.lines.length > 50) {
                                var spilled = child.lines.splice(child.lines.length - 25, 25);
                                var newleaf = new LeafChunk(spilled);
                                child.height -= newleaf.height;
                                this.children.splice(i + 1, 0, newleaf);
                                newleaf.parent = this;
                            }
                            this.maybeSpill();
                        }
                        break;
                    }
                    at -= sz;
                }
            },
            maybeSpill: function () {
                if (this.children.length <= 10)
                    return;
                var me = this;
                do {
                    var spilled = me.children.splice(me.children.length - 5, 5);
                    var sibling = new BranchChunk(spilled);
                    if (!me.parent) {
                        // Become the parent node
                        var copy = new BranchChunk(me.children);
                        copy.parent = me;
                        me.children = [
                            copy,
                            sibling
                        ];
                        me = copy;
                    } else {
                        me.size -= sibling.size;
                        me.height -= sibling.height;
                        var myIndex = indexOf(me.parent.children, me);
                        me.parent.children.splice(myIndex + 1, 0, sibling);
                    }
                    sibling.parent = me.parent;
                } while (me.children.length > 10);
                me.parent.maybeSpill();
            },
            iterN: function (at, n, op) {
                for (var i = 0, e = this.children.length; i < e; ++i) {
                    var child = this.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var used = Math.min(n, sz - at);
                        if (child.iterN(at, used, op))
                            return true;
                        if ((n -= used) == 0)
                            break;
                        at = 0;
                    } else
                        at -= sz;
                }
            }
        };
        var nextDocId = 0;
        var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
                if (!(this instanceof Doc))
                    return new Doc(text, mode, firstLine);
                if (firstLine == null)
                    firstLine = 0;
                BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
                this.first = firstLine;
                this.scrollTop = this.scrollLeft = 0;
                this.cantEdit = false;
                this.history = makeHistory();
                this.cleanGeneration = 1;
                this.frontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = {
                    from: start,
                    to: start,
                    head: start,
                    anchor: start,
                    shift: false,
                    extend: false,
                    goalColumn: null
                };
                this.id = ++nextDocId;
                this.modeOption = mode;
                if (typeof text == 'string')
                    text = splitLines(text);
                updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }, null, {
                    head: start,
                    anchor: start
                });
            };
        Doc.prototype = createObj(BranchChunk.prototype, {
            constructor: Doc,
            iter: function (from, to, op) {
                if (op)
                    this.iterN(from - this.first, to - from, op);
                else
                    this.iterN(this.first, this.first + this.size, from);
            },
            insert: function (at, lines) {
                var height = 0;
                for (var i = 0, e = lines.length; i < e; ++i)
                    height += lines[i].height;
                this.insertInner(at - this.first, lines, height);
            },
            remove: function (at, n) {
                this.removeInner(at - this.first, n);
            },
            getValue: function (lineSep) {
                var lines = getLines(this, this.first, this.first + this.size);
                if (lineSep === false)
                    return lines;
                return lines.join(lineSep || '\n');
            },
            setValue: function (code) {
                var top = Pos(this.first, 0), last = this.first + this.size - 1;
                makeChange(this, {
                    from: top,
                    to: Pos(last, getLine(this, last).text.length),
                    text: splitLines(code),
                    origin: 'setValue'
                }, {
                    head: top,
                    anchor: top
                }, true);
            },
            replaceRange: function (code, from, to, origin) {
                from = clipPos(this, from);
                to = to ? clipPos(this, to) : from;
                replaceRange(this, code, from, to, origin);
            },
            getRange: function (from, to, lineSep) {
                var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                if (lineSep === false)
                    return lines;
                return lines.join(lineSep || '\n');
            },
            getLine: function (line) {
                var l = this.getLineHandle(line);
                return l && l.text;
            },
            setLine: function (line, text) {
                if (isLine(this, line))
                    replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
            },
            removeLine: function (line) {
                if (line)
                    replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
                else
                    replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
            },
            getLineHandle: function (line) {
                if (isLine(this, line))
                    return getLine(this, line);
            },
            getLineNumber: function (line) {
                return lineNo(line);
            },
            getLineHandleVisualStart: function (line) {
                if (typeof line == 'number')
                    line = getLine(this, line);
                return visualLine(this, line);
            },
            lineCount: function () {
                return this.size;
            },
            firstLine: function () {
                return this.first;
            },
            lastLine: function () {
                return this.first + this.size - 1;
            },
            clipPos: function (pos) {
                return clipPos(this, pos);
            },
            getCursor: function (start) {
                var sel = this.sel, pos;
                if (start == null || start == 'head')
                    pos = sel.head;
                else if (start == 'anchor')
                    pos = sel.anchor;
                else if (start == 'end' || start === false)
                    pos = sel.to;
                else
                    pos = sel.from;
                return copyPos(pos);
            },
            somethingSelected: function () {
                return !posEq(this.sel.head, this.sel.anchor);
            },
            setCursor: docOperation(function (line, ch, extend) {
                var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
                if (extend)
                    extendSelection(this, pos);
                else
                    setSelection(this, pos, pos);
            }),
            setSelection: docOperation(function (anchor, head, bias) {
                setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);
            }),
            extendSelection: docOperation(function (from, to, bias) {
                extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);
            }),
            getSelection: function (lineSep) {
                return this.getRange(this.sel.from, this.sel.to, lineSep);
            },
            replaceSelection: function (code, collapse, origin) {
                makeChange(this, {
                    from: this.sel.from,
                    to: this.sel.to,
                    text: splitLines(code),
                    origin: origin
                }, collapse || 'around');
            },
            undo: docOperation(function () {
                makeChangeFromHistory(this, 'undo');
            }),
            redo: docOperation(function () {
                makeChangeFromHistory(this, 'redo');
            }),
            setExtending: function (val) {
                this.sel.extend = val;
            },
            historySize: function () {
                var hist = this.history;
                return {
                    undo: hist.done.length,
                    redo: hist.undone.length
                };
            },
            clearHistory: function () {
                this.history = makeHistory(this.history.maxGeneration);
            },
            markClean: function () {
                this.cleanGeneration = this.changeGeneration();
            },
            changeGeneration: function () {
                this.history.lastOp = this.history.lastOrigin = null;
                return this.history.generation;
            },
            isClean: function (gen) {
                return this.history.generation == (gen || this.cleanGeneration);
            },
            getHistory: function () {
                return {
                    done: copyHistoryArray(this.history.done),
                    undone: copyHistoryArray(this.history.undone)
                };
            },
            setHistory: function (histData) {
                var hist = this.history = makeHistory(this.history.maxGeneration);
                hist.done = histData.done.slice(0);
                hist.undone = histData.undone.slice(0);
            },
            markText: function (from, to, options) {
                return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
            },
            setBookmark: function (pos, options) {
                var realOpts = {
                        replacedWith: options && (options.nodeType == null ? options.widget : options),
                        insertLeft: options && options.insertLeft
                    };
                pos = clipPos(this, pos);
                return markText(this, pos, pos, realOpts, 'bookmark');
            },
            findMarksAt: function (pos) {
                pos = clipPos(this, pos);
                var markers = [], spans = getLine(this, pos.line).markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                            markers.push(span.marker.parent || span.marker);
                    }
                return markers;
            },
            getAllMarks: function () {
                var markers = [];
                this.iter(function (line) {
                    var sps = line.markedSpans;
                    if (sps)
                        for (var i = 0; i < sps.length; ++i)
                            if (sps[i].from != null)
                                markers.push(sps[i].marker);
                });
                return markers;
            },
            posFromIndex: function (off) {
                var ch, lineNo = this.first;
                this.iter(function (line) {
                    var sz = line.text.length + 1;
                    if (sz > off) {
                        ch = off;
                        return true;
                    }
                    off -= sz;
                    ++lineNo;
                });
                return clipPos(this, Pos(lineNo, ch));
            },
            indexFromPos: function (coords) {
                coords = clipPos(this, coords);
                var index = coords.ch;
                if (coords.line < this.first || coords.ch < 0)
                    return 0;
                this.iter(this.first, coords.line, function (line) {
                    index += line.text.length + 1;
                });
                return index;
            },
            copy: function (copyHistory) {
                var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
                doc.scrollTop = this.scrollTop;
                doc.scrollLeft = this.scrollLeft;
                doc.sel = {
                    from: this.sel.from,
                    to: this.sel.to,
                    head: this.sel.head,
                    anchor: this.sel.anchor,
                    shift: this.sel.shift,
                    extend: false,
                    goalColumn: this.sel.goalColumn
                };
                if (copyHistory) {
                    doc.history.undoDepth = this.history.undoDepth;
                    doc.setHistory(this.getHistory());
                }
                return doc;
            },
            linkedDoc: function (options) {
                if (!options)
                    options = {};
                var from = this.first, to = this.first + this.size;
                if (options.from != null && options.from > from)
                    from = options.from;
                if (options.to != null && options.to < to)
                    to = options.to;
                var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
                if (options.sharedHist)
                    copy.history = this.history;
                (this.linked || (this.linked = [])).push({
                    doc: copy,
                    sharedHist: options.sharedHist
                });
                copy.linked = [{
                        doc: this,
                        isParent: true,
                        sharedHist: options.sharedHist
                    }];
                return copy;
            },
            unlinkDoc: function (other) {
                if (other instanceof CodeMirror)
                    other = other.doc;
                if (this.linked)
                    for (var i = 0; i < this.linked.length; ++i) {
                        var link = this.linked[i];
                        if (link.doc != other)
                            continue;
                        this.linked.splice(i, 1);
                        other.unlinkDoc(this);
                        break;
                    }
                // If the histories were shared, split them again
                if (other.history == this.history) {
                    var splitIds = [other.id];
                    linkedDocs(other, function (doc) {
                        splitIds.push(doc.id);
                    }, true);
                    other.history = makeHistory();
                    other.history.done = copyHistoryArray(this.history.done, splitIds);
                    other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                }
            },
            iterLinkedDocs: function (f) {
                linkedDocs(this, f);
            },
            getMode: function () {
                return this.mode;
            },
            getEditor: function () {
                return this.cm;
            }
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        // The Doc methods that should be available on CodeMirror instances
        var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
        for (var prop in Doc.prototype)
            if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
                CodeMirror.prototype[prop] = function (method) {
                    return function () {
                        return method.apply(this.doc, arguments);
                    };
                }(Doc.prototype[prop]);
        eventMixin(Doc);
        function linkedDocs(doc, f, sharedHistOnly) {
            function propagate(doc, skip, sharedHist) {
                if (doc.linked)
                    for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc == skip)
                            continue;
                        var shared = sharedHist && rel.sharedHist;
                        if (sharedHistOnly && !shared)
                            continue;
                        f(rel.doc, shared);
                        propagate(rel.doc, doc, shared);
                    }
            }
            propagate(doc, null, true);
        }
        function attachDoc(cm, doc) {
            if (doc.cm)
                throw new Error('This document is already in use.');
            cm.doc = doc;
            doc.cm = cm;
            estimateLineHeights(cm);
            loadMode(cm);
            if (!cm.options.lineWrapping)
                computeMaxLength(cm);
            cm.options.mode = doc.modeOption;
            regChange(cm);
        }
        // LINE UTILITIES
        function getLine(chunk, n) {
            n -= chunk.first;
            while (!chunk.lines) {
                for (var i = 0;; ++i) {
                    var child = chunk.children[i], sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break;
                    }
                    n -= sz;
                }
            }
            return chunk.lines[n];
        }
        function getBetween(doc, start, end) {
            var out = [], n = start.line;
            doc.iter(start.line, end.line + 1, function (line) {
                var text = line.text;
                if (n == end.line)
                    text = text.slice(0, end.ch);
                if (n == start.line)
                    text = text.slice(start.ch);
                out.push(text);
                ++n;
            });
            return out;
        }
        function getLines(doc, from, to) {
            var out = [];
            doc.iter(from, to, function (line) {
                out.push(line.text);
            });
            return out;
        }
        function updateLineHeight(line, height) {
            var diff = height - line.height;
            for (var n = line; n; n = n.parent)
                n.height += diff;
        }
        function lineNo(line) {
            if (line.parent == null)
                return null;
            var cur = line.parent, no = indexOf(cur.lines, line);
            for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
                for (var i = 0;; ++i) {
                    if (chunk.children[i] == cur)
                        break;
                    no += chunk.children[i].chunkSize();
                }
            }
            return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
            var n = chunk.first;
            outer:
                do {
                    for (var i = 0, e = chunk.children.length; i < e; ++i) {
                        var child = chunk.children[i], ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch;
                        n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
            for (var i = 0, e = chunk.lines.length; i < e; ++i) {
                var line = chunk.lines[i], lh = line.height;
                if (h < lh)
                    break;
                h -= lh;
            }
            return n + i;
        }
        function heightAtLine(cm, lineObj) {
            lineObj = visualLine(cm.doc, lineObj);
            var h = 0, chunk = lineObj.parent;
            for (var i = 0; i < chunk.lines.length; ++i) {
                var line = chunk.lines[i];
                if (line == lineObj)
                    break;
                else
                    h += line.height;
            }
            for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
                for (var i = 0; i < p.children.length; ++i) {
                    var cur = p.children[i];
                    if (cur == chunk)
                        break;
                    else
                        h += cur.height;
                }
            }
            return h;
        }
        function getOrder(line) {
            var order = line.order;
            if (order == null)
                order = line.order = bidiOrdering(line.text);
            return order;
        }
        // HISTORY
        function makeHistory(startGen) {
            return {
                done: [],
                undone: [],
                undoDepth: Infinity,
                lastTime: 0,
                lastOp: null,
                lastOrigin: null,
                generation: startGen || 1,
                maxGeneration: startGen || 1
            };
        }
        function attachLocalSpans(doc, change, from, to) {
            var existing = change['spans_' + doc.id], n = 0;
            doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
                if (line.markedSpans)
                    (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
                ++n;
            });
        }
        function historyChangeFromChange(doc, change) {
            var from = {
                    line: change.from.line,
                    ch: change.from.ch
                };
            var histChange = {
                    from: from,
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
            linkedDocs(doc, function (doc) {
                attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
            }, true);
            return histChange;
        }
        function addToHistory(doc, change, selAfter, opId) {
            var hist = doc.history;
            hist.undone.length = 0;
            var time = +new Date(), cur = lst(hist.done);
            if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
                // Merge this change into the last event
                var last = lst(cur.changes);
                if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
                    // Optimized case for simple insertion -- don't want to add
                    // new changesets for every character typed
                    last.to = changeEnd(change);
                } else {
                    // Add new sub-event
                    cur.changes.push(historyChangeFromChange(doc, change));
                }
                cur.anchorAfter = selAfter.anchor;
                cur.headAfter = selAfter.head;
            } else {
                // Can not be merged, start a new event.
                cur = {
                    changes: [historyChangeFromChange(doc, change)],
                    generation: hist.generation,
                    anchorBefore: doc.sel.anchor,
                    headBefore: doc.sel.head,
                    anchorAfter: selAfter.anchor,
                    headAfter: selAfter.head
                };
                hist.done.push(cur);
                hist.generation = ++hist.maxGeneration;
                while (hist.done.length > hist.undoDepth)
                    hist.done.shift();
            }
            hist.lastTime = time;
            hist.lastOp = opId;
            hist.lastOrigin = change.origin;
        }
        function removeClearedSpans(spans) {
            if (!spans)
                return null;
            for (var i = 0, out; i < spans.length; ++i) {
                if (spans[i].marker.explicitlyCleared) {
                    if (!out)
                        out = spans.slice(0, i);
                } else if (out)
                    out.push(spans[i]);
            }
            return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc, change) {
            var found = change['spans_' + doc.id];
            if (!found)
                return null;
            for (var i = 0, nw = []; i < change.text.length; ++i)
                nw.push(removeClearedSpans(found[i]));
            return nw;
        }
        // Used both to provide a JSON-safe object in .getHistory, and, when
        // detaching a document, to split the history in two
        function copyHistoryArray(events, newGroup) {
            for (var i = 0, copy = []; i < events.length; ++i) {
                var event = events[i], changes = event.changes, newChanges = [];
                copy.push({
                    changes: newChanges,
                    anchorBefore: event.anchorBefore,
                    headBefore: event.headBefore,
                    anchorAfter: event.anchorAfter,
                    headAfter: event.headAfter
                });
                for (var j = 0; j < changes.length; ++j) {
                    var change = changes[j], m;
                    newChanges.push({
                        from: change.from,
                        to: change.to,
                        text: change.text
                    });
                    if (newGroup)
                        for (var prop in change)
                            if (m = prop.match(/^spans_(\d+)$/)) {
                                if (indexOf(newGroup, Number(m[1])) > -1) {
                                    lst(newChanges)[prop] = change[prop];
                                    delete change[prop];
                                }
                            }
                }
            }
            return copy;
        }
        // Rebasing/resetting history to deal with externally-sourced changes
        function rebaseHistSel(pos, from, to, diff) {
            if (to < pos.line) {
                pos.line += diff;
            } else if (from < pos.line) {
                pos.line = from;
                pos.ch = 0;
            }
        }
        // Tries to rebase an array of history events given a change in the
        // document. If the change touches the same lines as the event, the
        // event, and everything 'behind' it, is discarded. If the change is
        // before the event, the event's positions are updated. Uses a
        // copy-on-write scheme for the positions, to avoid having to
        // reallocate them all on every rebase, but also avoid problems with
        // shared position objects being unsafely updated.
        function rebaseHistArray(array, from, to, diff) {
            for (var i = 0; i < array.length; ++i) {
                var sub = array[i], ok = true;
                for (var j = 0; j < sub.changes.length; ++j) {
                    var cur = sub.changes[j];
                    if (!sub.copied) {
                        cur.from = copyPos(cur.from);
                        cur.to = copyPos(cur.to);
                    }
                    if (to < cur.from.line) {
                        cur.from.line += diff;
                        cur.to.line += diff;
                    } else if (from <= cur.to.line) {
                        ok = false;
                        break;
                    }
                }
                if (!sub.copied) {
                    sub.anchorBefore = copyPos(sub.anchorBefore);
                    sub.headBefore = copyPos(sub.headBefore);
                    sub.anchorAfter = copyPos(sub.anchorAfter);
                    sub.readAfter = copyPos(sub.headAfter);
                    sub.copied = true;
                }
                if (!ok) {
                    array.splice(0, i + 1);
                    i = 0;
                } else {
                    rebaseHistSel(sub.anchorBefore);
                    rebaseHistSel(sub.headBefore);
                    rebaseHistSel(sub.anchorAfter);
                    rebaseHistSel(sub.headAfter);
                }
            }
        }
        function rebaseHist(hist, change) {
            var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
            rebaseHistArray(hist.done, from, to, diff);
            rebaseHistArray(hist.undone, from, to, diff);
        }
        // EVENT OPERATORS
        function stopMethod() {
            e_stop(this);
        }
        // Ensure an event has a stop method.
        function addStop(event) {
            if (!event.stop)
                event.stop = stopMethod;
            return event;
        }
        function e_preventDefault(e) {
            if (e.preventDefault)
                e.preventDefault();
            else
                e.returnValue = false;
        }
        function e_stopPropagation(e) {
            if (e.stopPropagation)
                e.stopPropagation();
            else
                e.cancelBubble = true;
        }
        function e_defaultPrevented(e) {
            return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
        }
        function e_stop(e) {
            e_preventDefault(e);
            e_stopPropagation(e);
        }
        CodeMirror.e_stop = e_stop;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        function e_target(e) {
            return e.target || e.srcElement;
        }
        function e_button(e) {
            var b = e.which;
            if (b == null) {
                if (e.button & 1)
                    b = 1;
                else if (e.button & 2)
                    b = 3;
                else if (e.button & 4)
                    b = 2;
            }
            if (mac && e.ctrlKey && b == 1)
                b = 3;
            return b;
        }
        // EVENT HANDLING
        function on(emitter, type, f) {
            if (emitter.addEventListener)
                emitter.addEventListener(type, f, false);
            else if (emitter.attachEvent)
                emitter.attachEvent('on' + type, f);
            else {
                var map = emitter._handlers || (emitter._handlers = {});
                var arr = map[type] || (map[type] = []);
                arr.push(f);
            }
        }
        function off(emitter, type, f) {
            if (emitter.removeEventListener)
                emitter.removeEventListener(type, f, false);
            else if (emitter.detachEvent)
                emitter.detachEvent('on' + type, f);
            else {
                var arr = emitter._handlers && emitter._handlers[type];
                if (!arr)
                    return;
                for (var i = 0; i < arr.length; ++i)
                    if (arr[i] == f) {
                        arr.splice(i, 1);
                        break;
                    }
            }
        }
        function signal(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            var args = Array.prototype.slice.call(arguments, 2);
            for (var i = 0; i < arr.length; ++i)
                arr[i].apply(null, args);
        }
        var delayedCallbacks, delayedCallbackDepth = 0;
        function signalLater(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            var args = Array.prototype.slice.call(arguments, 2);
            if (!delayedCallbacks) {
                ++delayedCallbackDepth;
                delayedCallbacks = [];
                setTimeout(fireDelayed, 0);
            }
            function bnd(f) {
                return function () {
                    f.apply(null, args);
                };
            }
            for (var i = 0; i < arr.length; ++i)
                delayedCallbacks.push(bnd(arr[i]));
        }
        function signalDOMEvent(cm, e, override) {
            signal(cm, override || e.type, cm, e);
            return e_defaultPrevented(e) || e.codemirrorIgnore;
        }
        function fireDelayed() {
            --delayedCallbackDepth;
            var delayed = delayedCallbacks;
            delayedCallbacks = null;
            for (var i = 0; i < delayed.length; ++i)
                delayed[i]();
        }
        function hasHandler(emitter, type) {
            var arr = emitter._handlers && emitter._handlers[type];
            return arr && arr.length > 0;
        }
        CodeMirror.on = on;
        CodeMirror.off = off;
        CodeMirror.signal = signal;
        function eventMixin(ctor) {
            ctor.prototype.on = function (type, f) {
                on(this, type, f);
            };
            ctor.prototype.off = function (type, f) {
                off(this, type, f);
            };
        }
        // MISC UTILITIES
        // Number of pixels added to scroller and sizer to hide scrollbar
        var scrollerCutOff = 30;
        // Returned or thrown by various protocols to signal 'I'm not
        // handling this'.
        var Pass = CodeMirror.Pass = {
                toString: function () {
                    return 'CodeMirror.Pass';
                }
            };
        function Delayed() {
            this.id = null;
        }
        Delayed.prototype = {
            set: function (ms, f) {
                clearTimeout(this.id);
                this.id = setTimeout(f, ms);
            }
        };
        // Counts the column offset in a string, taking tabs into account.
        // Used mostly to find indentation.
        function countColumn(string, end, tabSize, startIndex, startValue) {
            if (end == null) {
                end = string.search(/[^\s\u00a0]/);
                if (end == -1)
                    end = string.length;
            }
            for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
                if (string.charAt(i) == '\t')
                    n += tabSize - n % tabSize;
                else
                    ++n;
            }
            return n;
        }
        CodeMirror.countColumn = countColumn;
        var spaceStrs = [''];
        function spaceStr(n) {
            while (spaceStrs.length <= n)
                spaceStrs.push(lst(spaceStrs) + ' ');
            return spaceStrs[n];
        }
        function lst(arr) {
            return arr[arr.length - 1];
        }
        function selectInput(node) {
            if (ios) {
                // Mobile Safari apparently has a bug where select() is broken.
                node.selectionStart = 0;
                node.selectionEnd = node.value.length;
            } else {
                // Suppress mysterious IE10 errors
                try {
                    node.select();
                } catch (_e) {
                }
            }
        }
        function indexOf(collection, elt) {
            if (collection.indexOf)
                return collection.indexOf(elt);
            for (var i = 0, e = collection.length; i < e; ++i)
                if (collection[i] == elt)
                    return i;
            return -1;
        }
        function createObj(base, props) {
            function Obj() {
            }
            Obj.prototype = base;
            var inst = new Obj();
            if (props)
                copyObj(props, inst);
            return inst;
        }
        function copyObj(obj, target) {
            if (!target)
                target = {};
            for (var prop in obj)
                if (obj.hasOwnProperty(prop))
                    target[prop] = obj[prop];
            return target;
        }
        function emptyArray(size) {
            for (var a = [], i = 0; i < size; ++i)
                a.push(undefined);
            return a;
        }
        function bind(f) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function () {
                return f.apply(null, args);
            };
        }
        var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordChar(ch) {
            return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isEmpty(obj) {
            for (var n in obj)
                if (obj.hasOwnProperty(n) && obj[n])
                    return false;
            return true;
        }
        var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
        // DOM UTILITIES
        function elt(tag, content, className, style) {
            var e = document.createElement(tag);
            if (className)
                e.className = className;
            if (style)
                e.style.cssText = style;
            if (typeof content == 'string')
                setTextContent(e, content);
            else if (content)
                for (var i = 0; i < content.length; ++i)
                    e.appendChild(content[i]);
            return e;
        }
        function removeChildren(e) {
            for (var count = e.childNodes.length; count > 0; --count)
                e.removeChild(e.firstChild);
            return e;
        }
        function removeChildrenAndAdd(parent, e) {
            return removeChildren(parent).appendChild(e);
        }
        function setTextContent(e, str) {
            if (ie_lt9) {
                e.innerHTML = '';
                e.appendChild(document.createTextNode(str));
            } else
                e.textContent = str;
        }
        function getRect(node) {
            return node.getBoundingClientRect();
        }
        CodeMirror.replaceGetRect = function (f) {
            getRect = f;
        };
        // FEATURE DETECTION
        // Detect drag-and-drop
        var dragAndDrop = function () {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie_lt9)
                    return false;
                var div = elt('div');
                return 'draggable' in div || 'dragDrop' in div;
            }();
        // For a reason I have yet to figure out, some browsers disallow
        // word wrapping between certain characters *only* if a new inline
        // element is started between them. This makes it hard to reliably
        // measure the position of things, since that requires inserting an
        // extra span. This terribly fragile set of tests matches the
        // character combinations that suffer from this phenomenon on the
        // various browsers.
        function spanAffectsWrapping() {
            return false;
        }
        if (gecko)
            // Only for "$'"
            spanAffectsWrapping = function (str, i) {
                return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
            };
        else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
            spanAffectsWrapping = function (str, i) {
                return /\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1));
            };
        else if (webkit && /Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent))
            spanAffectsWrapping = function (str, i) {
                var code = str.charCodeAt(i - 1);
                return code >= 8208 && code <= 8212;
            };
        else if (webkit)
            spanAffectsWrapping = function (str, i) {
                if (i > 1 && str.charCodeAt(i - 1) == 45) {
                    if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i)))
                        return true;
                    if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i)))
                        return false;
                }
                return /[~!#%&*)=+}\]\\|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));
            };
        var knownScrollbarWidth;
        function scrollbarWidth(measure) {
            if (knownScrollbarWidth != null)
                return knownScrollbarWidth;
            var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
            removeChildrenAndAdd(measure, test);
            if (test.offsetWidth)
                knownScrollbarWidth = test.offsetHeight - test.clientHeight;
            return knownScrollbarWidth || 0;
        }
        var zwspSupported;
        function zeroWidthElement(measure) {
            if (zwspSupported == null) {
                var test = elt('span', '\u200b');
                removeChildrenAndAdd(measure, elt('span', [
                    test,
                    document.createTextNode('x')
                ]));
                if (measure.firstChild.offsetHeight != 0)
                    zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
            }
            if (zwspSupported)
                return elt('span', '\u200b');
            else
                return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
        }
        // See if "".split is the broken IE version, if so, provide an
        // alternative way to split lines.
        var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
                var pos = 0, result = [], l = string.length;
                while (pos <= l) {
                    var nl = string.indexOf('\n', pos);
                    if (nl == -1)
                        nl = string.length;
                    var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
                    var rt = line.indexOf('\r');
                    if (rt != -1) {
                        result.push(line.slice(0, rt));
                        pos += rt + 1;
                    } else {
                        result.push(line);
                        pos = nl + 1;
                    }
                }
                return result;
            } : function (string) {
                return string.split(/\r\n?|\n/);
            };
        CodeMirror.splitLines = splitLines;
        var hasSelection = window.getSelection ? function (te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return false;
                }
            } : function (te) {
                try {
                    var range = te.ownerDocument.selection.createRange();
                } catch (e) {
                }
                if (!range || range.parentElement() != te)
                    return false;
                return range.compareEndPoints('StartToEnd', range) != 0;
            };
        var hasCopyEvent = function () {
                var e = elt('div');
                if ('oncopy' in e)
                    return true;
                e.setAttribute('oncopy', 'return;');
                return typeof e.oncopy == 'function';
            }();
        // KEY NAMING
        var keyNames = {
                3: 'Enter',
                8: 'Backspace',
                9: 'Tab',
                13: 'Enter',
                16: 'Shift',
                17: 'Ctrl',
                18: 'Alt',
                19: 'Pause',
                20: 'CapsLock',
                27: 'Esc',
                32: 'Space',
                33: 'PageUp',
                34: 'PageDown',
                35: 'End',
                36: 'Home',
                37: 'Left',
                38: 'Up',
                39: 'Right',
                40: 'Down',
                44: 'PrintScrn',
                45: 'Insert',
                46: 'Delete',
                59: ';',
                91: 'Mod',
                92: 'Mod',
                93: 'Mod',
                109: '-',
                107: '=',
                127: 'Delete',
                186: ';',
                187: '=',
                188: ',',
                189: '-',
                190: '.',
                191: '/',
                192: '`',
                219: '[',
                220: '\\',
                221: ']',
                222: '\'',
                63276: 'PageUp',
                63277: 'PageDown',
                63275: 'End',
                63273: 'Home',
                63234: 'Left',
                63232: 'Up',
                63235: 'Right',
                63233: 'Down',
                63302: 'Insert',
                63272: 'Delete'
            };
        CodeMirror.keyNames = keyNames;
        (function () {
            // Number keys
            for (var i = 0; i < 10; i++)
                keyNames[i + 48] = String(i);
            // Alphabetic keys
            for (var i = 65; i <= 90; i++)
                keyNames[i] = String.fromCharCode(i);
            // Function keys
            for (var i = 1; i <= 12; i++)
                keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
        }());
        // BIDI HELPERS
        function iterateBidiSections(order, from, to, f) {
            if (!order)
                return f(from, to, 'ltr');
            var found = false;
            for (var i = 0; i < order.length; ++i) {
                var part = order[i];
                if (part.from < to && part.to > from || from == to && part.to == from) {
                    f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
                    found = true;
                }
            }
            if (!found)
                f(from, to, 'ltr');
        }
        function bidiLeft(part) {
            return part.level % 2 ? part.to : part.from;
        }
        function bidiRight(part) {
            return part.level % 2 ? part.from : part.to;
        }
        function lineLeft(line) {
            var order = getOrder(line);
            return order ? bidiLeft(order[0]) : 0;
        }
        function lineRight(line) {
            var order = getOrder(line);
            if (!order)
                return line.text.length;
            return bidiRight(lst(order));
        }
        function lineStart(cm, lineN) {
            var line = getLine(cm.doc, lineN);
            var visual = visualLine(cm.doc, line);
            if (visual != line)
                lineN = lineNo(visual);
            var order = getOrder(visual);
            var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
            return Pos(lineN, ch);
        }
        function lineEnd(cm, lineN) {
            var merged, line;
            while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
                lineN = merged.find().to.line;
            var order = getOrder(line);
            var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
            return Pos(lineN, ch);
        }
        function compareBidiLevel(order, a, b) {
            var linedir = order[0].level;
            if (a == linedir)
                return true;
            if (b == linedir)
                return false;
            return a < b;
        }
        var bidiOther;
        function getBidiPartAt(order, pos) {
            for (var i = 0, found; i < order.length; ++i) {
                var cur = order[i];
                if (cur.from < pos && cur.to > pos) {
                    bidiOther = null;
                    return i;
                }
                if (cur.from == pos || cur.to == pos) {
                    if (found == null) {
                        found = i;
                    } else if (compareBidiLevel(order, cur.level, order[found].level)) {
                        bidiOther = found;
                        return i;
                    } else {
                        bidiOther = i;
                        return found;
                    }
                }
            }
            bidiOther = null;
            return found;
        }
        function moveInLine(line, pos, dir, byUnit) {
            if (!byUnit)
                return pos + dir;
            do
                pos += dir;
            while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
            return pos;
        }
        // This is somewhat involved. It is needed in order to move
        // 'visually' through bi-directional text -- i.e., pressing left
        // should make the cursor go left, even when in RTL text. The
        // tricky part is the 'jumps', where RTL and LTR text touch each
        // other. This often requires the cursor offset to move more than
        // one unit, in order to visually move one unit.
        function moveVisually(line, start, dir, byUnit) {
            var bidi = getOrder(line);
            if (!bidi)
                return moveLogically(line, start, dir, byUnit);
            var pos = getBidiPartAt(bidi, start), part = bidi[pos];
            var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
            for (;;) {
                if (target > part.from && target < part.to)
                    return target;
                if (target == part.from || target == part.to) {
                    if (getBidiPartAt(bidi, target) == pos)
                        return target;
                    part = bidi[pos += dir];
                    return dir > 0 == part.level % 2 ? part.to : part.from;
                } else {
                    part = bidi[pos += dir];
                    if (!part)
                        return null;
                    if (dir > 0 == part.level % 2)
                        target = moveInLine(line, part.to, -1, byUnit);
                    else
                        target = moveInLine(line, part.from, 1, byUnit);
                }
            }
        }
        function moveLogically(line, start, dir, byUnit) {
            var target = start + dir;
            if (byUnit)
                while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
                    target += dir;
            return target < 0 || target > line.text.length ? null : target;
        }
        // Bidirectional ordering algorithm
        // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
        // that this (partially) implements.
        // One-char codes used for character types:
        // L (L):   Left-to-Right
        // R (R):   Right-to-Left
        // r (AL):  Right-to-Left Arabic
        // 1 (EN):  European Number
        // + (ES):  European Number Separator
        // % (ET):  European Number Terminator
        // n (AN):  Arabic Number
        // , (CS):  Common Number Separator
        // m (NSM): Non-Spacing Mark
        // b (BN):  Boundary Neutral
        // s (B):   Paragraph Separator
        // t (S):   Segment Separator
        // w (WS):  Whitespace
        // N (ON):  Other Neutrals
        // Returns null if characters are ordered as they appear
        // (left-to-right), or an array of sections ({from, to, level}
        // objects) in the order in which they occur visually.
        var bidiOrdering = function () {
                // Character types for codepoints 0 to 0xff
                var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
                // Character types for codepoints 0x600 to 0x6ff
                var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
                function charType(code) {
                    if (code <= 255)
                        return lowTypes.charAt(code);
                    else if (1424 <= code && code <= 1524)
                        return 'R';
                    else if (1536 <= code && code <= 1791)
                        return arabicTypes.charAt(code - 1536);
                    else if (1792 <= code && code <= 2220)
                        return 'r';
                    else
                        return 'L';
                }
                var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
                var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
                // Browsers seem to always treat the boundaries of block elements as being L.
                var outerType = 'L';
                return function (str) {
                    if (!bidiRE.test(str))
                        return false;
                    var len = str.length, types = [];
                    for (var i = 0, type; i < len; ++i)
                        types.push(type = charType(str.charCodeAt(i)));
                    // W1. Examine each non-spacing mark (NSM) in the level run, and
                    // change the type of the NSM to the type of the previous
                    // character. If the NSM is at the start of the level run, it will
                    // get the type of sor.
                    for (var i = 0, prev = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == 'm')
                            types[i] = prev;
                        else
                            prev = type;
                    }
                    // W2. Search backwards from each instance of a European number
                    // until the first strong type (R, L, AL, or sor) is found. If an
                    // AL is found, change the type of the European number to Arabic
                    // number.
                    // W3. Change all ALs to R.
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (type == '1' && cur == 'r')
                            types[i] = 'n';
                        else if (isStrong.test(type)) {
                            cur = type;
                            if (type == 'r')
                                types[i] = 'R';
                        }
                    }
                    // W4. A single European separator between two European numbers
                    // changes to a European number. A single common separator between
                    // two numbers of the same type changes to that type.
                    for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                        var type = types[i];
                        if (type == '+' && prev == '1' && types[i + 1] == '1')
                            types[i] = '1';
                        else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
                            types[i] = prev;
                        prev = type;
                    }
                    // W5. A sequence of European terminators adjacent to European
                    // numbers changes to all European numbers.
                    // W6. Otherwise, separators and terminators change to Other
                    // Neutral.
                    for (var i = 0; i < len; ++i) {
                        var type = types[i];
                        if (type == ',')
                            types[i] = 'N';
                        else if (type == '%') {
                            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
                            }
                            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
                            for (var j = i; j < end; ++j)
                                types[j] = replace;
                            i = end - 1;
                        }
                    }
                    // W7. Search backwards from each instance of a European number
                    // until the first strong type (R, L, or sor) is found. If an L is
                    // found, then change the type of the European number to L.
                    for (var i = 0, cur = outerType; i < len; ++i) {
                        var type = types[i];
                        if (cur == 'L' && type == '1')
                            types[i] = 'L';
                        else if (isStrong.test(type))
                            cur = type;
                    }
                    // N1. A sequence of neutrals takes the direction of the
                    // surrounding strong text if the text on both sides has the same
                    // direction. European and Arabic numbers act as if they were R in
                    // terms of their influence on neutrals. Start-of-level-run (sor)
                    // and end-of-level-run (eor) are used at level run boundaries.
                    // N2. Any remaining neutrals take the embedding direction.
                    for (var i = 0; i < len; ++i) {
                        if (isNeutral.test(types[i])) {
                            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
                            }
                            var before = (i ? types[i - 1] : outerType) == 'L';
                            var after = (end < len - 1 ? types[end] : outerType) == 'L';
                            var replace = before || after ? 'L' : 'R';
                            for (var j = i; j < end; ++j)
                                types[j] = replace;
                            i = end - 1;
                        }
                    }
                    // Here we depart from the documented algorithm, in order to avoid
                    // building up an actual levels array. Since there are only three
                    // levels (0, 1, 2) in an implementation that doesn't take
                    // explicit embedding into account, we can build up the order on
                    // the fly, without following the level-based algorithm.
                    var order = [], m;
                    for (var i = 0; i < len;) {
                        if (countsAsLeft.test(types[i])) {
                            var start = i;
                            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
                            }
                            order.push({
                                from: start,
                                to: i,
                                level: 0
                            });
                        } else {
                            var pos = i, at = order.length;
                            for (++i; i < len && types[i] != 'L'; ++i) {
                            }
                            for (var j = pos; j < i;) {
                                if (countsAsNum.test(types[j])) {
                                    if (pos < j)
                                        order.splice(at, 0, {
                                            from: pos,
                                            to: j,
                                            level: 1
                                        });
                                    var nstart = j;
                                    for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                                    }
                                    order.splice(at, 0, {
                                        from: nstart,
                                        to: j,
                                        level: 2
                                    });
                                    pos = j;
                                } else
                                    ++j;
                            }
                            if (pos < i)
                                order.splice(at, 0, {
                                    from: pos,
                                    to: i,
                                    level: 1
                                });
                        }
                    }
                    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                        order[0].from = m[0].length;
                        order.unshift({
                            from: 0,
                            to: m[0].length,
                            level: 0
                        });
                    }
                    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                        lst(order).to -= m[0].length;
                        order.push({
                            from: len - m[0].length,
                            to: len,
                            level: 0
                        });
                    }
                    if (order[0].level != lst(order).level)
                        order.push({
                            from: len,
                            to: len,
                            level: order[0].level
                        });
                    return order;
                };
            }();
        // THE END
        CodeMirror.version = '3.18.1';
        return CodeMirror;
    }();
    codemirror = undefined;
    // TODO actually recognize syntax of TypeScript constructs
    CodeMirror.defineMode('javascript', function (config, parserConfig) {
        var indentUnit = config.indentUnit;
        var jsonMode = parserConfig.json;
        var isTS = parserConfig.typescript;
        // Tokenizer
        var keywords = function () {
                function kw(type) {
                    return {
                        type: type,
                        style: 'keyword'
                    };
                }
                var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c');
                var operator = kw('operator'), atom = {
                        type: 'atom',
                        style: 'atom'
                    };
                var jsKeywords = {
                        'if': A,
                        'while': A,
                        'with': A,
                        'else': B,
                        'do': B,
                        'try': B,
                        'finally': B,
                        'return': C,
                        'break': C,
                        'continue': C,
                        'new': C,
                        'delete': C,
                        'throw': C,
                        'var': kw('var'),
                        'const': kw('var'),
                        'let': kw('var'),
                        'function': kw('function'),
                        'catch': kw('catch'),
                        'for': kw('for'),
                        'switch': kw('switch'),
                        'case': kw('case'),
                        'default': kw('default'),
                        'in': operator,
                        'typeof': operator,
                        'instanceof': operator,
                        'true': atom,
                        'false': atom,
                        'null': atom,
                        'undefined': atom,
                        'NaN': atom,
                        'Infinity': atom
                    };
                // Extend the 'normal' keywords with the TypeScript language extensions
                if (isTS) {
                    var type = {
                            type: 'variable',
                            style: 'variable-3'
                        };
                    var tsKeywords = {
                            'interface': kw('interface'),
                            'class': kw('class'),
                            'extends': kw('extends'),
                            'constructor': kw('constructor'),
                            'public': kw('public'),
                            'private': kw('private'),
                            'protected': kw('protected'),
                            'static': kw('static'),
                            'super': kw('super'),
                            'string': type,
                            'number': type,
                            'bool': type,
                            'any': type
                        };
                    for (var attr in tsKeywords) {
                        jsKeywords[attr] = tsKeywords[attr];
                    }
                }
                return jsKeywords;
            }();
        var isOperatorChar = /[+\-*&%=<>!?|]/;
        function chain(stream, state, f) {
            state.tokenize = f;
            return f(stream, state);
        }
        function nextUntilUnescaped(stream, end) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
                if (next == end && !escaped)
                    return false;
                escaped = !escaped && next == '\\';
            }
            return escaped;
        }
        // Used as scratch variables to communicate multiple values without
        // consing up tons of objects.
        var type, content;
        function ret(tp, style, cont) {
            type = tp;
            content = cont;
            return style;
        }
        function jsTokenBase(stream, state) {
            var ch = stream.next();
            if (ch == '"' || ch == '\'')
                return chain(stream, state, jsTokenString(ch));
            else if (/[\[\]{}\(\),;\:\.]/.test(ch))
                return ret(ch);
            else if (ch == '0' && stream.eat(/x/i)) {
                stream.eatWhile(/[\da-f]/i);
                return ret('number', 'number');
            } else if (/\d/.test(ch) || ch == '-' && stream.eat(/\d/)) {
                stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
                return ret('number', 'number');
            } else if (ch == '/') {
                if (stream.eat('*')) {
                    return chain(stream, state, jsTokenComment);
                } else if (stream.eat('/')) {
                    stream.skipToEnd();
                    return ret('comment', 'comment');
                } else if (state.lastType == 'operator' || state.lastType == 'keyword c' || /^[\[{}\(,;:]$/.test(state.lastType)) {
                    nextUntilUnescaped(stream, '/');
                    stream.eatWhile(/[gimy]/);
                    // 'y' is "sticky" option in Mozilla
                    return ret('regexp', 'string-2');
                } else {
                    stream.eatWhile(isOperatorChar);
                    return ret('operator', null, stream.current());
                }
            } else if (ch == '#') {
                stream.skipToEnd();
                return ret('error', 'error');
            } else if (isOperatorChar.test(ch)) {
                stream.eatWhile(isOperatorChar);
                return ret('operator', null, stream.current());
            } else {
                stream.eatWhile(/[\w\$_]/);
                var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
                return known && state.lastType != '.' ? ret(known.type, known.style, word) : ret('variable', 'variable', word);
            }
        }
        function jsTokenString(quote) {
            return function (stream, state) {
                if (!nextUntilUnescaped(stream, quote))
                    state.tokenize = jsTokenBase;
                return ret('string', 'string');
            };
        }
        function jsTokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
                if (ch == '/' && maybeEnd) {
                    state.tokenize = jsTokenBase;
                    break;
                }
                maybeEnd = ch == '*';
            }
            return ret('comment', 'comment');
        }
        // Parser
        var atomicTypes = {
                'atom': true,
                'number': true,
                'variable': true,
                'string': true,
                'regexp': true
            };
        function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type;
            this.prev = prev;
            this.info = info;
            if (align != null)
                this.align = align;
        }
        function inScope(state, varname) {
            for (var v = state.localVars; v; v = v.next)
                if (v.name == varname)
                    return true;
        }
        function parseJS(state, style, type, content, stream) {
            var cc = state.cc;
            // Communicate our context to the combinators.
            // (Less wasteful than consing up a hundred closures on every call.)
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            if (!state.lexical.hasOwnProperty('align'))
                state.lexical.align = true;
            while (true) {
                var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                if (combinator(type, content)) {
                    while (cc.length && cc[cc.length - 1].lex)
                        cc.pop()();
                    if (cx.marked)
                        return cx.marked;
                    if (type == 'variable' && inScope(state, content))
                        return 'variable-2';
                    return style;
                }
            }
        }
        // Combinator utils
        var cx = {
                state: null,
                column: null,
                marked: null,
                cc: null
            };
        function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
                cx.cc.push(arguments[i]);
        }
        function cont() {
            pass.apply(null, arguments);
            return true;
        }
        function register(varname) {
            var state = cx.state;
            if (state.context) {
                cx.marked = 'def';
                for (var v = state.localVars; v; v = v.next)
                    if (v.name == varname)
                        return;
                state.localVars = {
                    name: varname,
                    next: state.localVars
                };
            }
        }
        // Combinators
        var defaultVars = {
                name: 'this',
                next: { name: 'arguments' }
            };
        function pushcontext() {
            cx.state.context = {
                prev: cx.state.context,
                vars: cx.state.localVars
            };
            cx.state.localVars = defaultVars;
        }
        function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
        }
        function pushlex(type, info) {
            var result = function () {
                var state = cx.state;
                state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
            };
            result.lex = true;
            return result;
        }
        function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
                if (state.lexical.type == ')')
                    state.indented = state.lexical.indented;
                state.lexical = state.lexical.prev;
            }
        }
        poplex.lex = true;
        function expect(wanted) {
            return function expecting(type) {
                if (type == wanted)
                    return cont();
                else if (wanted == ';')
                    return pass();
                else
                    return cont(arguments.callee);
            };
        }
        function statement(type) {
            if (type == 'var')
                return cont(pushlex('vardef'), vardef1, expect(';'), poplex);
            if (type == 'keyword a')
                return cont(pushlex('form'), expression, statement, poplex);
            if (type == 'keyword b')
                return cont(pushlex('form'), statement, poplex);
            if (type == '{')
                return cont(pushlex('}'), block, poplex);
            if (type == ';')
                return cont();
            if (type == 'function')
                return cont(functiondef);
            if (type == 'for')
                return cont(pushlex('form'), expect('('), pushlex(')'), forspec1, expect(')'), poplex, statement, poplex);
            if (type == 'variable')
                return cont(pushlex('stat'), maybelabel);
            if (type == 'switch')
                return cont(pushlex('form'), expression, pushlex('}', 'switch'), expect('{'), block, poplex, poplex);
            if (type == 'case')
                return cont(expression, expect(':'));
            if (type == 'default')
                return cont(expect(':'));
            if (type == 'catch')
                return cont(pushlex('form'), pushcontext, expect('('), funarg, expect(')'), statement, poplex, popcontext);
            return pass(pushlex('stat'), expression, expect(';'), poplex);
        }
        function expression(type) {
            if (atomicTypes.hasOwnProperty(type))
                return cont(maybeoperator);
            if (type == 'function')
                return cont(functiondef);
            if (type == 'keyword c')
                return cont(maybeexpression);
            if (type == '(')
                return cont(pushlex(')'), maybeexpression, expect(')'), poplex, maybeoperator);
            if (type == 'operator')
                return cont(expression);
            if (type == '[')
                return cont(pushlex(']'), commasep(expression, ']'), poplex, maybeoperator);
            if (type == '{')
                return cont(pushlex('}'), commasep(objprop, '}'), poplex, maybeoperator);
            return cont();
        }
        function maybeexpression(type) {
            if (type.match(/[;\}\)\],]/))
                return pass();
            return pass(expression);
        }
        function maybeoperator(type, value) {
            if (type == 'operator' && /\+\+|--/.test(value))
                return cont(maybeoperator);
            if (type == 'operator' && value == '?')
                return cont(expression, expect(':'), expression);
            if (type == ';')
                return;
            if (type == '(')
                return cont(pushlex(')'), commasep(expression, ')'), poplex, maybeoperator);
            if (type == '.')
                return cont(property, maybeoperator);
            if (type == '[')
                return cont(pushlex(']'), expression, expect(']'), poplex, maybeoperator);
        }
        function maybelabel(type) {
            if (type == ':')
                return cont(poplex, statement);
            return pass(maybeoperator, expect(';'), poplex);
        }
        function property(type) {
            if (type == 'variable') {
                cx.marked = 'property';
                return cont();
            }
        }
        function objprop(type) {
            if (type == 'variable')
                cx.marked = 'property';
            if (atomicTypes.hasOwnProperty(type))
                return cont(expect(':'), expression);
        }
        function commasep(what, end) {
            function proceed(type) {
                if (type == ',')
                    return cont(what, proceed);
                if (type == end)
                    return cont();
                return cont(expect(end));
            }
            return function commaSeparated(type) {
                if (type == end)
                    return cont();
                else
                    return pass(what, proceed);
            };
        }
        function block(type) {
            if (type == '}')
                return cont();
            return pass(statement, block);
        }
        function maybetype(type) {
            if (type == ':')
                return cont(typedef);
            return pass();
        }
        function typedef(type) {
            if (type == 'variable') {
                cx.marked = 'variable-3';
                return cont();
            }
            return pass();
        }
        function vardef1(type, value) {
            if (type == 'variable') {
                register(value);
                return isTS ? cont(maybetype, vardef2) : cont(vardef2);
            }
            return pass();
        }
        function vardef2(type, value) {
            if (value == '=')
                return cont(expression, vardef2);
            if (type == ',')
                return cont(vardef1);
        }
        function forspec1(type) {
            if (type == 'var')
                return cont(vardef1, expect(';'), forspec2);
            if (type == ';')
                return cont(forspec2);
            if (type == 'variable')
                return cont(formaybein);
            return cont(forspec2);
        }
        function formaybein(type, value) {
            if (value == 'in')
                return cont(expression);
            return cont(maybeoperator, forspec2);
        }
        function forspec2(type, value) {
            if (type == ';')
                return cont(forspec3);
            if (value == 'in')
                return cont(expression);
            return cont(expression, expect(';'), forspec3);
        }
        function forspec3(type) {
            if (type != ')')
                cont(expression);
        }
        function functiondef(type, value) {
            if (type == 'variable') {
                register(value);
                return cont(functiondef);
            }
            if (type == '(')
                return cont(pushlex(')'), pushcontext, commasep(funarg, ')'), poplex, statement, popcontext);
        }
        function funarg(type, value) {
            if (type == 'variable') {
                register(value);
                return isTS ? cont(maybetype) : cont();
            }
        }
        // Interface
        return {
            startState: function (basecolumn) {
                return {
                    tokenize: jsTokenBase,
                    lastType: null,
                    cc: [],
                    lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),
                    localVars: parserConfig.localVars,
                    context: parserConfig.localVars && { vars: parserConfig.localVars },
                    indented: 0
                };
            },
            token: function (stream, state) {
                if (stream.sol()) {
                    if (!state.lexical.hasOwnProperty('align'))
                        state.lexical.align = false;
                    state.indented = stream.indentation();
                }
                if (stream.eatSpace())
                    return null;
                var style = state.tokenize(stream, state);
                if (type == 'comment')
                    return style;
                state.lastType = type;
                return parseJS(state, style, type, content, stream);
            },
            indent: function (state, textAfter) {
                if (state.tokenize == jsTokenComment)
                    return CodeMirror.Pass;
                if (state.tokenize != jsTokenBase)
                    return 0;
                var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                if (lexical.type == 'stat' && firstChar == '}')
                    lexical = lexical.prev;
                var type = lexical.type, closing = firstChar == type;
                if (type == 'vardef')
                    return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? 4 : 0);
                else if (type == 'form' && firstChar == '{')
                    return lexical.indented;
                else if (type == 'form')
                    return lexical.indented + indentUnit;
                else if (type == 'stat')
                    return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? indentUnit : 0);
                else if (lexical.info == 'switch' && !closing)
                    return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                else if (lexical.align)
                    return lexical.column + (closing ? 0 : 1);
                else
                    return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricChars: ':{}',
            jsonMode: jsonMode
        };
    });
    CodeMirror.defineMIME('text/javascript', 'javascript');
    CodeMirror.defineMIME('application/json', {
        name: 'javascript',
        json: true
    });
    CodeMirror.defineMIME('text/typescript', {
        name: 'javascript',
        typescript: true
    });
    CodeMirror.defineMIME('application/typescript', {
        name: 'javascript',
        typescript: true
    });
    codemirror_javascript = undefined;
    (function () {
        var DEFAULT_BRACKETS = '()[]{}\'\'""';
        var DEFAULT_EXPLODE_ON_ENTER = '[]{}';
        var SPACE_CHAR_REGEX = /\s/;
        CodeMirror.defineOption('autoCloseBrackets', false, function (cm, val, old) {
            if (old != CodeMirror.Init && old)
                cm.removeKeyMap('autoCloseBrackets');
            if (!val)
                return;
            var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;
            if (typeof val == 'string')
                pairs = val;
            else if (typeof val == 'object') {
                if (val.pairs != null)
                    pairs = val.pairs;
                if (val.explode != null)
                    explode = val.explode;
            }
            var map = buildKeymap(pairs);
            if (explode)
                map.Enter = buildExplodeHandler(explode);
            cm.addKeyMap(map);
        });
        function charsAround(cm, pos) {
            var str = cm.getRange(CodeMirror.Pos(pos.line, pos.ch - 1), CodeMirror.Pos(pos.line, pos.ch + 1));
            return str.length == 2 ? str : null;
        }
        function buildKeymap(pairs) {
            var map = {
                    name: 'autoCloseBrackets',
                    Backspace: function (cm) {
                        if (cm.somethingSelected())
                            return CodeMirror.Pass;
                        var cur = cm.getCursor(), around = charsAround(cm, cur);
                        if (around && pairs.indexOf(around) % 2 == 0)
                            cm.replaceRange('', CodeMirror.Pos(cur.line, cur.ch - 1), CodeMirror.Pos(cur.line, cur.ch + 1));
                        else
                            return CodeMirror.Pass;
                    }
                };
            var closingBrackets = '';
            for (var i = 0; i < pairs.length; i += 2)
                (function (left, right) {
                    if (left != right)
                        closingBrackets += right;
                    function surround(cm) {
                        var selection = cm.getSelection();
                        cm.replaceSelection(left + selection + right);
                    }
                    function maybeOverwrite(cm) {
                        var cur = cm.getCursor(), ahead = cm.getRange(cur, CodeMirror.Pos(cur.line, cur.ch + 1));
                        if (ahead != right || cm.somethingSelected())
                            return CodeMirror.Pass;
                        else
                            cm.execCommand('goCharRight');
                    }
                    map['\'' + left + '\''] = function (cm) {
                        if (left == '\'' && cm.getTokenAt(cm.getCursor()).type == 'comment')
                            return CodeMirror.Pass;
                        if (cm.somethingSelected())
                            return surround(cm);
                        if (left == right && maybeOverwrite(cm) != CodeMirror.Pass)
                            return;
                        var cur = cm.getCursor(), ahead = CodeMirror.Pos(cur.line, cur.ch + 1);
                        var line = cm.getLine(cur.line), nextChar = line.charAt(cur.ch), curChar = cur.ch > 0 ? line.charAt(cur.ch - 1) : '';
                        if (left == right && CodeMirror.isWordChar(curChar))
                            return CodeMirror.Pass;
                        if (line.length == cur.ch || closingBrackets.indexOf(nextChar) >= 0 || SPACE_CHAR_REGEX.test(nextChar))
                            cm.replaceSelection(left + right, {
                                head: ahead,
                                anchor: ahead
                            });
                        else
                            return CodeMirror.Pass;
                    };
                    if (left != right)
                        map['\'' + right + '\''] = maybeOverwrite;
                }(pairs.charAt(i), pairs.charAt(i + 1)));
            return map;
        }
        function buildExplodeHandler(pairs) {
            return function (cm) {
                var cur = cm.getCursor(), around = charsAround(cm, cur);
                if (!around || pairs.indexOf(around) % 2 != 0)
                    return CodeMirror.Pass;
                cm.operation(function () {
                    var newPos = CodeMirror.Pos(cur.line + 1, 0);
                    cm.replaceSelection('\n\n', {
                        anchor: newPos,
                        head: newPos
                    }, '+input');
                    cm.indentLine(cur.line + 1, null, true);
                    cm.indentLine(cur.line + 2, null, true);
                });
            };
        }
    }());
    codemirror_closebrackets = undefined;
    (function () {
        var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
        var Pos = CodeMirror.Pos;
        var matching = {
                '(': ')>',
                ')': '(<',
                '[': ']>',
                ']': '[<',
                '{': '}>',
                '}': '{<'
            };
        function findMatchingBracket(cm, where, strict) {
            var state = cm.state.matchBrackets;
            var maxScanLen = state && state.maxScanLineLength || 10000;
            var cur = where || cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;
            var match = pos >= 0 && matching[line.text.charAt(pos)] || matching[line.text.charAt(++pos)];
            if (!match)
                return null;
            var forward = match.charAt(1) == '>', d = forward ? 1 : -1;
            if (strict && forward != (pos == cur.ch))
                return null;
            var style = cm.getTokenTypeAt(Pos(cur.line, pos + 1));
            var stack = [line.text.charAt(pos)], re = /[(){}[\]]/;
            function scan(line, lineNo, start) {
                if (!line.text)
                    return;
                var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;
                if (line.text.length > maxScanLen)
                    return null;
                if (start != null)
                    pos = start + d;
                for (; pos != end; pos += d) {
                    var ch = line.text.charAt(pos);
                    if (re.test(ch) && cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style) {
                        var match = matching[ch];
                        if (match.charAt(1) == '>' == forward)
                            stack.push(ch);
                        else if (stack.pop() != match.charAt(0))
                            return {
                                pos: pos,
                                match: false
                            };
                        else if (!stack.length)
                            return {
                                pos: pos,
                                match: true
                            };
                    }
                }
            }
            for (var i = cur.line, found, e = forward ? Math.min(i + 100, cm.lineCount()) : Math.max(-1, i - 100); i != e; i += d) {
                if (i == cur.line)
                    found = scan(line, i, pos);
                else
                    found = scan(cm.getLineHandle(i), i);
                if (found)
                    break;
            }
            return {
                from: Pos(cur.line, pos),
                to: found && Pos(i, found.pos),
                match: found && found.match,
                forward: forward
            };
        }
        function matchBrackets(cm, autoclear) {
            // Disable brace matching in long lines, since it'll cause hugely slow updates
            var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
            var found = findMatchingBracket(cm);
            if (!found || cm.getLine(found.from.line).length > maxHighlightLen || found.to && cm.getLine(found.to.line).length > maxHighlightLen)
                return;
            var style = found.match ? 'CodeMirror-matchingbracket' : 'CodeMirror-nonmatchingbracket';
            var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), { className: style });
            var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), { className: style });
            // Kludge to work around the IE bug from issue #1193, where text
            // input stops going to the textare whever this fires.
            if (ie_lt8 && cm.state.focused)
                cm.display.input.focus();
            var clear = function () {
                cm.operation(function () {
                    one.clear();
                    two && two.clear();
                });
            };
            if (autoclear)
                setTimeout(clear, 800);
            else
                return clear;
        }
        var currentlyHighlighted = null;
        function doMatchBrackets(cm) {
            cm.operation(function () {
                if (currentlyHighlighted) {
                    currentlyHighlighted();
                    currentlyHighlighted = null;
                }
                if (!cm.somethingSelected())
                    currentlyHighlighted = matchBrackets(cm, false);
            });
        }
        CodeMirror.defineOption('matchBrackets', false, function (cm, val, old) {
            if (old && old != CodeMirror.Init)
                cm.off('cursorActivity', doMatchBrackets);
            if (val) {
                cm.state.matchBrackets = typeof val == 'object' ? val : {};
                cm.on('cursorActivity', doMatchBrackets);
            }
        });
        CodeMirror.defineExtension('matchBrackets', function () {
            matchBrackets(this, true);
        });
        CodeMirror.defineExtension('findMatchingBracket', function (pos, strict) {
            return findMatchingBracket(this, pos, strict);
        });
    }());
    codemirror_matchbrackets = undefined;
    views_View = function ($, Backbone, _) {
        var View = Backbone.View.extend({
                el: 'body',
                initialize: function () {
                    var urlCode = this.getParameter('code');
                    this.amdTextarea = $('#amd-textarea');
                    this.standardTextarea = $('#standard-textarea');
                    this.autoRunJS = $('#auto-run-checkbox');
                    this.aggressiveOptimizations = $('#aggressive-optimizations-checkbox');
                    this.standardTextarea.val(amdclean.clean({
                        'code': this.amdTextarea.val(),
                        'aggressiveOptimizations': this.aggressiveOptimizations.is(':checked') ? true : false
                    }));
                    this.amdEditor = CodeMirror.fromTextArea(document.getElementById('amd-textarea'), {
                        mode: 'javascript',
                        tabMode: 'indent',
                        lineNumbers: true,
                        matchBrackets: true,
                        theme: 'xq-light',
                        autoCloseBrackets: true
                    });
                    this.standardEditor = CodeMirror.fromTextArea(document.getElementById('standard-textarea'), {
                        mode: 'javascript',
                        tabMode: 'indent',
                        lineNumbers: true,
                        readOnly: true,
                        cursorHeight: 0
                    });
                    this.amdEditor.on('change', _.bind(function () {
                        if (this.autoRunJS.is(':checked')) {
                            this.optimizeCode();
                        }
                    }, this));
                    this.codeError = $('.code-error');
                    this.linkToShare = $('#link-to-share');
                    this.linkToShareContainer = $('.link-to-share-container');
                    if (urlCode) {
                        this.amdEditor.setValue(window.escodegen.generate(esprima.parse(decodeURIComponent(urlCode))));
                    }
                },
                events: {
                    'click .clean-btn': 'optimizeCode',
                    'click #aggressive-optimizations-checkbox': 'optimizeCode',
                    'change #auto-run-checkbox': 'autorun',
                    'click .restore-to-defaults': 'restoreToDefaults',
                    'click a[href=#]': function (e) {
                        e.preventDefault();
                    }
                },
                optimizeCode: function () {
                    try {
                        var cleanedCode = amdclean.clean({
                                'code': $.trim(this.amdEditor.getValue()),
                                'aggressiveOptimizations': this.aggressiveOptimizations.is(':checked') ? true : false
                            });
                        this.standardEditor.setValue(cleanedCode);
                        this.codeError.empty().hide();
                        this.linkToShare.val(this.buildURL());
                        this.linkToShareContainer.fadeIn();
                    } catch (e) {
                        if (e.lineNumber && e.column && e.description) {
                            this.codeError.html('Description: ' + e.description + '<br><br>Line Number: ' + e.lineNumber + '<br><br>Column: ' + e.column).show();
                            this.standardEditor.setValue('');
                        }
                    }
                },
                getParameter: function (paramName) {
                    var searchString = window.location.search.substring(1), i, val, params = searchString.split('&');
                    for (i = 0; i < params.length; i++) {
                        val = params[i].split('=');
                        if (val[0] == paramName) {
                            return val[1];
                        }
                    }
                    return null;
                },
                autorun: function () {
                    if (this.autoRunJS.is(':checked')) {
                        this.optimizeCode();
                    }
                },
                buildURL: function () {
                    return location.protocol + '//' + location.host + location.pathname + '?code=' + encodeURIComponent(this.amdEditor.getValue());
                },
                restoreToDefaults: function () {
                    this.amdEditor.setValue(window.escodegen.generate(esprima.parse(decodeURIComponent(this.defaultAMDCode))));
                },
                defaultAMDCode: 'define(\'example\', [], function() {return \'Convert AMD code to standard JavaScript\';});'
            });
        // Returns the View class
        return View;
    }(jquery, backbone, underscore);
    routers_router = function ($, Backbone, View) {
        var Router = Backbone.Router.extend({
                initialize: function () {
                    // Tells Backbone to start watching for hashchange events
                    Backbone.history.start();
                },
                routes: { '': 'index' },
                index: function () {
                    // Instantiates a new view which will render the header text to the page
                    new View();
                }
            });
        // Returns the DesktopRouter class
        return Router;
    }(jquery, backbone, views_View);
    (function ($, Backbone, DesktopRouter) {
        // Instantiates a new Desktop Router instance
        new DesktopRouter();
    }(jquery, backbone, routers_router));
    desktop = undefined;
}());}());